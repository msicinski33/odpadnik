
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Fraction
 * 
 */
export type Fraction = $Result.DefaultSelection<Prisma.$FractionPayload>
/**
 * Model Point
 * 
 */
export type Point = $Result.DefaultSelection<Prisma.$PointPayload>
/**
 * Model PointFraction
 * 
 */
export type PointFraction = $Result.DefaultSelection<Prisma.$PointFractionPayload>
/**
 * Model EmployeeSchedule
 * 
 */
export type EmployeeSchedule = $Result.DefaultSelection<Prisma.$EmployeeSchedulePayload>
/**
 * Model RegionFraction
 * 
 */
export type RegionFraction = $Result.DefaultSelection<Prisma.$RegionFractionPayload>
/**
 * Model CalendarEntry
 * 
 */
export type CalendarEntry = $Result.DefaultSelection<Prisma.$CalendarEntryPayload>
/**
 * Model DailyAssignment
 * 
 */
export type DailyAssignment = $Result.DefaultSelection<Prisma.$DailyAssignmentPayload>
/**
 * Model DailyAssignmentAssistant
 * 
 */
export type DailyAssignmentAssistant = $Result.DefaultSelection<Prisma.$DailyAssignmentAssistantPayload>
/**
 * Model DailyAssignmentFraction
 * 
 */
export type DailyAssignmentFraction = $Result.DefaultSelection<Prisma.$DailyAssignmentFractionPayload>
/**
 * Model VehicleFaultReport
 * 
 */
export type VehicleFaultReport = $Result.DefaultSelection<Prisma.$VehicleFaultReportPayload>
/**
 * Model WorkOrder
 * 
 */
export type WorkOrder = $Result.DefaultSelection<Prisma.$WorkOrderPayload>
/**
 * Model Municipality
 * 
 */
export type Municipality = $Result.DefaultSelection<Prisma.$MunicipalityPayload>
/**
 * Model RodzajAbsencji
 * 
 */
export type RodzajAbsencji = $Result.DefaultSelection<Prisma.$RodzajAbsencjiPayload>
/**
 * Model WorkCardEntry
 * 
 */
export type WorkCardEntry = $Result.DefaultSelection<Prisma.$WorkCardEntryPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentAttachment
 * 
 */
export type DocumentAttachment = $Result.DefaultSelection<Prisma.$DocumentAttachmentPayload>
/**
 * Model DocumentAnnotation
 * 
 */
export type DocumentAnnotation = $Result.DefaultSelection<Prisma.$DocumentAnnotationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DailyAssignmentType: {
  bezpylne: 'bezpylne',
  sprzątanie: 'sprzątanie'
};

export type DailyAssignmentType = (typeof DailyAssignmentType)[keyof typeof DailyAssignmentType]

}

export type DailyAssignmentType = $Enums.DailyAssignmentType

export const DailyAssignmentType: typeof $Enums.DailyAssignmentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fraction`: Exposes CRUD operations for the **Fraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fractions
    * const fractions = await prisma.fraction.findMany()
    * ```
    */
  get fraction(): Prisma.FractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.point`: Exposes CRUD operations for the **Point** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Points
    * const points = await prisma.point.findMany()
    * ```
    */
  get point(): Prisma.PointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointFraction`: Exposes CRUD operations for the **PointFraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointFractions
    * const pointFractions = await prisma.pointFraction.findMany()
    * ```
    */
  get pointFraction(): Prisma.PointFractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeSchedule`: Exposes CRUD operations for the **EmployeeSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeSchedules
    * const employeeSchedules = await prisma.employeeSchedule.findMany()
    * ```
    */
  get employeeSchedule(): Prisma.EmployeeScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regionFraction`: Exposes CRUD operations for the **RegionFraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionFractions
    * const regionFractions = await prisma.regionFraction.findMany()
    * ```
    */
  get regionFraction(): Prisma.RegionFractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarEntry`: Exposes CRUD operations for the **CalendarEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEntries
    * const calendarEntries = await prisma.calendarEntry.findMany()
    * ```
    */
  get calendarEntry(): Prisma.CalendarEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyAssignment`: Exposes CRUD operations for the **DailyAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyAssignments
    * const dailyAssignments = await prisma.dailyAssignment.findMany()
    * ```
    */
  get dailyAssignment(): Prisma.DailyAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyAssignmentAssistant`: Exposes CRUD operations for the **DailyAssignmentAssistant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyAssignmentAssistants
    * const dailyAssignmentAssistants = await prisma.dailyAssignmentAssistant.findMany()
    * ```
    */
  get dailyAssignmentAssistant(): Prisma.DailyAssignmentAssistantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyAssignmentFraction`: Exposes CRUD operations for the **DailyAssignmentFraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyAssignmentFractions
    * const dailyAssignmentFractions = await prisma.dailyAssignmentFraction.findMany()
    * ```
    */
  get dailyAssignmentFraction(): Prisma.DailyAssignmentFractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleFaultReport`: Exposes CRUD operations for the **VehicleFaultReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleFaultReports
    * const vehicleFaultReports = await prisma.vehicleFaultReport.findMany()
    * ```
    */
  get vehicleFaultReport(): Prisma.VehicleFaultReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workOrder`: Exposes CRUD operations for the **WorkOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrders
    * const workOrders = await prisma.workOrder.findMany()
    * ```
    */
  get workOrder(): Prisma.WorkOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.municipality`: Exposes CRUD operations for the **Municipality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipalities
    * const municipalities = await prisma.municipality.findMany()
    * ```
    */
  get municipality(): Prisma.MunicipalityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rodzajAbsencji`: Exposes CRUD operations for the **RodzajAbsencji** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RodzajAbsencjis
    * const rodzajAbsencjis = await prisma.rodzajAbsencji.findMany()
    * ```
    */
  get rodzajAbsencji(): Prisma.RodzajAbsencjiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workCardEntry`: Exposes CRUD operations for the **WorkCardEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkCardEntries
    * const workCardEntries = await prisma.workCardEntry.findMany()
    * ```
    */
  get workCardEntry(): Prisma.WorkCardEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentAttachment`: Exposes CRUD operations for the **DocumentAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAttachments
    * const documentAttachments = await prisma.documentAttachment.findMany()
    * ```
    */
  get documentAttachment(): Prisma.DocumentAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentAnnotation`: Exposes CRUD operations for the **DocumentAnnotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAnnotations
    * const documentAnnotations = await prisma.documentAnnotation.findMany()
    * ```
    */
  get documentAnnotation(): Prisma.DocumentAnnotationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Employee: 'Employee',
    Vehicle: 'Vehicle',
    Region: 'Region',
    Fraction: 'Fraction',
    Point: 'Point',
    PointFraction: 'PointFraction',
    EmployeeSchedule: 'EmployeeSchedule',
    RegionFraction: 'RegionFraction',
    CalendarEntry: 'CalendarEntry',
    DailyAssignment: 'DailyAssignment',
    DailyAssignmentAssistant: 'DailyAssignmentAssistant',
    DailyAssignmentFraction: 'DailyAssignmentFraction',
    VehicleFaultReport: 'VehicleFaultReport',
    WorkOrder: 'WorkOrder',
    Municipality: 'Municipality',
    RodzajAbsencji: 'RodzajAbsencji',
    WorkCardEntry: 'WorkCardEntry',
    Document: 'Document',
    DocumentAttachment: 'DocumentAttachment',
    DocumentAnnotation: 'DocumentAnnotation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "employee" | "vehicle" | "region" | "fraction" | "point" | "pointFraction" | "employeeSchedule" | "regionFraction" | "calendarEntry" | "dailyAssignment" | "dailyAssignmentAssistant" | "dailyAssignmentFraction" | "vehicleFaultReport" | "workOrder" | "municipality" | "rodzajAbsencji" | "workCardEntry" | "document" | "documentAttachment" | "documentAnnotation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Fraction: {
        payload: Prisma.$FractionPayload<ExtArgs>
        fields: Prisma.FractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>
          }
          findFirst: {
            args: Prisma.FractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>
          }
          findMany: {
            args: Prisma.FractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>[]
          }
          create: {
            args: Prisma.FractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>
          }
          createMany: {
            args: Prisma.FractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>[]
          }
          delete: {
            args: Prisma.FractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>
          }
          update: {
            args: Prisma.FractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>
          }
          deleteMany: {
            args: Prisma.FractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>[]
          }
          upsert: {
            args: Prisma.FractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FractionPayload>
          }
          aggregate: {
            args: Prisma.FractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFraction>
          }
          groupBy: {
            args: Prisma.FractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FractionCountArgs<ExtArgs>
            result: $Utils.Optional<FractionCountAggregateOutputType> | number
          }
        }
      }
      Point: {
        payload: Prisma.$PointPayload<ExtArgs>
        fields: Prisma.PointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>
          }
          findFirst: {
            args: Prisma.PointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>
          }
          findMany: {
            args: Prisma.PointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>[]
          }
          create: {
            args: Prisma.PointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>
          }
          createMany: {
            args: Prisma.PointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>[]
          }
          delete: {
            args: Prisma.PointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>
          }
          update: {
            args: Prisma.PointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>
          }
          deleteMany: {
            args: Prisma.PointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>[]
          }
          upsert: {
            args: Prisma.PointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointPayload>
          }
          aggregate: {
            args: Prisma.PointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoint>
          }
          groupBy: {
            args: Prisma.PointGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointCountArgs<ExtArgs>
            result: $Utils.Optional<PointCountAggregateOutputType> | number
          }
        }
      }
      PointFraction: {
        payload: Prisma.$PointFractionPayload<ExtArgs>
        fields: Prisma.PointFractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointFractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointFractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>
          }
          findFirst: {
            args: Prisma.PointFractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointFractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>
          }
          findMany: {
            args: Prisma.PointFractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>[]
          }
          create: {
            args: Prisma.PointFractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>
          }
          createMany: {
            args: Prisma.PointFractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointFractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>[]
          }
          delete: {
            args: Prisma.PointFractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>
          }
          update: {
            args: Prisma.PointFractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>
          }
          deleteMany: {
            args: Prisma.PointFractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointFractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointFractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>[]
          }
          upsert: {
            args: Prisma.PointFractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointFractionPayload>
          }
          aggregate: {
            args: Prisma.PointFractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointFraction>
          }
          groupBy: {
            args: Prisma.PointFractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointFractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointFractionCountArgs<ExtArgs>
            result: $Utils.Optional<PointFractionCountAggregateOutputType> | number
          }
        }
      }
      EmployeeSchedule: {
        payload: Prisma.$EmployeeSchedulePayload<ExtArgs>
        fields: Prisma.EmployeeScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>
          }
          findFirst: {
            args: Prisma.EmployeeScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>
          }
          findMany: {
            args: Prisma.EmployeeScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>[]
          }
          create: {
            args: Prisma.EmployeeScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>
          }
          createMany: {
            args: Prisma.EmployeeScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>[]
          }
          delete: {
            args: Prisma.EmployeeScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>
          }
          update: {
            args: Prisma.EmployeeScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeSchedulePayload>
          }
          aggregate: {
            args: Prisma.EmployeeScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeSchedule>
          }
          groupBy: {
            args: Prisma.EmployeeScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeScheduleCountAggregateOutputType> | number
          }
        }
      }
      RegionFraction: {
        payload: Prisma.$RegionFractionPayload<ExtArgs>
        fields: Prisma.RegionFractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>
          }
          findFirst: {
            args: Prisma.RegionFractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>
          }
          findMany: {
            args: Prisma.RegionFractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>[]
          }
          create: {
            args: Prisma.RegionFractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>
          }
          createMany: {
            args: Prisma.RegionFractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionFractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>[]
          }
          delete: {
            args: Prisma.RegionFractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>
          }
          update: {
            args: Prisma.RegionFractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>
          }
          deleteMany: {
            args: Prisma.RegionFractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionFractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionFractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>[]
          }
          upsert: {
            args: Prisma.RegionFractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionFractionPayload>
          }
          aggregate: {
            args: Prisma.RegionFractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegionFraction>
          }
          groupBy: {
            args: Prisma.RegionFractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionFractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionFractionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionFractionCountAggregateOutputType> | number
          }
        }
      }
      CalendarEntry: {
        payload: Prisma.$CalendarEntryPayload<ExtArgs>
        fields: Prisma.CalendarEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          findFirst: {
            args: Prisma.CalendarEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          findMany: {
            args: Prisma.CalendarEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>[]
          }
          create: {
            args: Prisma.CalendarEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          createMany: {
            args: Prisma.CalendarEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>[]
          }
          delete: {
            args: Prisma.CalendarEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          update: {
            args: Prisma.CalendarEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CalendarEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>[]
          }
          upsert: {
            args: Prisma.CalendarEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEntryPayload>
          }
          aggregate: {
            args: Prisma.CalendarEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEntry>
          }
          groupBy: {
            args: Prisma.CalendarEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEntryCountAggregateOutputType> | number
          }
        }
      }
      DailyAssignment: {
        payload: Prisma.$DailyAssignmentPayload<ExtArgs>
        fields: Prisma.DailyAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DailyAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>
          }
          findMany: {
            args: Prisma.DailyAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>[]
          }
          create: {
            args: Prisma.DailyAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>
          }
          createMany: {
            args: Prisma.DailyAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>[]
          }
          delete: {
            args: Prisma.DailyAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>
          }
          update: {
            args: Prisma.DailyAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DailyAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.DailyAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DailyAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyAssignment>
          }
          groupBy: {
            args: Prisma.DailyAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DailyAssignmentCountAggregateOutputType> | number
          }
        }
      }
      DailyAssignmentAssistant: {
        payload: Prisma.$DailyAssignmentAssistantPayload<ExtArgs>
        fields: Prisma.DailyAssignmentAssistantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyAssignmentAssistantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyAssignmentAssistantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>
          }
          findFirst: {
            args: Prisma.DailyAssignmentAssistantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyAssignmentAssistantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>
          }
          findMany: {
            args: Prisma.DailyAssignmentAssistantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>[]
          }
          create: {
            args: Prisma.DailyAssignmentAssistantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>
          }
          createMany: {
            args: Prisma.DailyAssignmentAssistantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyAssignmentAssistantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>[]
          }
          delete: {
            args: Prisma.DailyAssignmentAssistantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>
          }
          update: {
            args: Prisma.DailyAssignmentAssistantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>
          }
          deleteMany: {
            args: Prisma.DailyAssignmentAssistantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyAssignmentAssistantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyAssignmentAssistantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>[]
          }
          upsert: {
            args: Prisma.DailyAssignmentAssistantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentAssistantPayload>
          }
          aggregate: {
            args: Prisma.DailyAssignmentAssistantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyAssignmentAssistant>
          }
          groupBy: {
            args: Prisma.DailyAssignmentAssistantGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyAssignmentAssistantGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyAssignmentAssistantCountArgs<ExtArgs>
            result: $Utils.Optional<DailyAssignmentAssistantCountAggregateOutputType> | number
          }
        }
      }
      DailyAssignmentFraction: {
        payload: Prisma.$DailyAssignmentFractionPayload<ExtArgs>
        fields: Prisma.DailyAssignmentFractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyAssignmentFractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyAssignmentFractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>
          }
          findFirst: {
            args: Prisma.DailyAssignmentFractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyAssignmentFractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>
          }
          findMany: {
            args: Prisma.DailyAssignmentFractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>[]
          }
          create: {
            args: Prisma.DailyAssignmentFractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>
          }
          createMany: {
            args: Prisma.DailyAssignmentFractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyAssignmentFractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>[]
          }
          delete: {
            args: Prisma.DailyAssignmentFractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>
          }
          update: {
            args: Prisma.DailyAssignmentFractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>
          }
          deleteMany: {
            args: Prisma.DailyAssignmentFractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyAssignmentFractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyAssignmentFractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>[]
          }
          upsert: {
            args: Prisma.DailyAssignmentFractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyAssignmentFractionPayload>
          }
          aggregate: {
            args: Prisma.DailyAssignmentFractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyAssignmentFraction>
          }
          groupBy: {
            args: Prisma.DailyAssignmentFractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyAssignmentFractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyAssignmentFractionCountArgs<ExtArgs>
            result: $Utils.Optional<DailyAssignmentFractionCountAggregateOutputType> | number
          }
        }
      }
      VehicleFaultReport: {
        payload: Prisma.$VehicleFaultReportPayload<ExtArgs>
        fields: Prisma.VehicleFaultReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFaultReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFaultReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>
          }
          findFirst: {
            args: Prisma.VehicleFaultReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFaultReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>
          }
          findMany: {
            args: Prisma.VehicleFaultReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>[]
          }
          create: {
            args: Prisma.VehicleFaultReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>
          }
          createMany: {
            args: Prisma.VehicleFaultReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleFaultReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>[]
          }
          delete: {
            args: Prisma.VehicleFaultReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>
          }
          update: {
            args: Prisma.VehicleFaultReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>
          }
          deleteMany: {
            args: Prisma.VehicleFaultReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleFaultReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleFaultReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>[]
          }
          upsert: {
            args: Prisma.VehicleFaultReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleFaultReportPayload>
          }
          aggregate: {
            args: Prisma.VehicleFaultReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleFaultReport>
          }
          groupBy: {
            args: Prisma.VehicleFaultReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleFaultReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleFaultReportCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleFaultReportCountAggregateOutputType> | number
          }
        }
      }
      WorkOrder: {
        payload: Prisma.$WorkOrderPayload<ExtArgs>
        fields: Prisma.WorkOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findMany: {
            args: Prisma.WorkOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          create: {
            args: Prisma.WorkOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          createMany: {
            args: Prisma.WorkOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          update: {
            args: Prisma.WorkOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          upsert: {
            args: Prisma.WorkOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrder>
          }
          groupBy: {
            args: Prisma.WorkOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderCountAggregateOutputType> | number
          }
        }
      }
      Municipality: {
        payload: Prisma.$MunicipalityPayload<ExtArgs>
        fields: Prisma.MunicipalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findFirst: {
            args: Prisma.MunicipalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findMany: {
            args: Prisma.MunicipalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          create: {
            args: Prisma.MunicipalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          createMany: {
            args: Prisma.MunicipalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MunicipalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          delete: {
            args: Prisma.MunicipalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          update: {
            args: Prisma.MunicipalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          deleteMany: {
            args: Prisma.MunicipalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MunicipalityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          upsert: {
            args: Prisma.MunicipalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          aggregate: {
            args: Prisma.MunicipalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipality>
          }
          groupBy: {
            args: Prisma.MunicipalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipalityCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityCountAggregateOutputType> | number
          }
        }
      }
      RodzajAbsencji: {
        payload: Prisma.$RodzajAbsencjiPayload<ExtArgs>
        fields: Prisma.RodzajAbsencjiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RodzajAbsencjiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RodzajAbsencjiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>
          }
          findFirst: {
            args: Prisma.RodzajAbsencjiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RodzajAbsencjiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>
          }
          findMany: {
            args: Prisma.RodzajAbsencjiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>[]
          }
          create: {
            args: Prisma.RodzajAbsencjiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>
          }
          createMany: {
            args: Prisma.RodzajAbsencjiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RodzajAbsencjiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>[]
          }
          delete: {
            args: Prisma.RodzajAbsencjiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>
          }
          update: {
            args: Prisma.RodzajAbsencjiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>
          }
          deleteMany: {
            args: Prisma.RodzajAbsencjiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RodzajAbsencjiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RodzajAbsencjiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>[]
          }
          upsert: {
            args: Prisma.RodzajAbsencjiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RodzajAbsencjiPayload>
          }
          aggregate: {
            args: Prisma.RodzajAbsencjiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRodzajAbsencji>
          }
          groupBy: {
            args: Prisma.RodzajAbsencjiGroupByArgs<ExtArgs>
            result: $Utils.Optional<RodzajAbsencjiGroupByOutputType>[]
          }
          count: {
            args: Prisma.RodzajAbsencjiCountArgs<ExtArgs>
            result: $Utils.Optional<RodzajAbsencjiCountAggregateOutputType> | number
          }
        }
      }
      WorkCardEntry: {
        payload: Prisma.$WorkCardEntryPayload<ExtArgs>
        fields: Prisma.WorkCardEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkCardEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkCardEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>
          }
          findFirst: {
            args: Prisma.WorkCardEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkCardEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>
          }
          findMany: {
            args: Prisma.WorkCardEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>[]
          }
          create: {
            args: Prisma.WorkCardEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>
          }
          createMany: {
            args: Prisma.WorkCardEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkCardEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>[]
          }
          delete: {
            args: Prisma.WorkCardEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>
          }
          update: {
            args: Prisma.WorkCardEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>
          }
          deleteMany: {
            args: Prisma.WorkCardEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkCardEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkCardEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>[]
          }
          upsert: {
            args: Prisma.WorkCardEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkCardEntryPayload>
          }
          aggregate: {
            args: Prisma.WorkCardEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkCardEntry>
          }
          groupBy: {
            args: Prisma.WorkCardEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkCardEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkCardEntryCountArgs<ExtArgs>
            result: $Utils.Optional<WorkCardEntryCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentAttachment: {
        payload: Prisma.$DocumentAttachmentPayload<ExtArgs>
        fields: Prisma.DocumentAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          findFirst: {
            args: Prisma.DocumentAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          findMany: {
            args: Prisma.DocumentAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          create: {
            args: Prisma.DocumentAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          createMany: {
            args: Prisma.DocumentAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          delete: {
            args: Prisma.DocumentAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          update: {
            args: Prisma.DocumentAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAttachment>
          }
          groupBy: {
            args: Prisma.DocumentAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentAttachmentCountAggregateOutputType> | number
          }
        }
      }
      DocumentAnnotation: {
        payload: Prisma.$DocumentAnnotationPayload<ExtArgs>
        fields: Prisma.DocumentAnnotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentAnnotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentAnnotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>
          }
          findFirst: {
            args: Prisma.DocumentAnnotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentAnnotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>
          }
          findMany: {
            args: Prisma.DocumentAnnotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>[]
          }
          create: {
            args: Prisma.DocumentAnnotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>
          }
          createMany: {
            args: Prisma.DocumentAnnotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentAnnotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>[]
          }
          delete: {
            args: Prisma.DocumentAnnotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>
          }
          update: {
            args: Prisma.DocumentAnnotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>
          }
          deleteMany: {
            args: Prisma.DocumentAnnotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentAnnotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentAnnotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>[]
          }
          upsert: {
            args: Prisma.DocumentAnnotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAnnotationPayload>
          }
          aggregate: {
            args: Prisma.DocumentAnnotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAnnotation>
          }
          groupBy: {
            args: Prisma.DocumentAnnotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentAnnotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentAnnotationCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentAnnotationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    employee?: EmployeeOmit
    vehicle?: VehicleOmit
    region?: RegionOmit
    fraction?: FractionOmit
    point?: PointOmit
    pointFraction?: PointFractionOmit
    employeeSchedule?: EmployeeScheduleOmit
    regionFraction?: RegionFractionOmit
    calendarEntry?: CalendarEntryOmit
    dailyAssignment?: DailyAssignmentOmit
    dailyAssignmentAssistant?: DailyAssignmentAssistantOmit
    dailyAssignmentFraction?: DailyAssignmentFractionOmit
    vehicleFaultReport?: VehicleFaultReportOmit
    workOrder?: WorkOrderOmit
    municipality?: MunicipalityOmit
    rodzajAbsencji?: RodzajAbsencjiOmit
    workCardEntry?: WorkCardEntryOmit
    document?: DocumentOmit
    documentAttachment?: DocumentAttachmentOmit
    documentAnnotation?: DocumentAnnotationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    uploadedDocuments: number
    deletedDocuments: number
    uploadedAttachments: number
    annotations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    deletedDocuments?: boolean | UserCountOutputTypeCountDeletedDocumentsArgs
    uploadedAttachments?: boolean | UserCountOutputTypeCountUploadedAttachmentsArgs
    annotations?: boolean | UserCountOutputTypeCountAnnotationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAnnotationWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    employeeSchedules: number
    drivenAssignments: number
    assistantAssignments: number
    workCardEntries: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeSchedules?: boolean | EmployeeCountOutputTypeCountEmployeeSchedulesArgs
    drivenAssignments?: boolean | EmployeeCountOutputTypeCountDrivenAssignmentsArgs
    assistantAssignments?: boolean | EmployeeCountOutputTypeCountAssistantAssignmentsArgs
    workCardEntries?: boolean | EmployeeCountOutputTypeCountWorkCardEntriesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeScheduleWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDrivenAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAssistantAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentAssistantWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkCardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkCardEntryWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    dailyAssignments: number
    faultReports: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignments?: boolean | VehicleCountOutputTypeCountDailyAssignmentsArgs
    faultReports?: boolean | VehicleCountOutputTypeCountFaultReportsArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountDailyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountFaultReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleFaultReportWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    points: number
    regionFractions: number
    calendarEntries: number
    dailyAssignments: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    points?: boolean | RegionCountOutputTypeCountPointsArgs
    regionFractions?: boolean | RegionCountOutputTypeCountRegionFractionsArgs
    calendarEntries?: boolean | RegionCountOutputTypeCountCalendarEntriesArgs
    dailyAssignments?: boolean | RegionCountOutputTypeCountDailyAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountRegionFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionFractionWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountCalendarEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEntryWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountDailyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentWhereInput
  }


  /**
   * Count Type FractionCountOutputType
   */

  export type FractionCountOutputType = {
    pointFractions: number
    regionFractions: number
    calendarEntries: number
    fractionsInAssignments: number
  }

  export type FractionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointFractions?: boolean | FractionCountOutputTypeCountPointFractionsArgs
    regionFractions?: boolean | FractionCountOutputTypeCountRegionFractionsArgs
    calendarEntries?: boolean | FractionCountOutputTypeCountCalendarEntriesArgs
    fractionsInAssignments?: boolean | FractionCountOutputTypeCountFractionsInAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * FractionCountOutputType without action
   */
  export type FractionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FractionCountOutputType
     */
    select?: FractionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FractionCountOutputType without action
   */
  export type FractionCountOutputTypeCountPointFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointFractionWhereInput
  }

  /**
   * FractionCountOutputType without action
   */
  export type FractionCountOutputTypeCountRegionFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionFractionWhereInput
  }

  /**
   * FractionCountOutputType without action
   */
  export type FractionCountOutputTypeCountCalendarEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEntryWhereInput
  }

  /**
   * FractionCountOutputType without action
   */
  export type FractionCountOutputTypeCountFractionsInAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentFractionWhereInput
  }


  /**
   * Count Type PointCountOutputType
   */

  export type PointCountOutputType = {
    pointFractions: number
  }

  export type PointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointFractions?: boolean | PointCountOutputTypeCountPointFractionsArgs
  }

  // Custom InputTypes
  /**
   * PointCountOutputType without action
   */
  export type PointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointCountOutputType
     */
    select?: PointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PointCountOutputType without action
   */
  export type PointCountOutputTypeCountPointFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointFractionWhereInput
  }


  /**
   * Count Type DailyAssignmentCountOutputType
   */

  export type DailyAssignmentCountOutputType = {
    assistants: number
    fractions: number
  }

  export type DailyAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistants?: boolean | DailyAssignmentCountOutputTypeCountAssistantsArgs
    fractions?: boolean | DailyAssignmentCountOutputTypeCountFractionsArgs
  }

  // Custom InputTypes
  /**
   * DailyAssignmentCountOutputType without action
   */
  export type DailyAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentCountOutputType
     */
    select?: DailyAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailyAssignmentCountOutputType without action
   */
  export type DailyAssignmentCountOutputTypeCountAssistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentAssistantWhereInput
  }

  /**
   * DailyAssignmentCountOutputType without action
   */
  export type DailyAssignmentCountOutputTypeCountFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentFractionWhereInput
  }


  /**
   * Count Type MunicipalityCountOutputType
   */

  export type MunicipalityCountOutputType = {
    dailyAssignments: number
  }

  export type MunicipalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignments?: boolean | MunicipalityCountOutputTypeCountDailyAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipalityCountOutputType
     */
    select?: MunicipalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountDailyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentWhereInput
  }


  /**
   * Count Type RodzajAbsencjiCountOutputType
   */

  export type RodzajAbsencjiCountOutputType = {
    workCardEntries: number
  }

  export type RodzajAbsencjiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workCardEntries?: boolean | RodzajAbsencjiCountOutputTypeCountWorkCardEntriesArgs
  }

  // Custom InputTypes
  /**
   * RodzajAbsencjiCountOutputType without action
   */
  export type RodzajAbsencjiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencjiCountOutputType
     */
    select?: RodzajAbsencjiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RodzajAbsencjiCountOutputType without action
   */
  export type RodzajAbsencjiCountOutputTypeCountWorkCardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkCardEntryWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    attachments: number
    annotations: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | DocumentCountOutputTypeCountAttachmentsArgs
    annotations?: boolean | DocumentCountOutputTypeCountAnnotationsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountAnnotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAnnotationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
    isActive: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
    isActive: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    avatarUrl: number
    isActive: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
    isActive?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
    isActive?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
    isActive?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: string
    createdAt: Date
    updatedAt: Date
    avatarUrl: string | null
    isActive: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    deletedDocuments?: boolean | User$deletedDocumentsArgs<ExtArgs>
    uploadedAttachments?: boolean | User$uploadedAttachmentsArgs<ExtArgs>
    annotations?: boolean | User$annotationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
    isActive?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "createdAt" | "updatedAt" | "avatarUrl" | "isActive", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    deletedDocuments?: boolean | User$deletedDocumentsArgs<ExtArgs>
    uploadedAttachments?: boolean | User$uploadedAttachmentsArgs<ExtArgs>
    annotations?: boolean | User$annotationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      uploadedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      deletedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      uploadedAttachments: Prisma.$DocumentAttachmentPayload<ExtArgs>[]
      annotations: Prisma.$DocumentAnnotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      role: string
      createdAt: Date
      updatedAt: Date
      avatarUrl: string | null
      isActive: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deletedDocuments<T extends User$deletedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$deletedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedAttachments<T extends User$uploadedAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    annotations<T extends User$annotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$annotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.deletedDocuments
   */
  export type User$deletedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.uploadedAttachments
   */
  export type User$uploadedAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    cursor?: DocumentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * User.annotations
   */
  export type User$annotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    where?: DocumentAnnotationWhereInput
    orderBy?: DocumentAnnotationOrderByWithRelationInput | DocumentAnnotationOrderByWithRelationInput[]
    cursor?: DocumentAnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAnnotationScalarFieldEnum | DocumentAnnotationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    position: string | null
    phone: string | null
    email: string | null
    hiredAt: Date | null
    terminatedAt: Date | null
    notes: string | null
    hasDisabilityCertificate: boolean | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    surname: string | null
    position: string | null
    phone: string | null
    email: string | null
    hiredAt: Date | null
    terminatedAt: Date | null
    notes: string | null
    hasDisabilityCertificate: boolean | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    name: number
    surname: number
    position: number
    phone: number
    email: number
    hiredAt: number
    terminatedAt: number
    notes: number
    hasDisabilityCertificate: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    position?: true
    phone?: true
    email?: true
    hiredAt?: true
    terminatedAt?: true
    notes?: true
    hasDisabilityCertificate?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    position?: true
    phone?: true
    email?: true
    hiredAt?: true
    terminatedAt?: true
    notes?: true
    hasDisabilityCertificate?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    name?: true
    surname?: true
    position?: true
    phone?: true
    email?: true
    hiredAt?: true
    terminatedAt?: true
    notes?: true
    hasDisabilityCertificate?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    name: string
    surname: string
    position: string
    phone: string
    email: string | null
    hiredAt: Date | null
    terminatedAt: Date | null
    notes: string | null
    hasDisabilityCertificate: boolean
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    hiredAt?: boolean
    terminatedAt?: boolean
    notes?: boolean
    hasDisabilityCertificate?: boolean
    employeeSchedules?: boolean | Employee$employeeSchedulesArgs<ExtArgs>
    drivenAssignments?: boolean | Employee$drivenAssignmentsArgs<ExtArgs>
    assistantAssignments?: boolean | Employee$assistantAssignmentsArgs<ExtArgs>
    workCardEntries?: boolean | Employee$workCardEntriesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    hiredAt?: boolean
    terminatedAt?: boolean
    notes?: boolean
    hasDisabilityCertificate?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    surname?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    hiredAt?: boolean
    terminatedAt?: boolean
    notes?: boolean
    hasDisabilityCertificate?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    name?: boolean
    surname?: boolean
    position?: boolean
    phone?: boolean
    email?: boolean
    hiredAt?: boolean
    terminatedAt?: boolean
    notes?: boolean
    hasDisabilityCertificate?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "surname" | "position" | "phone" | "email" | "hiredAt" | "terminatedAt" | "notes" | "hasDisabilityCertificate", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeSchedules?: boolean | Employee$employeeSchedulesArgs<ExtArgs>
    drivenAssignments?: boolean | Employee$drivenAssignmentsArgs<ExtArgs>
    assistantAssignments?: boolean | Employee$assistantAssignmentsArgs<ExtArgs>
    workCardEntries?: boolean | Employee$workCardEntriesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      employeeSchedules: Prisma.$EmployeeSchedulePayload<ExtArgs>[]
      drivenAssignments: Prisma.$DailyAssignmentPayload<ExtArgs>[]
      assistantAssignments: Prisma.$DailyAssignmentAssistantPayload<ExtArgs>[]
      workCardEntries: Prisma.$WorkCardEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      surname: string
      position: string
      phone: string
      email: string | null
      hiredAt: Date | null
      terminatedAt: Date | null
      notes: string | null
      hasDisabilityCertificate: boolean
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeSchedules<T extends Employee$employeeSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$employeeSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    drivenAssignments<T extends Employee$drivenAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$drivenAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assistantAssignments<T extends Employee$assistantAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$assistantAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workCardEntries<T extends Employee$workCardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$workCardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly surname: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly hiredAt: FieldRef<"Employee", 'DateTime'>
    readonly terminatedAt: FieldRef<"Employee", 'DateTime'>
    readonly notes: FieldRef<"Employee", 'String'>
    readonly hasDisabilityCertificate: FieldRef<"Employee", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.employeeSchedules
   */
  export type Employee$employeeSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    where?: EmployeeScheduleWhereInput
    orderBy?: EmployeeScheduleOrderByWithRelationInput | EmployeeScheduleOrderByWithRelationInput[]
    cursor?: EmployeeScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScheduleScalarFieldEnum | EmployeeScheduleScalarFieldEnum[]
  }

  /**
   * Employee.drivenAssignments
   */
  export type Employee$drivenAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    where?: DailyAssignmentWhereInput
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    cursor?: DailyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * Employee.assistantAssignments
   */
  export type Employee$assistantAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    where?: DailyAssignmentAssistantWhereInput
    orderBy?: DailyAssignmentAssistantOrderByWithRelationInput | DailyAssignmentAssistantOrderByWithRelationInput[]
    cursor?: DailyAssignmentAssistantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentAssistantScalarFieldEnum | DailyAssignmentAssistantScalarFieldEnum[]
  }

  /**
   * Employee.workCardEntries
   */
  export type Employee$workCardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    where?: WorkCardEntryWhereInput
    orderBy?: WorkCardEntryOrderByWithRelationInput | WorkCardEntryOrderByWithRelationInput[]
    cursor?: WorkCardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkCardEntryScalarFieldEnum | WorkCardEntryScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type VehicleSumAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: number | null
    brand: string | null
    registrationNumber: string | null
    vehicleType: string | null
    capacity: number | null
    fuelType: string | null
    purchaseDate: Date | null
    isActive: boolean | null
    faultStatus: string | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: number | null
    brand: string | null
    registrationNumber: string | null
    vehicleType: string | null
    capacity: number | null
    fuelType: string | null
    purchaseDate: Date | null
    isActive: boolean | null
    faultStatus: string | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    brand: number
    registrationNumber: number
    vehicleType: number
    capacity: number
    fuelType: number
    purchaseDate: number
    isActive: number
    faultStatus: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type VehicleSumAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    brand?: true
    registrationNumber?: true
    vehicleType?: true
    capacity?: true
    fuelType?: true
    purchaseDate?: true
    isActive?: true
    faultStatus?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    brand?: true
    registrationNumber?: true
    vehicleType?: true
    capacity?: true
    fuelType?: true
    purchaseDate?: true
    isActive?: true
    faultStatus?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    brand?: true
    registrationNumber?: true
    vehicleType?: true
    capacity?: true
    fuelType?: true
    purchaseDate?: true
    isActive?: true
    faultStatus?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: number
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate: Date | null
    isActive: boolean
    faultStatus: string
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand?: boolean
    registrationNumber?: boolean
    vehicleType?: boolean
    capacity?: boolean
    fuelType?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    faultStatus?: boolean
    dailyAssignments?: boolean | Vehicle$dailyAssignmentsArgs<ExtArgs>
    faultReports?: boolean | Vehicle$faultReportsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand?: boolean
    registrationNumber?: boolean
    vehicleType?: boolean
    capacity?: boolean
    fuelType?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    faultStatus?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand?: boolean
    registrationNumber?: boolean
    vehicleType?: boolean
    capacity?: boolean
    fuelType?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    faultStatus?: boolean
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    brand?: boolean
    registrationNumber?: boolean
    vehicleType?: boolean
    capacity?: boolean
    fuelType?: boolean
    purchaseDate?: boolean
    isActive?: boolean
    faultStatus?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand" | "registrationNumber" | "vehicleType" | "capacity" | "fuelType" | "purchaseDate" | "isActive" | "faultStatus", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignments?: boolean | Vehicle$dailyAssignmentsArgs<ExtArgs>
    faultReports?: boolean | Vehicle$faultReportsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      dailyAssignments: Prisma.$DailyAssignmentPayload<ExtArgs>[]
      faultReports: Prisma.$VehicleFaultReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand: string
      registrationNumber: string
      vehicleType: string
      capacity: number
      fuelType: string
      purchaseDate: Date | null
      isActive: boolean
      faultStatus: string
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailyAssignments<T extends Vehicle$dailyAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$dailyAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faultReports<T extends Vehicle$faultReportsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$faultReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'Int'>
    readonly brand: FieldRef<"Vehicle", 'String'>
    readonly registrationNumber: FieldRef<"Vehicle", 'String'>
    readonly vehicleType: FieldRef<"Vehicle", 'String'>
    readonly capacity: FieldRef<"Vehicle", 'Float'>
    readonly fuelType: FieldRef<"Vehicle", 'String'>
    readonly purchaseDate: FieldRef<"Vehicle", 'DateTime'>
    readonly isActive: FieldRef<"Vehicle", 'Boolean'>
    readonly faultStatus: FieldRef<"Vehicle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.dailyAssignments
   */
  export type Vehicle$dailyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    where?: DailyAssignmentWhereInput
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    cursor?: DailyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * Vehicle.faultReports
   */
  export type Vehicle$faultReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    where?: VehicleFaultReportWhereInput
    orderBy?: VehicleFaultReportOrderByWithRelationInput | VehicleFaultReportOrderByWithRelationInput[]
    cursor?: VehicleFaultReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleFaultReportScalarFieldEnum | VehicleFaultReportScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    name: string | null
    unitName: string | null
    notes: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    unitName: string | null
    notes: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    unitName: number
    notes: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
    unitName?: true
    notes?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
    unitName?: true
    notes?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    unitName?: true
    notes?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    name: string
    unitName: string
    notes: string | null
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unitName?: boolean
    notes?: boolean
    points?: boolean | Region$pointsArgs<ExtArgs>
    regionFractions?: boolean | Region$regionFractionsArgs<ExtArgs>
    calendarEntries?: boolean | Region$calendarEntriesArgs<ExtArgs>
    dailyAssignments?: boolean | Region$dailyAssignmentsArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unitName?: boolean
    notes?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    unitName?: boolean
    notes?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
    unitName?: boolean
    notes?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "unitName" | "notes", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    points?: boolean | Region$pointsArgs<ExtArgs>
    regionFractions?: boolean | Region$regionFractionsArgs<ExtArgs>
    calendarEntries?: boolean | Region$calendarEntriesArgs<ExtArgs>
    dailyAssignments?: boolean | Region$dailyAssignmentsArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      points: Prisma.$PointPayload<ExtArgs>[]
      regionFractions: Prisma.$RegionFractionPayload<ExtArgs>[]
      calendarEntries: Prisma.$CalendarEntryPayload<ExtArgs>[]
      dailyAssignments: Prisma.$DailyAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      unitName: string
      notes: string | null
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions and returns the data updated in the database.
     * @param {RegionUpdateManyAndReturnArgs} args - Arguments to update many Regions.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    points<T extends Region$pointsArgs<ExtArgs> = {}>(args?: Subset<T, Region$pointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regionFractions<T extends Region$regionFractionsArgs<ExtArgs> = {}>(args?: Subset<T, Region$regionFractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendarEntries<T extends Region$calendarEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Region$calendarEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyAssignments<T extends Region$dailyAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Region$dailyAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
    readonly unitName: FieldRef<"Region", 'String'>
    readonly notes: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region updateManyAndReturn
   */
  export type RegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.points
   */
  export type Region$pointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    where?: PointWhereInput
    orderBy?: PointOrderByWithRelationInput | PointOrderByWithRelationInput[]
    cursor?: PointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointScalarFieldEnum | PointScalarFieldEnum[]
  }

  /**
   * Region.regionFractions
   */
  export type Region$regionFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    where?: RegionFractionWhereInput
    orderBy?: RegionFractionOrderByWithRelationInput | RegionFractionOrderByWithRelationInput[]
    cursor?: RegionFractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionFractionScalarFieldEnum | RegionFractionScalarFieldEnum[]
  }

  /**
   * Region.calendarEntries
   */
  export type Region$calendarEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    where?: CalendarEntryWhereInput
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    cursor?: CalendarEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * Region.dailyAssignments
   */
  export type Region$dailyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    where?: DailyAssignmentWhereInput
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    cursor?: DailyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Fraction
   */

  export type AggregateFraction = {
    _count: FractionCountAggregateOutputType | null
    _avg: FractionAvgAggregateOutputType | null
    _sum: FractionSumAggregateOutputType | null
    _min: FractionMinAggregateOutputType | null
    _max: FractionMaxAggregateOutputType | null
  }

  export type FractionAvgAggregateOutputType = {
    id: number | null
  }

  export type FractionSumAggregateOutputType = {
    id: number | null
  }

  export type FractionMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    color: string | null
  }

  export type FractionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    color: string | null
  }

  export type FractionCountAggregateOutputType = {
    id: number
    name: number
    code: number
    color: number
    _all: number
  }


  export type FractionAvgAggregateInputType = {
    id?: true
  }

  export type FractionSumAggregateInputType = {
    id?: true
  }

  export type FractionMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
  }

  export type FractionMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
  }

  export type FractionCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    _all?: true
  }

  export type FractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fraction to aggregate.
     */
    where?: FractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fractions to fetch.
     */
    orderBy?: FractionOrderByWithRelationInput | FractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fractions
    **/
    _count?: true | FractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FractionMaxAggregateInputType
  }

  export type GetFractionAggregateType<T extends FractionAggregateArgs> = {
        [P in keyof T & keyof AggregateFraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFraction[P]>
      : GetScalarType<T[P], AggregateFraction[P]>
  }




  export type FractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FractionWhereInput
    orderBy?: FractionOrderByWithAggregationInput | FractionOrderByWithAggregationInput[]
    by: FractionScalarFieldEnum[] | FractionScalarFieldEnum
    having?: FractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FractionCountAggregateInputType | true
    _avg?: FractionAvgAggregateInputType
    _sum?: FractionSumAggregateInputType
    _min?: FractionMinAggregateInputType
    _max?: FractionMaxAggregateInputType
  }

  export type FractionGroupByOutputType = {
    id: number
    name: string
    code: string
    color: string
    _count: FractionCountAggregateOutputType | null
    _avg: FractionAvgAggregateOutputType | null
    _sum: FractionSumAggregateOutputType | null
    _min: FractionMinAggregateOutputType | null
    _max: FractionMaxAggregateOutputType | null
  }

  type GetFractionGroupByPayload<T extends FractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FractionGroupByOutputType[P]>
            : GetScalarType<T[P], FractionGroupByOutputType[P]>
        }
      >
    >


  export type FractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    pointFractions?: boolean | Fraction$pointFractionsArgs<ExtArgs>
    regionFractions?: boolean | Fraction$regionFractionsArgs<ExtArgs>
    calendarEntries?: boolean | Fraction$calendarEntriesArgs<ExtArgs>
    fractionsInAssignments?: boolean | Fraction$fractionsInAssignmentsArgs<ExtArgs>
    _count?: boolean | FractionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fraction"]>

  export type FractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
  }, ExtArgs["result"]["fraction"]>

  export type FractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
  }, ExtArgs["result"]["fraction"]>

  export type FractionSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
  }

  export type FractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "color", ExtArgs["result"]["fraction"]>
  export type FractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointFractions?: boolean | Fraction$pointFractionsArgs<ExtArgs>
    regionFractions?: boolean | Fraction$regionFractionsArgs<ExtArgs>
    calendarEntries?: boolean | Fraction$calendarEntriesArgs<ExtArgs>
    fractionsInAssignments?: boolean | Fraction$fractionsInAssignmentsArgs<ExtArgs>
    _count?: boolean | FractionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fraction"
    objects: {
      pointFractions: Prisma.$PointFractionPayload<ExtArgs>[]
      regionFractions: Prisma.$RegionFractionPayload<ExtArgs>[]
      calendarEntries: Prisma.$CalendarEntryPayload<ExtArgs>[]
      fractionsInAssignments: Prisma.$DailyAssignmentFractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      color: string
    }, ExtArgs["result"]["fraction"]>
    composites: {}
  }

  type FractionGetPayload<S extends boolean | null | undefined | FractionDefaultArgs> = $Result.GetResult<Prisma.$FractionPayload, S>

  type FractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FractionCountAggregateInputType | true
    }

  export interface FractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fraction'], meta: { name: 'Fraction' } }
    /**
     * Find zero or one Fraction that matches the filter.
     * @param {FractionFindUniqueArgs} args - Arguments to find a Fraction
     * @example
     * // Get one Fraction
     * const fraction = await prisma.fraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FractionFindUniqueArgs>(args: SelectSubset<T, FractionFindUniqueArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FractionFindUniqueOrThrowArgs} args - Arguments to find a Fraction
     * @example
     * // Get one Fraction
     * const fraction = await prisma.fraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FractionFindUniqueOrThrowArgs>(args: SelectSubset<T, FractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionFindFirstArgs} args - Arguments to find a Fraction
     * @example
     * // Get one Fraction
     * const fraction = await prisma.fraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FractionFindFirstArgs>(args?: SelectSubset<T, FractionFindFirstArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionFindFirstOrThrowArgs} args - Arguments to find a Fraction
     * @example
     * // Get one Fraction
     * const fraction = await prisma.fraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FractionFindFirstOrThrowArgs>(args?: SelectSubset<T, FractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fractions
     * const fractions = await prisma.fraction.findMany()
     * 
     * // Get first 10 Fractions
     * const fractions = await prisma.fraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fractionWithIdOnly = await prisma.fraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FractionFindManyArgs>(args?: SelectSubset<T, FractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fraction.
     * @param {FractionCreateArgs} args - Arguments to create a Fraction.
     * @example
     * // Create one Fraction
     * const Fraction = await prisma.fraction.create({
     *   data: {
     *     // ... data to create a Fraction
     *   }
     * })
     * 
     */
    create<T extends FractionCreateArgs>(args: SelectSubset<T, FractionCreateArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fractions.
     * @param {FractionCreateManyArgs} args - Arguments to create many Fractions.
     * @example
     * // Create many Fractions
     * const fraction = await prisma.fraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FractionCreateManyArgs>(args?: SelectSubset<T, FractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fractions and returns the data saved in the database.
     * @param {FractionCreateManyAndReturnArgs} args - Arguments to create many Fractions.
     * @example
     * // Create many Fractions
     * const fraction = await prisma.fraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fractions and only return the `id`
     * const fractionWithIdOnly = await prisma.fraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FractionCreateManyAndReturnArgs>(args?: SelectSubset<T, FractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fraction.
     * @param {FractionDeleteArgs} args - Arguments to delete one Fraction.
     * @example
     * // Delete one Fraction
     * const Fraction = await prisma.fraction.delete({
     *   where: {
     *     // ... filter to delete one Fraction
     *   }
     * })
     * 
     */
    delete<T extends FractionDeleteArgs>(args: SelectSubset<T, FractionDeleteArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fraction.
     * @param {FractionUpdateArgs} args - Arguments to update one Fraction.
     * @example
     * // Update one Fraction
     * const fraction = await prisma.fraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FractionUpdateArgs>(args: SelectSubset<T, FractionUpdateArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fractions.
     * @param {FractionDeleteManyArgs} args - Arguments to filter Fractions to delete.
     * @example
     * // Delete a few Fractions
     * const { count } = await prisma.fraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FractionDeleteManyArgs>(args?: SelectSubset<T, FractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fractions
     * const fraction = await prisma.fraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FractionUpdateManyArgs>(args: SelectSubset<T, FractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fractions and returns the data updated in the database.
     * @param {FractionUpdateManyAndReturnArgs} args - Arguments to update many Fractions.
     * @example
     * // Update many Fractions
     * const fraction = await prisma.fraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fractions and only return the `id`
     * const fractionWithIdOnly = await prisma.fraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FractionUpdateManyAndReturnArgs>(args: SelectSubset<T, FractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fraction.
     * @param {FractionUpsertArgs} args - Arguments to update or create a Fraction.
     * @example
     * // Update or create a Fraction
     * const fraction = await prisma.fraction.upsert({
     *   create: {
     *     // ... data to create a Fraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fraction we want to update
     *   }
     * })
     */
    upsert<T extends FractionUpsertArgs>(args: SelectSubset<T, FractionUpsertArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionCountArgs} args - Arguments to filter Fractions to count.
     * @example
     * // Count the number of Fractions
     * const count = await prisma.fraction.count({
     *   where: {
     *     // ... the filter for the Fractions we want to count
     *   }
     * })
    **/
    count<T extends FractionCountArgs>(
      args?: Subset<T, FractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FractionAggregateArgs>(args: Subset<T, FractionAggregateArgs>): Prisma.PrismaPromise<GetFractionAggregateType<T>>

    /**
     * Group by Fraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FractionGroupByArgs['orderBy'] }
        : { orderBy?: FractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fraction model
   */
  readonly fields: FractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pointFractions<T extends Fraction$pointFractionsArgs<ExtArgs> = {}>(args?: Subset<T, Fraction$pointFractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regionFractions<T extends Fraction$regionFractionsArgs<ExtArgs> = {}>(args?: Subset<T, Fraction$regionFractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendarEntries<T extends Fraction$calendarEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Fraction$calendarEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fractionsInAssignments<T extends Fraction$fractionsInAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Fraction$fractionsInAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fraction model
   */
  interface FractionFieldRefs {
    readonly id: FieldRef<"Fraction", 'Int'>
    readonly name: FieldRef<"Fraction", 'String'>
    readonly code: FieldRef<"Fraction", 'String'>
    readonly color: FieldRef<"Fraction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fraction findUnique
   */
  export type FractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * Filter, which Fraction to fetch.
     */
    where: FractionWhereUniqueInput
  }

  /**
   * Fraction findUniqueOrThrow
   */
  export type FractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * Filter, which Fraction to fetch.
     */
    where: FractionWhereUniqueInput
  }

  /**
   * Fraction findFirst
   */
  export type FractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * Filter, which Fraction to fetch.
     */
    where?: FractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fractions to fetch.
     */
    orderBy?: FractionOrderByWithRelationInput | FractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fractions.
     */
    cursor?: FractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fractions.
     */
    distinct?: FractionScalarFieldEnum | FractionScalarFieldEnum[]
  }

  /**
   * Fraction findFirstOrThrow
   */
  export type FractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * Filter, which Fraction to fetch.
     */
    where?: FractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fractions to fetch.
     */
    orderBy?: FractionOrderByWithRelationInput | FractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fractions.
     */
    cursor?: FractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fractions.
     */
    distinct?: FractionScalarFieldEnum | FractionScalarFieldEnum[]
  }

  /**
   * Fraction findMany
   */
  export type FractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * Filter, which Fractions to fetch.
     */
    where?: FractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fractions to fetch.
     */
    orderBy?: FractionOrderByWithRelationInput | FractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fractions.
     */
    cursor?: FractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fractions.
     */
    skip?: number
    distinct?: FractionScalarFieldEnum | FractionScalarFieldEnum[]
  }

  /**
   * Fraction create
   */
  export type FractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Fraction.
     */
    data: XOR<FractionCreateInput, FractionUncheckedCreateInput>
  }

  /**
   * Fraction createMany
   */
  export type FractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fractions.
     */
    data: FractionCreateManyInput | FractionCreateManyInput[]
  }

  /**
   * Fraction createManyAndReturn
   */
  export type FractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * The data used to create many Fractions.
     */
    data: FractionCreateManyInput | FractionCreateManyInput[]
  }

  /**
   * Fraction update
   */
  export type FractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Fraction.
     */
    data: XOR<FractionUpdateInput, FractionUncheckedUpdateInput>
    /**
     * Choose, which Fraction to update.
     */
    where: FractionWhereUniqueInput
  }

  /**
   * Fraction updateMany
   */
  export type FractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fractions.
     */
    data: XOR<FractionUpdateManyMutationInput, FractionUncheckedUpdateManyInput>
    /**
     * Filter which Fractions to update
     */
    where?: FractionWhereInput
    /**
     * Limit how many Fractions to update.
     */
    limit?: number
  }

  /**
   * Fraction updateManyAndReturn
   */
  export type FractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * The data used to update Fractions.
     */
    data: XOR<FractionUpdateManyMutationInput, FractionUncheckedUpdateManyInput>
    /**
     * Filter which Fractions to update
     */
    where?: FractionWhereInput
    /**
     * Limit how many Fractions to update.
     */
    limit?: number
  }

  /**
   * Fraction upsert
   */
  export type FractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Fraction to update in case it exists.
     */
    where: FractionWhereUniqueInput
    /**
     * In case the Fraction found by the `where` argument doesn't exist, create a new Fraction with this data.
     */
    create: XOR<FractionCreateInput, FractionUncheckedCreateInput>
    /**
     * In case the Fraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FractionUpdateInput, FractionUncheckedUpdateInput>
  }

  /**
   * Fraction delete
   */
  export type FractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
    /**
     * Filter which Fraction to delete.
     */
    where: FractionWhereUniqueInput
  }

  /**
   * Fraction deleteMany
   */
  export type FractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fractions to delete
     */
    where?: FractionWhereInput
    /**
     * Limit how many Fractions to delete.
     */
    limit?: number
  }

  /**
   * Fraction.pointFractions
   */
  export type Fraction$pointFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    where?: PointFractionWhereInput
    orderBy?: PointFractionOrderByWithRelationInput | PointFractionOrderByWithRelationInput[]
    cursor?: PointFractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointFractionScalarFieldEnum | PointFractionScalarFieldEnum[]
  }

  /**
   * Fraction.regionFractions
   */
  export type Fraction$regionFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    where?: RegionFractionWhereInput
    orderBy?: RegionFractionOrderByWithRelationInput | RegionFractionOrderByWithRelationInput[]
    cursor?: RegionFractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionFractionScalarFieldEnum | RegionFractionScalarFieldEnum[]
  }

  /**
   * Fraction.calendarEntries
   */
  export type Fraction$calendarEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    where?: CalendarEntryWhereInput
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    cursor?: CalendarEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * Fraction.fractionsInAssignments
   */
  export type Fraction$fractionsInAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    where?: DailyAssignmentFractionWhereInput
    orderBy?: DailyAssignmentFractionOrderByWithRelationInput | DailyAssignmentFractionOrderByWithRelationInput[]
    cursor?: DailyAssignmentFractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentFractionScalarFieldEnum | DailyAssignmentFractionScalarFieldEnum[]
  }

  /**
   * Fraction without action
   */
  export type FractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fraction
     */
    select?: FractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fraction
     */
    omit?: FractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FractionInclude<ExtArgs> | null
  }


  /**
   * Model Point
   */

  export type AggregatePoint = {
    _count: PointCountAggregateOutputType | null
    _avg: PointAvgAggregateOutputType | null
    _sum: PointSumAggregateOutputType | null
    _min: PointMinAggregateOutputType | null
    _max: PointMaxAggregateOutputType | null
  }

  export type PointAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
  }

  export type PointSumAggregateOutputType = {
    id: number | null
    regionId: number | null
  }

  export type PointMinAggregateOutputType = {
    id: number | null
    type: string | null
    town: string | null
    street: string | null
    number: string | null
    notes: string | null
    companyName: string | null
    activityNotes: string | null
    startDate: Date | null
    endDate: Date | null
    isIndefinite: boolean | null
    kompostownik: boolean | null
    regionId: number | null
  }

  export type PointMaxAggregateOutputType = {
    id: number | null
    type: string | null
    town: string | null
    street: string | null
    number: string | null
    notes: string | null
    companyName: string | null
    activityNotes: string | null
    startDate: Date | null
    endDate: Date | null
    isIndefinite: boolean | null
    kompostownik: boolean | null
    regionId: number | null
  }

  export type PointCountAggregateOutputType = {
    id: number
    type: number
    town: number
    street: number
    number: number
    notes: number
    companyName: number
    activityNotes: number
    startDate: number
    endDate: number
    isIndefinite: number
    kompostownik: number
    regionId: number
    _all: number
  }


  export type PointAvgAggregateInputType = {
    id?: true
    regionId?: true
  }

  export type PointSumAggregateInputType = {
    id?: true
    regionId?: true
  }

  export type PointMinAggregateInputType = {
    id?: true
    type?: true
    town?: true
    street?: true
    number?: true
    notes?: true
    companyName?: true
    activityNotes?: true
    startDate?: true
    endDate?: true
    isIndefinite?: true
    kompostownik?: true
    regionId?: true
  }

  export type PointMaxAggregateInputType = {
    id?: true
    type?: true
    town?: true
    street?: true
    number?: true
    notes?: true
    companyName?: true
    activityNotes?: true
    startDate?: true
    endDate?: true
    isIndefinite?: true
    kompostownik?: true
    regionId?: true
  }

  export type PointCountAggregateInputType = {
    id?: true
    type?: true
    town?: true
    street?: true
    number?: true
    notes?: true
    companyName?: true
    activityNotes?: true
    startDate?: true
    endDate?: true
    isIndefinite?: true
    kompostownik?: true
    regionId?: true
    _all?: true
  }

  export type PointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Point to aggregate.
     */
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointOrderByWithRelationInput | PointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Points
    **/
    _count?: true | PointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointMaxAggregateInputType
  }

  export type GetPointAggregateType<T extends PointAggregateArgs> = {
        [P in keyof T & keyof AggregatePoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoint[P]>
      : GetScalarType<T[P], AggregatePoint[P]>
  }




  export type PointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointWhereInput
    orderBy?: PointOrderByWithAggregationInput | PointOrderByWithAggregationInput[]
    by: PointScalarFieldEnum[] | PointScalarFieldEnum
    having?: PointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointCountAggregateInputType | true
    _avg?: PointAvgAggregateInputType
    _sum?: PointSumAggregateInputType
    _min?: PointMinAggregateInputType
    _max?: PointMaxAggregateInputType
  }

  export type PointGroupByOutputType = {
    id: number
    type: string
    town: string
    street: string
    number: string
    notes: string | null
    companyName: string | null
    activityNotes: string | null
    startDate: Date | null
    endDate: Date | null
    isIndefinite: boolean
    kompostownik: boolean
    regionId: number | null
    _count: PointCountAggregateOutputType | null
    _avg: PointAvgAggregateOutputType | null
    _sum: PointSumAggregateOutputType | null
    _min: PointMinAggregateOutputType | null
    _max: PointMaxAggregateOutputType | null
  }

  type GetPointGroupByPayload<T extends PointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointGroupByOutputType[P]>
            : GetScalarType<T[P], PointGroupByOutputType[P]>
        }
      >
    >


  export type PointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    town?: boolean
    street?: boolean
    number?: boolean
    notes?: boolean
    companyName?: boolean
    activityNotes?: boolean
    startDate?: boolean
    endDate?: boolean
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: boolean
    region?: boolean | Point$regionArgs<ExtArgs>
    pointFractions?: boolean | Point$pointFractionsArgs<ExtArgs>
    _count?: boolean | PointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["point"]>

  export type PointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    town?: boolean
    street?: boolean
    number?: boolean
    notes?: boolean
    companyName?: boolean
    activityNotes?: boolean
    startDate?: boolean
    endDate?: boolean
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: boolean
    region?: boolean | Point$regionArgs<ExtArgs>
  }, ExtArgs["result"]["point"]>

  export type PointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    town?: boolean
    street?: boolean
    number?: boolean
    notes?: boolean
    companyName?: boolean
    activityNotes?: boolean
    startDate?: boolean
    endDate?: boolean
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: boolean
    region?: boolean | Point$regionArgs<ExtArgs>
  }, ExtArgs["result"]["point"]>

  export type PointSelectScalar = {
    id?: boolean
    type?: boolean
    town?: boolean
    street?: boolean
    number?: boolean
    notes?: boolean
    companyName?: boolean
    activityNotes?: boolean
    startDate?: boolean
    endDate?: boolean
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: boolean
  }

  export type PointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "town" | "street" | "number" | "notes" | "companyName" | "activityNotes" | "startDate" | "endDate" | "isIndefinite" | "kompostownik" | "regionId", ExtArgs["result"]["point"]>
  export type PointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | Point$regionArgs<ExtArgs>
    pointFractions?: boolean | Point$pointFractionsArgs<ExtArgs>
    _count?: boolean | PointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | Point$regionArgs<ExtArgs>
  }
  export type PointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | Point$regionArgs<ExtArgs>
  }

  export type $PointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Point"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs> | null
      pointFractions: Prisma.$PointFractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      town: string
      street: string
      number: string
      notes: string | null
      companyName: string | null
      activityNotes: string | null
      startDate: Date | null
      endDate: Date | null
      isIndefinite: boolean
      kompostownik: boolean
      regionId: number | null
    }, ExtArgs["result"]["point"]>
    composites: {}
  }

  type PointGetPayload<S extends boolean | null | undefined | PointDefaultArgs> = $Result.GetResult<Prisma.$PointPayload, S>

  type PointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointCountAggregateInputType | true
    }

  export interface PointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Point'], meta: { name: 'Point' } }
    /**
     * Find zero or one Point that matches the filter.
     * @param {PointFindUniqueArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointFindUniqueArgs>(args: SelectSubset<T, PointFindUniqueArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Point that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointFindUniqueOrThrowArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointFindUniqueOrThrowArgs>(args: SelectSubset<T, PointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Point that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFindFirstArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointFindFirstArgs>(args?: SelectSubset<T, PointFindFirstArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Point that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFindFirstOrThrowArgs} args - Arguments to find a Point
     * @example
     * // Get one Point
     * const point = await prisma.point.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointFindFirstOrThrowArgs>(args?: SelectSubset<T, PointFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Points that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Points
     * const points = await prisma.point.findMany()
     * 
     * // Get first 10 Points
     * const points = await prisma.point.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointWithIdOnly = await prisma.point.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointFindManyArgs>(args?: SelectSubset<T, PointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Point.
     * @param {PointCreateArgs} args - Arguments to create a Point.
     * @example
     * // Create one Point
     * const Point = await prisma.point.create({
     *   data: {
     *     // ... data to create a Point
     *   }
     * })
     * 
     */
    create<T extends PointCreateArgs>(args: SelectSubset<T, PointCreateArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Points.
     * @param {PointCreateManyArgs} args - Arguments to create many Points.
     * @example
     * // Create many Points
     * const point = await prisma.point.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointCreateManyArgs>(args?: SelectSubset<T, PointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Points and returns the data saved in the database.
     * @param {PointCreateManyAndReturnArgs} args - Arguments to create many Points.
     * @example
     * // Create many Points
     * const point = await prisma.point.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Points and only return the `id`
     * const pointWithIdOnly = await prisma.point.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointCreateManyAndReturnArgs>(args?: SelectSubset<T, PointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Point.
     * @param {PointDeleteArgs} args - Arguments to delete one Point.
     * @example
     * // Delete one Point
     * const Point = await prisma.point.delete({
     *   where: {
     *     // ... filter to delete one Point
     *   }
     * })
     * 
     */
    delete<T extends PointDeleteArgs>(args: SelectSubset<T, PointDeleteArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Point.
     * @param {PointUpdateArgs} args - Arguments to update one Point.
     * @example
     * // Update one Point
     * const point = await prisma.point.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointUpdateArgs>(args: SelectSubset<T, PointUpdateArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Points.
     * @param {PointDeleteManyArgs} args - Arguments to filter Points to delete.
     * @example
     * // Delete a few Points
     * const { count } = await prisma.point.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointDeleteManyArgs>(args?: SelectSubset<T, PointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Points
     * const point = await prisma.point.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointUpdateManyArgs>(args: SelectSubset<T, PointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Points and returns the data updated in the database.
     * @param {PointUpdateManyAndReturnArgs} args - Arguments to update many Points.
     * @example
     * // Update many Points
     * const point = await prisma.point.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Points and only return the `id`
     * const pointWithIdOnly = await prisma.point.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointUpdateManyAndReturnArgs>(args: SelectSubset<T, PointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Point.
     * @param {PointUpsertArgs} args - Arguments to update or create a Point.
     * @example
     * // Update or create a Point
     * const point = await prisma.point.upsert({
     *   create: {
     *     // ... data to create a Point
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Point we want to update
     *   }
     * })
     */
    upsert<T extends PointUpsertArgs>(args: SelectSubset<T, PointUpsertArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Points.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointCountArgs} args - Arguments to filter Points to count.
     * @example
     * // Count the number of Points
     * const count = await prisma.point.count({
     *   where: {
     *     // ... the filter for the Points we want to count
     *   }
     * })
    **/
    count<T extends PointCountArgs>(
      args?: Subset<T, PointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Point.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointAggregateArgs>(args: Subset<T, PointAggregateArgs>): Prisma.PrismaPromise<GetPointAggregateType<T>>

    /**
     * Group by Point.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointGroupByArgs['orderBy'] }
        : { orderBy?: PointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Point model
   */
  readonly fields: PointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Point.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends Point$regionArgs<ExtArgs> = {}>(args?: Subset<T, Point$regionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pointFractions<T extends Point$pointFractionsArgs<ExtArgs> = {}>(args?: Subset<T, Point$pointFractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Point model
   */
  interface PointFieldRefs {
    readonly id: FieldRef<"Point", 'Int'>
    readonly type: FieldRef<"Point", 'String'>
    readonly town: FieldRef<"Point", 'String'>
    readonly street: FieldRef<"Point", 'String'>
    readonly number: FieldRef<"Point", 'String'>
    readonly notes: FieldRef<"Point", 'String'>
    readonly companyName: FieldRef<"Point", 'String'>
    readonly activityNotes: FieldRef<"Point", 'String'>
    readonly startDate: FieldRef<"Point", 'DateTime'>
    readonly endDate: FieldRef<"Point", 'DateTime'>
    readonly isIndefinite: FieldRef<"Point", 'Boolean'>
    readonly kompostownik: FieldRef<"Point", 'Boolean'>
    readonly regionId: FieldRef<"Point", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Point findUnique
   */
  export type PointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * Filter, which Point to fetch.
     */
    where: PointWhereUniqueInput
  }

  /**
   * Point findUniqueOrThrow
   */
  export type PointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * Filter, which Point to fetch.
     */
    where: PointWhereUniqueInput
  }

  /**
   * Point findFirst
   */
  export type PointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * Filter, which Point to fetch.
     */
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointOrderByWithRelationInput | PointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Points.
     */
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Points.
     */
    distinct?: PointScalarFieldEnum | PointScalarFieldEnum[]
  }

  /**
   * Point findFirstOrThrow
   */
  export type PointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * Filter, which Point to fetch.
     */
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointOrderByWithRelationInput | PointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Points.
     */
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Points.
     */
    distinct?: PointScalarFieldEnum | PointScalarFieldEnum[]
  }

  /**
   * Point findMany
   */
  export type PointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * Filter, which Points to fetch.
     */
    where?: PointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Points to fetch.
     */
    orderBy?: PointOrderByWithRelationInput | PointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Points.
     */
    cursor?: PointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Points from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Points.
     */
    skip?: number
    distinct?: PointScalarFieldEnum | PointScalarFieldEnum[]
  }

  /**
   * Point create
   */
  export type PointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * The data needed to create a Point.
     */
    data: XOR<PointCreateInput, PointUncheckedCreateInput>
  }

  /**
   * Point createMany
   */
  export type PointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Points.
     */
    data: PointCreateManyInput | PointCreateManyInput[]
  }

  /**
   * Point createManyAndReturn
   */
  export type PointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * The data used to create many Points.
     */
    data: PointCreateManyInput | PointCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Point update
   */
  export type PointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * The data needed to update a Point.
     */
    data: XOR<PointUpdateInput, PointUncheckedUpdateInput>
    /**
     * Choose, which Point to update.
     */
    where: PointWhereUniqueInput
  }

  /**
   * Point updateMany
   */
  export type PointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Points.
     */
    data: XOR<PointUpdateManyMutationInput, PointUncheckedUpdateManyInput>
    /**
     * Filter which Points to update
     */
    where?: PointWhereInput
    /**
     * Limit how many Points to update.
     */
    limit?: number
  }

  /**
   * Point updateManyAndReturn
   */
  export type PointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * The data used to update Points.
     */
    data: XOR<PointUpdateManyMutationInput, PointUncheckedUpdateManyInput>
    /**
     * Filter which Points to update
     */
    where?: PointWhereInput
    /**
     * Limit how many Points to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Point upsert
   */
  export type PointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * The filter to search for the Point to update in case it exists.
     */
    where: PointWhereUniqueInput
    /**
     * In case the Point found by the `where` argument doesn't exist, create a new Point with this data.
     */
    create: XOR<PointCreateInput, PointUncheckedCreateInput>
    /**
     * In case the Point was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointUpdateInput, PointUncheckedUpdateInput>
  }

  /**
   * Point delete
   */
  export type PointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
    /**
     * Filter which Point to delete.
     */
    where: PointWhereUniqueInput
  }

  /**
   * Point deleteMany
   */
  export type PointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Points to delete
     */
    where?: PointWhereInput
    /**
     * Limit how many Points to delete.
     */
    limit?: number
  }

  /**
   * Point.region
   */
  export type Point$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * Point.pointFractions
   */
  export type Point$pointFractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    where?: PointFractionWhereInput
    orderBy?: PointFractionOrderByWithRelationInput | PointFractionOrderByWithRelationInput[]
    cursor?: PointFractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointFractionScalarFieldEnum | PointFractionScalarFieldEnum[]
  }

  /**
   * Point without action
   */
  export type PointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Point
     */
    omit?: PointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointInclude<ExtArgs> | null
  }


  /**
   * Model PointFraction
   */

  export type AggregatePointFraction = {
    _count: PointFractionCountAggregateOutputType | null
    _avg: PointFractionAvgAggregateOutputType | null
    _sum: PointFractionSumAggregateOutputType | null
    _min: PointFractionMinAggregateOutputType | null
    _max: PointFractionMaxAggregateOutputType | null
  }

  export type PointFractionAvgAggregateOutputType = {
    id: number | null
    pointId: number | null
    fractionId: number | null
  }

  export type PointFractionSumAggregateOutputType = {
    id: number | null
    pointId: number | null
    fractionId: number | null
  }

  export type PointFractionMinAggregateOutputType = {
    id: number | null
    pointId: number | null
    fractionId: number | null
    containerSize: string | null
    pickupFrequency: string | null
  }

  export type PointFractionMaxAggregateOutputType = {
    id: number | null
    pointId: number | null
    fractionId: number | null
    containerSize: string | null
    pickupFrequency: string | null
  }

  export type PointFractionCountAggregateOutputType = {
    id: number
    pointId: number
    fractionId: number
    containerSize: number
    pickupFrequency: number
    _all: number
  }


  export type PointFractionAvgAggregateInputType = {
    id?: true
    pointId?: true
    fractionId?: true
  }

  export type PointFractionSumAggregateInputType = {
    id?: true
    pointId?: true
    fractionId?: true
  }

  export type PointFractionMinAggregateInputType = {
    id?: true
    pointId?: true
    fractionId?: true
    containerSize?: true
    pickupFrequency?: true
  }

  export type PointFractionMaxAggregateInputType = {
    id?: true
    pointId?: true
    fractionId?: true
    containerSize?: true
    pickupFrequency?: true
  }

  export type PointFractionCountAggregateInputType = {
    id?: true
    pointId?: true
    fractionId?: true
    containerSize?: true
    pickupFrequency?: true
    _all?: true
  }

  export type PointFractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointFraction to aggregate.
     */
    where?: PointFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointFractions to fetch.
     */
    orderBy?: PointFractionOrderByWithRelationInput | PointFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointFractions
    **/
    _count?: true | PointFractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointFractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointFractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointFractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointFractionMaxAggregateInputType
  }

  export type GetPointFractionAggregateType<T extends PointFractionAggregateArgs> = {
        [P in keyof T & keyof AggregatePointFraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointFraction[P]>
      : GetScalarType<T[P], AggregatePointFraction[P]>
  }




  export type PointFractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointFractionWhereInput
    orderBy?: PointFractionOrderByWithAggregationInput | PointFractionOrderByWithAggregationInput[]
    by: PointFractionScalarFieldEnum[] | PointFractionScalarFieldEnum
    having?: PointFractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointFractionCountAggregateInputType | true
    _avg?: PointFractionAvgAggregateInputType
    _sum?: PointFractionSumAggregateInputType
    _min?: PointFractionMinAggregateInputType
    _max?: PointFractionMaxAggregateInputType
  }

  export type PointFractionGroupByOutputType = {
    id: number
    pointId: number
    fractionId: number
    containerSize: string
    pickupFrequency: string
    _count: PointFractionCountAggregateOutputType | null
    _avg: PointFractionAvgAggregateOutputType | null
    _sum: PointFractionSumAggregateOutputType | null
    _min: PointFractionMinAggregateOutputType | null
    _max: PointFractionMaxAggregateOutputType | null
  }

  type GetPointFractionGroupByPayload<T extends PointFractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointFractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointFractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointFractionGroupByOutputType[P]>
            : GetScalarType<T[P], PointFractionGroupByOutputType[P]>
        }
      >
    >


  export type PointFractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointId?: boolean
    fractionId?: boolean
    containerSize?: boolean
    pickupFrequency?: boolean
    point?: boolean | PointDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointFraction"]>

  export type PointFractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointId?: boolean
    fractionId?: boolean
    containerSize?: boolean
    pickupFrequency?: boolean
    point?: boolean | PointDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointFraction"]>

  export type PointFractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointId?: boolean
    fractionId?: boolean
    containerSize?: boolean
    pickupFrequency?: boolean
    point?: boolean | PointDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointFraction"]>

  export type PointFractionSelectScalar = {
    id?: boolean
    pointId?: boolean
    fractionId?: boolean
    containerSize?: boolean
    pickupFrequency?: boolean
  }

  export type PointFractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pointId" | "fractionId" | "containerSize" | "pickupFrequency", ExtArgs["result"]["pointFraction"]>
  export type PointFractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    point?: boolean | PointDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type PointFractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    point?: boolean | PointDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type PointFractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    point?: boolean | PointDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }

  export type $PointFractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointFraction"
    objects: {
      point: Prisma.$PointPayload<ExtArgs>
      fraction: Prisma.$FractionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pointId: number
      fractionId: number
      containerSize: string
      pickupFrequency: string
    }, ExtArgs["result"]["pointFraction"]>
    composites: {}
  }

  type PointFractionGetPayload<S extends boolean | null | undefined | PointFractionDefaultArgs> = $Result.GetResult<Prisma.$PointFractionPayload, S>

  type PointFractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointFractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointFractionCountAggregateInputType | true
    }

  export interface PointFractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointFraction'], meta: { name: 'PointFraction' } }
    /**
     * Find zero or one PointFraction that matches the filter.
     * @param {PointFractionFindUniqueArgs} args - Arguments to find a PointFraction
     * @example
     * // Get one PointFraction
     * const pointFraction = await prisma.pointFraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointFractionFindUniqueArgs>(args: SelectSubset<T, PointFractionFindUniqueArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointFraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointFractionFindUniqueOrThrowArgs} args - Arguments to find a PointFraction
     * @example
     * // Get one PointFraction
     * const pointFraction = await prisma.pointFraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointFractionFindUniqueOrThrowArgs>(args: SelectSubset<T, PointFractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointFraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionFindFirstArgs} args - Arguments to find a PointFraction
     * @example
     * // Get one PointFraction
     * const pointFraction = await prisma.pointFraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointFractionFindFirstArgs>(args?: SelectSubset<T, PointFractionFindFirstArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointFraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionFindFirstOrThrowArgs} args - Arguments to find a PointFraction
     * @example
     * // Get one PointFraction
     * const pointFraction = await prisma.pointFraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointFractionFindFirstOrThrowArgs>(args?: SelectSubset<T, PointFractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointFractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointFractions
     * const pointFractions = await prisma.pointFraction.findMany()
     * 
     * // Get first 10 PointFractions
     * const pointFractions = await prisma.pointFraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointFractionWithIdOnly = await prisma.pointFraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointFractionFindManyArgs>(args?: SelectSubset<T, PointFractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointFraction.
     * @param {PointFractionCreateArgs} args - Arguments to create a PointFraction.
     * @example
     * // Create one PointFraction
     * const PointFraction = await prisma.pointFraction.create({
     *   data: {
     *     // ... data to create a PointFraction
     *   }
     * })
     * 
     */
    create<T extends PointFractionCreateArgs>(args: SelectSubset<T, PointFractionCreateArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointFractions.
     * @param {PointFractionCreateManyArgs} args - Arguments to create many PointFractions.
     * @example
     * // Create many PointFractions
     * const pointFraction = await prisma.pointFraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointFractionCreateManyArgs>(args?: SelectSubset<T, PointFractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointFractions and returns the data saved in the database.
     * @param {PointFractionCreateManyAndReturnArgs} args - Arguments to create many PointFractions.
     * @example
     * // Create many PointFractions
     * const pointFraction = await prisma.pointFraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointFractions and only return the `id`
     * const pointFractionWithIdOnly = await prisma.pointFraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointFractionCreateManyAndReturnArgs>(args?: SelectSubset<T, PointFractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointFraction.
     * @param {PointFractionDeleteArgs} args - Arguments to delete one PointFraction.
     * @example
     * // Delete one PointFraction
     * const PointFraction = await prisma.pointFraction.delete({
     *   where: {
     *     // ... filter to delete one PointFraction
     *   }
     * })
     * 
     */
    delete<T extends PointFractionDeleteArgs>(args: SelectSubset<T, PointFractionDeleteArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointFraction.
     * @param {PointFractionUpdateArgs} args - Arguments to update one PointFraction.
     * @example
     * // Update one PointFraction
     * const pointFraction = await prisma.pointFraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointFractionUpdateArgs>(args: SelectSubset<T, PointFractionUpdateArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointFractions.
     * @param {PointFractionDeleteManyArgs} args - Arguments to filter PointFractions to delete.
     * @example
     * // Delete a few PointFractions
     * const { count } = await prisma.pointFraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointFractionDeleteManyArgs>(args?: SelectSubset<T, PointFractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointFractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointFractions
     * const pointFraction = await prisma.pointFraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointFractionUpdateManyArgs>(args: SelectSubset<T, PointFractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointFractions and returns the data updated in the database.
     * @param {PointFractionUpdateManyAndReturnArgs} args - Arguments to update many PointFractions.
     * @example
     * // Update many PointFractions
     * const pointFraction = await prisma.pointFraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointFractions and only return the `id`
     * const pointFractionWithIdOnly = await prisma.pointFraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointFractionUpdateManyAndReturnArgs>(args: SelectSubset<T, PointFractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointFraction.
     * @param {PointFractionUpsertArgs} args - Arguments to update or create a PointFraction.
     * @example
     * // Update or create a PointFraction
     * const pointFraction = await prisma.pointFraction.upsert({
     *   create: {
     *     // ... data to create a PointFraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointFraction we want to update
     *   }
     * })
     */
    upsert<T extends PointFractionUpsertArgs>(args: SelectSubset<T, PointFractionUpsertArgs<ExtArgs>>): Prisma__PointFractionClient<$Result.GetResult<Prisma.$PointFractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointFractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionCountArgs} args - Arguments to filter PointFractions to count.
     * @example
     * // Count the number of PointFractions
     * const count = await prisma.pointFraction.count({
     *   where: {
     *     // ... the filter for the PointFractions we want to count
     *   }
     * })
    **/
    count<T extends PointFractionCountArgs>(
      args?: Subset<T, PointFractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointFractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointFraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointFractionAggregateArgs>(args: Subset<T, PointFractionAggregateArgs>): Prisma.PrismaPromise<GetPointFractionAggregateType<T>>

    /**
     * Group by PointFraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointFractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointFractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointFractionGroupByArgs['orderBy'] }
        : { orderBy?: PointFractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointFractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointFractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointFraction model
   */
  readonly fields: PointFractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointFraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointFractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    point<T extends PointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PointDefaultArgs<ExtArgs>>): Prisma__PointClient<$Result.GetResult<Prisma.$PointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fraction<T extends FractionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FractionDefaultArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointFraction model
   */
  interface PointFractionFieldRefs {
    readonly id: FieldRef<"PointFraction", 'Int'>
    readonly pointId: FieldRef<"PointFraction", 'Int'>
    readonly fractionId: FieldRef<"PointFraction", 'Int'>
    readonly containerSize: FieldRef<"PointFraction", 'String'>
    readonly pickupFrequency: FieldRef<"PointFraction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PointFraction findUnique
   */
  export type PointFractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * Filter, which PointFraction to fetch.
     */
    where: PointFractionWhereUniqueInput
  }

  /**
   * PointFraction findUniqueOrThrow
   */
  export type PointFractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * Filter, which PointFraction to fetch.
     */
    where: PointFractionWhereUniqueInput
  }

  /**
   * PointFraction findFirst
   */
  export type PointFractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * Filter, which PointFraction to fetch.
     */
    where?: PointFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointFractions to fetch.
     */
    orderBy?: PointFractionOrderByWithRelationInput | PointFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointFractions.
     */
    cursor?: PointFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointFractions.
     */
    distinct?: PointFractionScalarFieldEnum | PointFractionScalarFieldEnum[]
  }

  /**
   * PointFraction findFirstOrThrow
   */
  export type PointFractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * Filter, which PointFraction to fetch.
     */
    where?: PointFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointFractions to fetch.
     */
    orderBy?: PointFractionOrderByWithRelationInput | PointFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointFractions.
     */
    cursor?: PointFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointFractions.
     */
    distinct?: PointFractionScalarFieldEnum | PointFractionScalarFieldEnum[]
  }

  /**
   * PointFraction findMany
   */
  export type PointFractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * Filter, which PointFractions to fetch.
     */
    where?: PointFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointFractions to fetch.
     */
    orderBy?: PointFractionOrderByWithRelationInput | PointFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointFractions.
     */
    cursor?: PointFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointFractions.
     */
    skip?: number
    distinct?: PointFractionScalarFieldEnum | PointFractionScalarFieldEnum[]
  }

  /**
   * PointFraction create
   */
  export type PointFractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * The data needed to create a PointFraction.
     */
    data: XOR<PointFractionCreateInput, PointFractionUncheckedCreateInput>
  }

  /**
   * PointFraction createMany
   */
  export type PointFractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointFractions.
     */
    data: PointFractionCreateManyInput | PointFractionCreateManyInput[]
  }

  /**
   * PointFraction createManyAndReturn
   */
  export type PointFractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * The data used to create many PointFractions.
     */
    data: PointFractionCreateManyInput | PointFractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointFraction update
   */
  export type PointFractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * The data needed to update a PointFraction.
     */
    data: XOR<PointFractionUpdateInput, PointFractionUncheckedUpdateInput>
    /**
     * Choose, which PointFraction to update.
     */
    where: PointFractionWhereUniqueInput
  }

  /**
   * PointFraction updateMany
   */
  export type PointFractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointFractions.
     */
    data: XOR<PointFractionUpdateManyMutationInput, PointFractionUncheckedUpdateManyInput>
    /**
     * Filter which PointFractions to update
     */
    where?: PointFractionWhereInput
    /**
     * Limit how many PointFractions to update.
     */
    limit?: number
  }

  /**
   * PointFraction updateManyAndReturn
   */
  export type PointFractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * The data used to update PointFractions.
     */
    data: XOR<PointFractionUpdateManyMutationInput, PointFractionUncheckedUpdateManyInput>
    /**
     * Filter which PointFractions to update
     */
    where?: PointFractionWhereInput
    /**
     * Limit how many PointFractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointFraction upsert
   */
  export type PointFractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * The filter to search for the PointFraction to update in case it exists.
     */
    where: PointFractionWhereUniqueInput
    /**
     * In case the PointFraction found by the `where` argument doesn't exist, create a new PointFraction with this data.
     */
    create: XOR<PointFractionCreateInput, PointFractionUncheckedCreateInput>
    /**
     * In case the PointFraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointFractionUpdateInput, PointFractionUncheckedUpdateInput>
  }

  /**
   * PointFraction delete
   */
  export type PointFractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
    /**
     * Filter which PointFraction to delete.
     */
    where: PointFractionWhereUniqueInput
  }

  /**
   * PointFraction deleteMany
   */
  export type PointFractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointFractions to delete
     */
    where?: PointFractionWhereInput
    /**
     * Limit how many PointFractions to delete.
     */
    limit?: number
  }

  /**
   * PointFraction without action
   */
  export type PointFractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointFraction
     */
    select?: PointFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointFraction
     */
    omit?: PointFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointFractionInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeSchedule
   */

  export type AggregateEmployeeSchedule = {
    _count: EmployeeScheduleCountAggregateOutputType | null
    _avg: EmployeeScheduleAvgAggregateOutputType | null
    _sum: EmployeeScheduleSumAggregateOutputType | null
    _min: EmployeeScheduleMinAggregateOutputType | null
    _max: EmployeeScheduleMaxAggregateOutputType | null
  }

  export type EmployeeScheduleAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type EmployeeScheduleSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type EmployeeScheduleMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    shift: string | null
    customHours: string | null
    colorCode: string | null
  }

  export type EmployeeScheduleMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    shift: string | null
    customHours: string | null
    colorCode: string | null
  }

  export type EmployeeScheduleCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    shift: number
    customHours: number
    colorCode: number
    _all: number
  }


  export type EmployeeScheduleAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type EmployeeScheduleSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type EmployeeScheduleMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    shift?: true
    customHours?: true
    colorCode?: true
  }

  export type EmployeeScheduleMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    shift?: true
    customHours?: true
    colorCode?: true
  }

  export type EmployeeScheduleCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    shift?: true
    customHours?: true
    colorCode?: true
    _all?: true
  }

  export type EmployeeScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeSchedule to aggregate.
     */
    where?: EmployeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSchedules to fetch.
     */
    orderBy?: EmployeeScheduleOrderByWithRelationInput | EmployeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeSchedules
    **/
    _count?: true | EmployeeScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeScheduleMaxAggregateInputType
  }

  export type GetEmployeeScheduleAggregateType<T extends EmployeeScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeSchedule[P]>
      : GetScalarType<T[P], AggregateEmployeeSchedule[P]>
  }




  export type EmployeeScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeScheduleWhereInput
    orderBy?: EmployeeScheduleOrderByWithAggregationInput | EmployeeScheduleOrderByWithAggregationInput[]
    by: EmployeeScheduleScalarFieldEnum[] | EmployeeScheduleScalarFieldEnum
    having?: EmployeeScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeScheduleCountAggregateInputType | true
    _avg?: EmployeeScheduleAvgAggregateInputType
    _sum?: EmployeeScheduleSumAggregateInputType
    _min?: EmployeeScheduleMinAggregateInputType
    _max?: EmployeeScheduleMaxAggregateInputType
  }

  export type EmployeeScheduleGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    shift: string
    customHours: string | null
    colorCode: string | null
    _count: EmployeeScheduleCountAggregateOutputType | null
    _avg: EmployeeScheduleAvgAggregateOutputType | null
    _sum: EmployeeScheduleSumAggregateOutputType | null
    _min: EmployeeScheduleMinAggregateOutputType | null
    _max: EmployeeScheduleMaxAggregateOutputType | null
  }

  type GetEmployeeScheduleGroupByPayload<T extends EmployeeScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeScheduleGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    shift?: boolean
    customHours?: boolean
    colorCode?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeSchedule"]>

  export type EmployeeScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    shift?: boolean
    customHours?: boolean
    colorCode?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeSchedule"]>

  export type EmployeeScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    shift?: boolean
    customHours?: boolean
    colorCode?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeSchedule"]>

  export type EmployeeScheduleSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    shift?: boolean
    customHours?: boolean
    colorCode?: boolean
  }

  export type EmployeeScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "shift" | "customHours" | "colorCode", ExtArgs["result"]["employeeSchedule"]>
  export type EmployeeScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EmployeeSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeSchedule"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      shift: string
      customHours: string | null
      colorCode: string | null
    }, ExtArgs["result"]["employeeSchedule"]>
    composites: {}
  }

  type EmployeeScheduleGetPayload<S extends boolean | null | undefined | EmployeeScheduleDefaultArgs> = $Result.GetResult<Prisma.$EmployeeSchedulePayload, S>

  type EmployeeScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeScheduleCountAggregateInputType | true
    }

  export interface EmployeeScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeSchedule'], meta: { name: 'EmployeeSchedule' } }
    /**
     * Find zero or one EmployeeSchedule that matches the filter.
     * @param {EmployeeScheduleFindUniqueArgs} args - Arguments to find a EmployeeSchedule
     * @example
     * // Get one EmployeeSchedule
     * const employeeSchedule = await prisma.employeeSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeScheduleFindUniqueArgs>(args: SelectSubset<T, EmployeeScheduleFindUniqueArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeScheduleFindUniqueOrThrowArgs} args - Arguments to find a EmployeeSchedule
     * @example
     * // Get one EmployeeSchedule
     * const employeeSchedule = await prisma.employeeSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleFindFirstArgs} args - Arguments to find a EmployeeSchedule
     * @example
     * // Get one EmployeeSchedule
     * const employeeSchedule = await prisma.employeeSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeScheduleFindFirstArgs>(args?: SelectSubset<T, EmployeeScheduleFindFirstArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleFindFirstOrThrowArgs} args - Arguments to find a EmployeeSchedule
     * @example
     * // Get one EmployeeSchedule
     * const employeeSchedule = await prisma.employeeSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeSchedules
     * const employeeSchedules = await prisma.employeeSchedule.findMany()
     * 
     * // Get first 10 EmployeeSchedules
     * const employeeSchedules = await prisma.employeeSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeScheduleWithIdOnly = await prisma.employeeSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeScheduleFindManyArgs>(args?: SelectSubset<T, EmployeeScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeSchedule.
     * @param {EmployeeScheduleCreateArgs} args - Arguments to create a EmployeeSchedule.
     * @example
     * // Create one EmployeeSchedule
     * const EmployeeSchedule = await prisma.employeeSchedule.create({
     *   data: {
     *     // ... data to create a EmployeeSchedule
     *   }
     * })
     * 
     */
    create<T extends EmployeeScheduleCreateArgs>(args: SelectSubset<T, EmployeeScheduleCreateArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeSchedules.
     * @param {EmployeeScheduleCreateManyArgs} args - Arguments to create many EmployeeSchedules.
     * @example
     * // Create many EmployeeSchedules
     * const employeeSchedule = await prisma.employeeSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeScheduleCreateManyArgs>(args?: SelectSubset<T, EmployeeScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeSchedules and returns the data saved in the database.
     * @param {EmployeeScheduleCreateManyAndReturnArgs} args - Arguments to create many EmployeeSchedules.
     * @example
     * // Create many EmployeeSchedules
     * const employeeSchedule = await prisma.employeeSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeSchedules and only return the `id`
     * const employeeScheduleWithIdOnly = await prisma.employeeSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeSchedule.
     * @param {EmployeeScheduleDeleteArgs} args - Arguments to delete one EmployeeSchedule.
     * @example
     * // Delete one EmployeeSchedule
     * const EmployeeSchedule = await prisma.employeeSchedule.delete({
     *   where: {
     *     // ... filter to delete one EmployeeSchedule
     *   }
     * })
     * 
     */
    delete<T extends EmployeeScheduleDeleteArgs>(args: SelectSubset<T, EmployeeScheduleDeleteArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeSchedule.
     * @param {EmployeeScheduleUpdateArgs} args - Arguments to update one EmployeeSchedule.
     * @example
     * // Update one EmployeeSchedule
     * const employeeSchedule = await prisma.employeeSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeScheduleUpdateArgs>(args: SelectSubset<T, EmployeeScheduleUpdateArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeSchedules.
     * @param {EmployeeScheduleDeleteManyArgs} args - Arguments to filter EmployeeSchedules to delete.
     * @example
     * // Delete a few EmployeeSchedules
     * const { count } = await prisma.employeeSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeScheduleDeleteManyArgs>(args?: SelectSubset<T, EmployeeScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeSchedules
     * const employeeSchedule = await prisma.employeeSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeScheduleUpdateManyArgs>(args: SelectSubset<T, EmployeeScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeSchedules and returns the data updated in the database.
     * @param {EmployeeScheduleUpdateManyAndReturnArgs} args - Arguments to update many EmployeeSchedules.
     * @example
     * // Update many EmployeeSchedules
     * const employeeSchedule = await prisma.employeeSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeSchedules and only return the `id`
     * const employeeScheduleWithIdOnly = await prisma.employeeSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeSchedule.
     * @param {EmployeeScheduleUpsertArgs} args - Arguments to update or create a EmployeeSchedule.
     * @example
     * // Update or create a EmployeeSchedule
     * const employeeSchedule = await prisma.employeeSchedule.upsert({
     *   create: {
     *     // ... data to create a EmployeeSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeSchedule we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeScheduleUpsertArgs>(args: SelectSubset<T, EmployeeScheduleUpsertArgs<ExtArgs>>): Prisma__EmployeeScheduleClient<$Result.GetResult<Prisma.$EmployeeSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleCountArgs} args - Arguments to filter EmployeeSchedules to count.
     * @example
     * // Count the number of EmployeeSchedules
     * const count = await prisma.employeeSchedule.count({
     *   where: {
     *     // ... the filter for the EmployeeSchedules we want to count
     *   }
     * })
    **/
    count<T extends EmployeeScheduleCountArgs>(
      args?: Subset<T, EmployeeScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeScheduleAggregateArgs>(args: Subset<T, EmployeeScheduleAggregateArgs>): Prisma.PrismaPromise<GetEmployeeScheduleAggregateType<T>>

    /**
     * Group by EmployeeSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeScheduleGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeSchedule model
   */
  readonly fields: EmployeeScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeSchedule model
   */
  interface EmployeeScheduleFieldRefs {
    readonly id: FieldRef<"EmployeeSchedule", 'Int'>
    readonly employeeId: FieldRef<"EmployeeSchedule", 'Int'>
    readonly date: FieldRef<"EmployeeSchedule", 'DateTime'>
    readonly shift: FieldRef<"EmployeeSchedule", 'String'>
    readonly customHours: FieldRef<"EmployeeSchedule", 'String'>
    readonly colorCode: FieldRef<"EmployeeSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeSchedule findUnique
   */
  export type EmployeeScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSchedule to fetch.
     */
    where: EmployeeScheduleWhereUniqueInput
  }

  /**
   * EmployeeSchedule findUniqueOrThrow
   */
  export type EmployeeScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSchedule to fetch.
     */
    where: EmployeeScheduleWhereUniqueInput
  }

  /**
   * EmployeeSchedule findFirst
   */
  export type EmployeeScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSchedule to fetch.
     */
    where?: EmployeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSchedules to fetch.
     */
    orderBy?: EmployeeScheduleOrderByWithRelationInput | EmployeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeSchedules.
     */
    cursor?: EmployeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeSchedules.
     */
    distinct?: EmployeeScheduleScalarFieldEnum | EmployeeScheduleScalarFieldEnum[]
  }

  /**
   * EmployeeSchedule findFirstOrThrow
   */
  export type EmployeeScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSchedule to fetch.
     */
    where?: EmployeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSchedules to fetch.
     */
    orderBy?: EmployeeScheduleOrderByWithRelationInput | EmployeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeSchedules.
     */
    cursor?: EmployeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeSchedules.
     */
    distinct?: EmployeeScheduleScalarFieldEnum | EmployeeScheduleScalarFieldEnum[]
  }

  /**
   * EmployeeSchedule findMany
   */
  export type EmployeeScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeSchedules to fetch.
     */
    where?: EmployeeScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeSchedules to fetch.
     */
    orderBy?: EmployeeScheduleOrderByWithRelationInput | EmployeeScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeSchedules.
     */
    cursor?: EmployeeScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeSchedules.
     */
    skip?: number
    distinct?: EmployeeScheduleScalarFieldEnum | EmployeeScheduleScalarFieldEnum[]
  }

  /**
   * EmployeeSchedule create
   */
  export type EmployeeScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeSchedule.
     */
    data: XOR<EmployeeScheduleCreateInput, EmployeeScheduleUncheckedCreateInput>
  }

  /**
   * EmployeeSchedule createMany
   */
  export type EmployeeScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeSchedules.
     */
    data: EmployeeScheduleCreateManyInput | EmployeeScheduleCreateManyInput[]
  }

  /**
   * EmployeeSchedule createManyAndReturn
   */
  export type EmployeeScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeSchedules.
     */
    data: EmployeeScheduleCreateManyInput | EmployeeScheduleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeSchedule update
   */
  export type EmployeeScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeSchedule.
     */
    data: XOR<EmployeeScheduleUpdateInput, EmployeeScheduleUncheckedUpdateInput>
    /**
     * Choose, which EmployeeSchedule to update.
     */
    where: EmployeeScheduleWhereUniqueInput
  }

  /**
   * EmployeeSchedule updateMany
   */
  export type EmployeeScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeSchedules.
     */
    data: XOR<EmployeeScheduleUpdateManyMutationInput, EmployeeScheduleUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeSchedules to update
     */
    where?: EmployeeScheduleWhereInput
    /**
     * Limit how many EmployeeSchedules to update.
     */
    limit?: number
  }

  /**
   * EmployeeSchedule updateManyAndReturn
   */
  export type EmployeeScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeSchedules.
     */
    data: XOR<EmployeeScheduleUpdateManyMutationInput, EmployeeScheduleUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeSchedules to update
     */
    where?: EmployeeScheduleWhereInput
    /**
     * Limit how many EmployeeSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeSchedule upsert
   */
  export type EmployeeScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeSchedule to update in case it exists.
     */
    where: EmployeeScheduleWhereUniqueInput
    /**
     * In case the EmployeeSchedule found by the `where` argument doesn't exist, create a new EmployeeSchedule with this data.
     */
    create: XOR<EmployeeScheduleCreateInput, EmployeeScheduleUncheckedCreateInput>
    /**
     * In case the EmployeeSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeScheduleUpdateInput, EmployeeScheduleUncheckedUpdateInput>
  }

  /**
   * EmployeeSchedule delete
   */
  export type EmployeeScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
    /**
     * Filter which EmployeeSchedule to delete.
     */
    where: EmployeeScheduleWhereUniqueInput
  }

  /**
   * EmployeeSchedule deleteMany
   */
  export type EmployeeScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeSchedules to delete
     */
    where?: EmployeeScheduleWhereInput
    /**
     * Limit how many EmployeeSchedules to delete.
     */
    limit?: number
  }

  /**
   * EmployeeSchedule without action
   */
  export type EmployeeScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeSchedule
     */
    select?: EmployeeScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeSchedule
     */
    omit?: EmployeeScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeScheduleInclude<ExtArgs> | null
  }


  /**
   * Model RegionFraction
   */

  export type AggregateRegionFraction = {
    _count: RegionFractionCountAggregateOutputType | null
    _avg: RegionFractionAvgAggregateOutputType | null
    _sum: RegionFractionSumAggregateOutputType | null
    _min: RegionFractionMinAggregateOutputType | null
    _max: RegionFractionMaxAggregateOutputType | null
  }

  export type RegionFractionAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
  }

  export type RegionFractionSumAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
  }

  export type RegionFractionMinAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
  }

  export type RegionFractionMaxAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
  }

  export type RegionFractionCountAggregateOutputType = {
    id: number
    regionId: number
    fractionId: number
    _all: number
  }


  export type RegionFractionAvgAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
  }

  export type RegionFractionSumAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
  }

  export type RegionFractionMinAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
  }

  export type RegionFractionMaxAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
  }

  export type RegionFractionCountAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
    _all?: true
  }

  export type RegionFractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionFraction to aggregate.
     */
    where?: RegionFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionFractions to fetch.
     */
    orderBy?: RegionFractionOrderByWithRelationInput | RegionFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionFractions
    **/
    _count?: true | RegionFractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionFractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionFractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionFractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionFractionMaxAggregateInputType
  }

  export type GetRegionFractionAggregateType<T extends RegionFractionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionFraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionFraction[P]>
      : GetScalarType<T[P], AggregateRegionFraction[P]>
  }




  export type RegionFractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionFractionWhereInput
    orderBy?: RegionFractionOrderByWithAggregationInput | RegionFractionOrderByWithAggregationInput[]
    by: RegionFractionScalarFieldEnum[] | RegionFractionScalarFieldEnum
    having?: RegionFractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionFractionCountAggregateInputType | true
    _avg?: RegionFractionAvgAggregateInputType
    _sum?: RegionFractionSumAggregateInputType
    _min?: RegionFractionMinAggregateInputType
    _max?: RegionFractionMaxAggregateInputType
  }

  export type RegionFractionGroupByOutputType = {
    id: number
    regionId: number
    fractionId: number
    _count: RegionFractionCountAggregateOutputType | null
    _avg: RegionFractionAvgAggregateOutputType | null
    _sum: RegionFractionSumAggregateOutputType | null
    _min: RegionFractionMinAggregateOutputType | null
    _max: RegionFractionMaxAggregateOutputType | null
  }

  type GetRegionFractionGroupByPayload<T extends RegionFractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionFractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionFractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionFractionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionFractionGroupByOutputType[P]>
        }
      >
    >


  export type RegionFractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionFraction"]>

  export type RegionFractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionFraction"]>

  export type RegionFractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionFraction"]>

  export type RegionFractionSelectScalar = {
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
  }

  export type RegionFractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionId" | "fractionId", ExtArgs["result"]["regionFraction"]>
  export type RegionFractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type RegionFractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type RegionFractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }

  export type $RegionFractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegionFraction"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      fraction: Prisma.$FractionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionId: number
      fractionId: number
    }, ExtArgs["result"]["regionFraction"]>
    composites: {}
  }

  type RegionFractionGetPayload<S extends boolean | null | undefined | RegionFractionDefaultArgs> = $Result.GetResult<Prisma.$RegionFractionPayload, S>

  type RegionFractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionFractionCountAggregateInputType | true
    }

  export interface RegionFractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegionFraction'], meta: { name: 'RegionFraction' } }
    /**
     * Find zero or one RegionFraction that matches the filter.
     * @param {RegionFractionFindUniqueArgs} args - Arguments to find a RegionFraction
     * @example
     * // Get one RegionFraction
     * const regionFraction = await prisma.regionFraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFractionFindUniqueArgs>(args: SelectSubset<T, RegionFractionFindUniqueArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegionFraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFractionFindUniqueOrThrowArgs} args - Arguments to find a RegionFraction
     * @example
     * // Get one RegionFraction
     * const regionFraction = await prisma.regionFraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFractionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionFraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionFindFirstArgs} args - Arguments to find a RegionFraction
     * @example
     * // Get one RegionFraction
     * const regionFraction = await prisma.regionFraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFractionFindFirstArgs>(args?: SelectSubset<T, RegionFractionFindFirstArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionFraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionFindFirstOrThrowArgs} args - Arguments to find a RegionFraction
     * @example
     * // Get one RegionFraction
     * const regionFraction = await prisma.regionFraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFractionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegionFractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionFractions
     * const regionFractions = await prisma.regionFraction.findMany()
     * 
     * // Get first 10 RegionFractions
     * const regionFractions = await prisma.regionFraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionFractionWithIdOnly = await prisma.regionFraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFractionFindManyArgs>(args?: SelectSubset<T, RegionFractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegionFraction.
     * @param {RegionFractionCreateArgs} args - Arguments to create a RegionFraction.
     * @example
     * // Create one RegionFraction
     * const RegionFraction = await prisma.regionFraction.create({
     *   data: {
     *     // ... data to create a RegionFraction
     *   }
     * })
     * 
     */
    create<T extends RegionFractionCreateArgs>(args: SelectSubset<T, RegionFractionCreateArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegionFractions.
     * @param {RegionFractionCreateManyArgs} args - Arguments to create many RegionFractions.
     * @example
     * // Create many RegionFractions
     * const regionFraction = await prisma.regionFraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionFractionCreateManyArgs>(args?: SelectSubset<T, RegionFractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegionFractions and returns the data saved in the database.
     * @param {RegionFractionCreateManyAndReturnArgs} args - Arguments to create many RegionFractions.
     * @example
     * // Create many RegionFractions
     * const regionFraction = await prisma.regionFraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegionFractions and only return the `id`
     * const regionFractionWithIdOnly = await prisma.regionFraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionFractionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionFractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegionFraction.
     * @param {RegionFractionDeleteArgs} args - Arguments to delete one RegionFraction.
     * @example
     * // Delete one RegionFraction
     * const RegionFraction = await prisma.regionFraction.delete({
     *   where: {
     *     // ... filter to delete one RegionFraction
     *   }
     * })
     * 
     */
    delete<T extends RegionFractionDeleteArgs>(args: SelectSubset<T, RegionFractionDeleteArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegionFraction.
     * @param {RegionFractionUpdateArgs} args - Arguments to update one RegionFraction.
     * @example
     * // Update one RegionFraction
     * const regionFraction = await prisma.regionFraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionFractionUpdateArgs>(args: SelectSubset<T, RegionFractionUpdateArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegionFractions.
     * @param {RegionFractionDeleteManyArgs} args - Arguments to filter RegionFractions to delete.
     * @example
     * // Delete a few RegionFractions
     * const { count } = await prisma.regionFraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionFractionDeleteManyArgs>(args?: SelectSubset<T, RegionFractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionFractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionFractions
     * const regionFraction = await prisma.regionFraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionFractionUpdateManyArgs>(args: SelectSubset<T, RegionFractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionFractions and returns the data updated in the database.
     * @param {RegionFractionUpdateManyAndReturnArgs} args - Arguments to update many RegionFractions.
     * @example
     * // Update many RegionFractions
     * const regionFraction = await prisma.regionFraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegionFractions and only return the `id`
     * const regionFractionWithIdOnly = await prisma.regionFraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionFractionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionFractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegionFraction.
     * @param {RegionFractionUpsertArgs} args - Arguments to update or create a RegionFraction.
     * @example
     * // Update or create a RegionFraction
     * const regionFraction = await prisma.regionFraction.upsert({
     *   create: {
     *     // ... data to create a RegionFraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionFraction we want to update
     *   }
     * })
     */
    upsert<T extends RegionFractionUpsertArgs>(args: SelectSubset<T, RegionFractionUpsertArgs<ExtArgs>>): Prisma__RegionFractionClient<$Result.GetResult<Prisma.$RegionFractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegionFractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionCountArgs} args - Arguments to filter RegionFractions to count.
     * @example
     * // Count the number of RegionFractions
     * const count = await prisma.regionFraction.count({
     *   where: {
     *     // ... the filter for the RegionFractions we want to count
     *   }
     * })
    **/
    count<T extends RegionFractionCountArgs>(
      args?: Subset<T, RegionFractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionFractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionFraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionFractionAggregateArgs>(args: Subset<T, RegionFractionAggregateArgs>): Prisma.PrismaPromise<GetRegionFractionAggregateType<T>>

    /**
     * Group by RegionFraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionFractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionFractionGroupByArgs['orderBy'] }
        : { orderBy?: RegionFractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionFractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionFractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegionFraction model
   */
  readonly fields: RegionFractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionFraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionFractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fraction<T extends FractionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FractionDefaultArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegionFraction model
   */
  interface RegionFractionFieldRefs {
    readonly id: FieldRef<"RegionFraction", 'Int'>
    readonly regionId: FieldRef<"RegionFraction", 'Int'>
    readonly fractionId: FieldRef<"RegionFraction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RegionFraction findUnique
   */
  export type RegionFractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * Filter, which RegionFraction to fetch.
     */
    where: RegionFractionWhereUniqueInput
  }

  /**
   * RegionFraction findUniqueOrThrow
   */
  export type RegionFractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * Filter, which RegionFraction to fetch.
     */
    where: RegionFractionWhereUniqueInput
  }

  /**
   * RegionFraction findFirst
   */
  export type RegionFractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * Filter, which RegionFraction to fetch.
     */
    where?: RegionFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionFractions to fetch.
     */
    orderBy?: RegionFractionOrderByWithRelationInput | RegionFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionFractions.
     */
    cursor?: RegionFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionFractions.
     */
    distinct?: RegionFractionScalarFieldEnum | RegionFractionScalarFieldEnum[]
  }

  /**
   * RegionFraction findFirstOrThrow
   */
  export type RegionFractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * Filter, which RegionFraction to fetch.
     */
    where?: RegionFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionFractions to fetch.
     */
    orderBy?: RegionFractionOrderByWithRelationInput | RegionFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionFractions.
     */
    cursor?: RegionFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionFractions.
     */
    distinct?: RegionFractionScalarFieldEnum | RegionFractionScalarFieldEnum[]
  }

  /**
   * RegionFraction findMany
   */
  export type RegionFractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * Filter, which RegionFractions to fetch.
     */
    where?: RegionFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionFractions to fetch.
     */
    orderBy?: RegionFractionOrderByWithRelationInput | RegionFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionFractions.
     */
    cursor?: RegionFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionFractions.
     */
    skip?: number
    distinct?: RegionFractionScalarFieldEnum | RegionFractionScalarFieldEnum[]
  }

  /**
   * RegionFraction create
   */
  export type RegionFractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * The data needed to create a RegionFraction.
     */
    data: XOR<RegionFractionCreateInput, RegionFractionUncheckedCreateInput>
  }

  /**
   * RegionFraction createMany
   */
  export type RegionFractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegionFractions.
     */
    data: RegionFractionCreateManyInput | RegionFractionCreateManyInput[]
  }

  /**
   * RegionFraction createManyAndReturn
   */
  export type RegionFractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * The data used to create many RegionFractions.
     */
    data: RegionFractionCreateManyInput | RegionFractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegionFraction update
   */
  export type RegionFractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * The data needed to update a RegionFraction.
     */
    data: XOR<RegionFractionUpdateInput, RegionFractionUncheckedUpdateInput>
    /**
     * Choose, which RegionFraction to update.
     */
    where: RegionFractionWhereUniqueInput
  }

  /**
   * RegionFraction updateMany
   */
  export type RegionFractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegionFractions.
     */
    data: XOR<RegionFractionUpdateManyMutationInput, RegionFractionUncheckedUpdateManyInput>
    /**
     * Filter which RegionFractions to update
     */
    where?: RegionFractionWhereInput
    /**
     * Limit how many RegionFractions to update.
     */
    limit?: number
  }

  /**
   * RegionFraction updateManyAndReturn
   */
  export type RegionFractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * The data used to update RegionFractions.
     */
    data: XOR<RegionFractionUpdateManyMutationInput, RegionFractionUncheckedUpdateManyInput>
    /**
     * Filter which RegionFractions to update
     */
    where?: RegionFractionWhereInput
    /**
     * Limit how many RegionFractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegionFraction upsert
   */
  export type RegionFractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * The filter to search for the RegionFraction to update in case it exists.
     */
    where: RegionFractionWhereUniqueInput
    /**
     * In case the RegionFraction found by the `where` argument doesn't exist, create a new RegionFraction with this data.
     */
    create: XOR<RegionFractionCreateInput, RegionFractionUncheckedCreateInput>
    /**
     * In case the RegionFraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionFractionUpdateInput, RegionFractionUncheckedUpdateInput>
  }

  /**
   * RegionFraction delete
   */
  export type RegionFractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
    /**
     * Filter which RegionFraction to delete.
     */
    where: RegionFractionWhereUniqueInput
  }

  /**
   * RegionFraction deleteMany
   */
  export type RegionFractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionFractions to delete
     */
    where?: RegionFractionWhereInput
    /**
     * Limit how many RegionFractions to delete.
     */
    limit?: number
  }

  /**
   * RegionFraction without action
   */
  export type RegionFractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionFraction
     */
    select?: RegionFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionFraction
     */
    omit?: RegionFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionFractionInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEntry
   */

  export type AggregateCalendarEntry = {
    _count: CalendarEntryCountAggregateOutputType | null
    _avg: CalendarEntryAvgAggregateOutputType | null
    _sum: CalendarEntrySumAggregateOutputType | null
    _min: CalendarEntryMinAggregateOutputType | null
    _max: CalendarEntryMaxAggregateOutputType | null
  }

  export type CalendarEntryAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
  }

  export type CalendarEntrySumAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
  }

  export type CalendarEntryMinAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
    date: Date | null
  }

  export type CalendarEntryMaxAggregateOutputType = {
    id: number | null
    regionId: number | null
    fractionId: number | null
    date: Date | null
  }

  export type CalendarEntryCountAggregateOutputType = {
    id: number
    regionId: number
    fractionId: number
    date: number
    _all: number
  }


  export type CalendarEntryAvgAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
  }

  export type CalendarEntrySumAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
  }

  export type CalendarEntryMinAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
    date?: true
  }

  export type CalendarEntryMaxAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
    date?: true
  }

  export type CalendarEntryCountAggregateInputType = {
    id?: true
    regionId?: true
    fractionId?: true
    date?: true
    _all?: true
  }

  export type CalendarEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEntry to aggregate.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEntries
    **/
    _count?: true | CalendarEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEntryMaxAggregateInputType
  }

  export type GetCalendarEntryAggregateType<T extends CalendarEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEntry[P]>
      : GetScalarType<T[P], AggregateCalendarEntry[P]>
  }




  export type CalendarEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEntryWhereInput
    orderBy?: CalendarEntryOrderByWithAggregationInput | CalendarEntryOrderByWithAggregationInput[]
    by: CalendarEntryScalarFieldEnum[] | CalendarEntryScalarFieldEnum
    having?: CalendarEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEntryCountAggregateInputType | true
    _avg?: CalendarEntryAvgAggregateInputType
    _sum?: CalendarEntrySumAggregateInputType
    _min?: CalendarEntryMinAggregateInputType
    _max?: CalendarEntryMaxAggregateInputType
  }

  export type CalendarEntryGroupByOutputType = {
    id: number
    regionId: number
    fractionId: number
    date: Date
    _count: CalendarEntryCountAggregateOutputType | null
    _avg: CalendarEntryAvgAggregateOutputType | null
    _sum: CalendarEntrySumAggregateOutputType | null
    _min: CalendarEntryMinAggregateOutputType | null
    _max: CalendarEntryMaxAggregateOutputType | null
  }

  type GetCalendarEntryGroupByPayload<T extends CalendarEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEntryGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    date?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEntry"]>

  export type CalendarEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    date?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEntry"]>

  export type CalendarEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    date?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarEntry"]>

  export type CalendarEntrySelectScalar = {
    id?: boolean
    regionId?: boolean
    fractionId?: boolean
    date?: boolean
  }

  export type CalendarEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionId" | "fractionId" | "date", ExtArgs["result"]["calendarEntry"]>
  export type CalendarEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type CalendarEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type CalendarEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }

  export type $CalendarEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEntry"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      fraction: Prisma.$FractionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionId: number
      fractionId: number
      date: Date
    }, ExtArgs["result"]["calendarEntry"]>
    composites: {}
  }

  type CalendarEntryGetPayload<S extends boolean | null | undefined | CalendarEntryDefaultArgs> = $Result.GetResult<Prisma.$CalendarEntryPayload, S>

  type CalendarEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarEntryCountAggregateInputType | true
    }

  export interface CalendarEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEntry'], meta: { name: 'CalendarEntry' } }
    /**
     * Find zero or one CalendarEntry that matches the filter.
     * @param {CalendarEntryFindUniqueArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEntryFindUniqueArgs>(args: SelectSubset<T, CalendarEntryFindUniqueArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarEntryFindUniqueOrThrowArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryFindFirstArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEntryFindFirstArgs>(args?: SelectSubset<T, CalendarEntryFindFirstArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryFindFirstOrThrowArgs} args - Arguments to find a CalendarEntry
     * @example
     * // Get one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEntries
     * const calendarEntries = await prisma.calendarEntry.findMany()
     * 
     * // Get first 10 CalendarEntries
     * const calendarEntries = await prisma.calendarEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEntryWithIdOnly = await prisma.calendarEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEntryFindManyArgs>(args?: SelectSubset<T, CalendarEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarEntry.
     * @param {CalendarEntryCreateArgs} args - Arguments to create a CalendarEntry.
     * @example
     * // Create one CalendarEntry
     * const CalendarEntry = await prisma.calendarEntry.create({
     *   data: {
     *     // ... data to create a CalendarEntry
     *   }
     * })
     * 
     */
    create<T extends CalendarEntryCreateArgs>(args: SelectSubset<T, CalendarEntryCreateArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarEntries.
     * @param {CalendarEntryCreateManyArgs} args - Arguments to create many CalendarEntries.
     * @example
     * // Create many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEntryCreateManyArgs>(args?: SelectSubset<T, CalendarEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEntries and returns the data saved in the database.
     * @param {CalendarEntryCreateManyAndReturnArgs} args - Arguments to create many CalendarEntries.
     * @example
     * // Create many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEntries and only return the `id`
     * const calendarEntryWithIdOnly = await prisma.calendarEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CalendarEntry.
     * @param {CalendarEntryDeleteArgs} args - Arguments to delete one CalendarEntry.
     * @example
     * // Delete one CalendarEntry
     * const CalendarEntry = await prisma.calendarEntry.delete({
     *   where: {
     *     // ... filter to delete one CalendarEntry
     *   }
     * })
     * 
     */
    delete<T extends CalendarEntryDeleteArgs>(args: SelectSubset<T, CalendarEntryDeleteArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarEntry.
     * @param {CalendarEntryUpdateArgs} args - Arguments to update one CalendarEntry.
     * @example
     * // Update one CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEntryUpdateArgs>(args: SelectSubset<T, CalendarEntryUpdateArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarEntries.
     * @param {CalendarEntryDeleteManyArgs} args - Arguments to filter CalendarEntries to delete.
     * @example
     * // Delete a few CalendarEntries
     * const { count } = await prisma.calendarEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEntryDeleteManyArgs>(args?: SelectSubset<T, CalendarEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEntryUpdateManyArgs>(args: SelectSubset<T, CalendarEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEntries and returns the data updated in the database.
     * @param {CalendarEntryUpdateManyAndReturnArgs} args - Arguments to update many CalendarEntries.
     * @example
     * // Update many CalendarEntries
     * const calendarEntry = await prisma.calendarEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CalendarEntries and only return the `id`
     * const calendarEntryWithIdOnly = await prisma.calendarEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CalendarEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, CalendarEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CalendarEntry.
     * @param {CalendarEntryUpsertArgs} args - Arguments to update or create a CalendarEntry.
     * @example
     * // Update or create a CalendarEntry
     * const calendarEntry = await prisma.calendarEntry.upsert({
     *   create: {
     *     // ... data to create a CalendarEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEntry we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEntryUpsertArgs>(args: SelectSubset<T, CalendarEntryUpsertArgs<ExtArgs>>): Prisma__CalendarEntryClient<$Result.GetResult<Prisma.$CalendarEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryCountArgs} args - Arguments to filter CalendarEntries to count.
     * @example
     * // Count the number of CalendarEntries
     * const count = await prisma.calendarEntry.count({
     *   where: {
     *     // ... the filter for the CalendarEntries we want to count
     *   }
     * })
    **/
    count<T extends CalendarEntryCountArgs>(
      args?: Subset<T, CalendarEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEntryAggregateArgs>(args: Subset<T, CalendarEntryAggregateArgs>): Prisma.PrismaPromise<GetCalendarEntryAggregateType<T>>

    /**
     * Group by CalendarEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEntryGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEntry model
   */
  readonly fields: CalendarEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fraction<T extends FractionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FractionDefaultArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEntry model
   */
  interface CalendarEntryFieldRefs {
    readonly id: FieldRef<"CalendarEntry", 'Int'>
    readonly regionId: FieldRef<"CalendarEntry", 'Int'>
    readonly fractionId: FieldRef<"CalendarEntry", 'Int'>
    readonly date: FieldRef<"CalendarEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEntry findUnique
   */
  export type CalendarEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry findUniqueOrThrow
   */
  export type CalendarEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry findFirst
   */
  export type CalendarEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEntries.
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEntries.
     */
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * CalendarEntry findFirstOrThrow
   */
  export type CalendarEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEntry to fetch.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEntries.
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEntries.
     */
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * CalendarEntry findMany
   */
  export type CalendarEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * Filter, which CalendarEntries to fetch.
     */
    where?: CalendarEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEntries to fetch.
     */
    orderBy?: CalendarEntryOrderByWithRelationInput | CalendarEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEntries.
     */
    cursor?: CalendarEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEntries.
     */
    skip?: number
    distinct?: CalendarEntryScalarFieldEnum | CalendarEntryScalarFieldEnum[]
  }

  /**
   * CalendarEntry create
   */
  export type CalendarEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarEntry.
     */
    data: XOR<CalendarEntryCreateInput, CalendarEntryUncheckedCreateInput>
  }

  /**
   * CalendarEntry createMany
   */
  export type CalendarEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEntries.
     */
    data: CalendarEntryCreateManyInput | CalendarEntryCreateManyInput[]
  }

  /**
   * CalendarEntry createManyAndReturn
   */
  export type CalendarEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The data used to create many CalendarEntries.
     */
    data: CalendarEntryCreateManyInput | CalendarEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEntry update
   */
  export type CalendarEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarEntry.
     */
    data: XOR<CalendarEntryUpdateInput, CalendarEntryUncheckedUpdateInput>
    /**
     * Choose, which CalendarEntry to update.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry updateMany
   */
  export type CalendarEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEntries.
     */
    data: XOR<CalendarEntryUpdateManyMutationInput, CalendarEntryUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEntries to update
     */
    where?: CalendarEntryWhereInput
    /**
     * Limit how many CalendarEntries to update.
     */
    limit?: number
  }

  /**
   * CalendarEntry updateManyAndReturn
   */
  export type CalendarEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * The data used to update CalendarEntries.
     */
    data: XOR<CalendarEntryUpdateManyMutationInput, CalendarEntryUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEntries to update
     */
    where?: CalendarEntryWhereInput
    /**
     * Limit how many CalendarEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CalendarEntry upsert
   */
  export type CalendarEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarEntry to update in case it exists.
     */
    where: CalendarEntryWhereUniqueInput
    /**
     * In case the CalendarEntry found by the `where` argument doesn't exist, create a new CalendarEntry with this data.
     */
    create: XOR<CalendarEntryCreateInput, CalendarEntryUncheckedCreateInput>
    /**
     * In case the CalendarEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEntryUpdateInput, CalendarEntryUncheckedUpdateInput>
  }

  /**
   * CalendarEntry delete
   */
  export type CalendarEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
    /**
     * Filter which CalendarEntry to delete.
     */
    where: CalendarEntryWhereUniqueInput
  }

  /**
   * CalendarEntry deleteMany
   */
  export type CalendarEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEntries to delete
     */
    where?: CalendarEntryWhereInput
    /**
     * Limit how many CalendarEntries to delete.
     */
    limit?: number
  }

  /**
   * CalendarEntry without action
   */
  export type CalendarEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEntry
     */
    select?: CalendarEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarEntry
     */
    omit?: CalendarEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarEntryInclude<ExtArgs> | null
  }


  /**
   * Model DailyAssignment
   */

  export type AggregateDailyAssignment = {
    _count: DailyAssignmentCountAggregateOutputType | null
    _avg: DailyAssignmentAvgAggregateOutputType | null
    _sum: DailyAssignmentSumAggregateOutputType | null
    _min: DailyAssignmentMinAggregateOutputType | null
    _max: DailyAssignmentMaxAggregateOutputType | null
  }

  export type DailyAssignmentAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    vehicleId: number | null
    driverId: number | null
    municipalityId: number | null
  }

  export type DailyAssignmentSumAggregateOutputType = {
    id: number | null
    regionId: number | null
    vehicleId: number | null
    driverId: number | null
    municipalityId: number | null
  }

  export type DailyAssignmentMinAggregateOutputType = {
    id: number | null
    date: Date | null
    regionId: number | null
    vehicleId: number | null
    driverId: number | null
    type: $Enums.DailyAssignmentType | null
    shift: string | null
    municipalityId: number | null
    workType: string | null
  }

  export type DailyAssignmentMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    regionId: number | null
    vehicleId: number | null
    driverId: number | null
    type: $Enums.DailyAssignmentType | null
    shift: string | null
    municipalityId: number | null
    workType: string | null
  }

  export type DailyAssignmentCountAggregateOutputType = {
    id: number
    date: number
    regionId: number
    vehicleId: number
    driverId: number
    type: number
    shift: number
    municipalityId: number
    equipment: number
    workType: number
    _all: number
  }


  export type DailyAssignmentAvgAggregateInputType = {
    id?: true
    regionId?: true
    vehicleId?: true
    driverId?: true
    municipalityId?: true
  }

  export type DailyAssignmentSumAggregateInputType = {
    id?: true
    regionId?: true
    vehicleId?: true
    driverId?: true
    municipalityId?: true
  }

  export type DailyAssignmentMinAggregateInputType = {
    id?: true
    date?: true
    regionId?: true
    vehicleId?: true
    driverId?: true
    type?: true
    shift?: true
    municipalityId?: true
    workType?: true
  }

  export type DailyAssignmentMaxAggregateInputType = {
    id?: true
    date?: true
    regionId?: true
    vehicleId?: true
    driverId?: true
    type?: true
    shift?: true
    municipalityId?: true
    workType?: true
  }

  export type DailyAssignmentCountAggregateInputType = {
    id?: true
    date?: true
    regionId?: true
    vehicleId?: true
    driverId?: true
    type?: true
    shift?: true
    municipalityId?: true
    equipment?: true
    workType?: true
    _all?: true
  }

  export type DailyAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAssignment to aggregate.
     */
    where?: DailyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignments to fetch.
     */
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyAssignments
    **/
    _count?: true | DailyAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyAssignmentMaxAggregateInputType
  }

  export type GetDailyAssignmentAggregateType<T extends DailyAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyAssignment[P]>
      : GetScalarType<T[P], AggregateDailyAssignment[P]>
  }




  export type DailyAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentWhereInput
    orderBy?: DailyAssignmentOrderByWithAggregationInput | DailyAssignmentOrderByWithAggregationInput[]
    by: DailyAssignmentScalarFieldEnum[] | DailyAssignmentScalarFieldEnum
    having?: DailyAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyAssignmentCountAggregateInputType | true
    _avg?: DailyAssignmentAvgAggregateInputType
    _sum?: DailyAssignmentSumAggregateInputType
    _min?: DailyAssignmentMinAggregateInputType
    _max?: DailyAssignmentMaxAggregateInputType
  }

  export type DailyAssignmentGroupByOutputType = {
    id: number
    date: Date
    regionId: number
    vehicleId: number
    driverId: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId: number | null
    equipment: JsonValue | null
    workType: string | null
    _count: DailyAssignmentCountAggregateOutputType | null
    _avg: DailyAssignmentAvgAggregateOutputType | null
    _sum: DailyAssignmentSumAggregateOutputType | null
    _min: DailyAssignmentMinAggregateOutputType | null
    _max: DailyAssignmentMaxAggregateOutputType | null
  }

  type GetDailyAssignmentGroupByPayload<T extends DailyAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DailyAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DailyAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    regionId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    type?: boolean
    shift?: boolean
    municipalityId?: boolean
    equipment?: boolean
    workType?: boolean
    municipality?: boolean | DailyAssignment$municipalityArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DailyAssignment$driverArgs<ExtArgs>
    assistants?: boolean | DailyAssignment$assistantsArgs<ExtArgs>
    fractions?: boolean | DailyAssignment$fractionsArgs<ExtArgs>
    _count?: boolean | DailyAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignment"]>

  export type DailyAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    regionId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    type?: boolean
    shift?: boolean
    municipalityId?: boolean
    equipment?: boolean
    workType?: boolean
    municipality?: boolean | DailyAssignment$municipalityArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DailyAssignment$driverArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignment"]>

  export type DailyAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    regionId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    type?: boolean
    shift?: boolean
    municipalityId?: boolean
    equipment?: boolean
    workType?: boolean
    municipality?: boolean | DailyAssignment$municipalityArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DailyAssignment$driverArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignment"]>

  export type DailyAssignmentSelectScalar = {
    id?: boolean
    date?: boolean
    regionId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    type?: boolean
    shift?: boolean
    municipalityId?: boolean
    equipment?: boolean
    workType?: boolean
  }

  export type DailyAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "regionId" | "vehicleId" | "driverId" | "type" | "shift" | "municipalityId" | "equipment" | "workType", ExtArgs["result"]["dailyAssignment"]>
  export type DailyAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | DailyAssignment$municipalityArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DailyAssignment$driverArgs<ExtArgs>
    assistants?: boolean | DailyAssignment$assistantsArgs<ExtArgs>
    fractions?: boolean | DailyAssignment$fractionsArgs<ExtArgs>
    _count?: boolean | DailyAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailyAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | DailyAssignment$municipalityArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DailyAssignment$driverArgs<ExtArgs>
  }
  export type DailyAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | DailyAssignment$municipalityArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    driver?: boolean | DailyAssignment$driverArgs<ExtArgs>
  }

  export type $DailyAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyAssignment"
    objects: {
      municipality: Prisma.$MunicipalityPayload<ExtArgs> | null
      region: Prisma.$RegionPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      driver: Prisma.$EmployeePayload<ExtArgs> | null
      assistants: Prisma.$DailyAssignmentAssistantPayload<ExtArgs>[]
      fractions: Prisma.$DailyAssignmentFractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      regionId: number
      vehicleId: number
      driverId: number | null
      type: $Enums.DailyAssignmentType
      shift: string
      municipalityId: number | null
      equipment: Prisma.JsonValue | null
      workType: string | null
    }, ExtArgs["result"]["dailyAssignment"]>
    composites: {}
  }

  type DailyAssignmentGetPayload<S extends boolean | null | undefined | DailyAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DailyAssignmentPayload, S>

  type DailyAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyAssignmentCountAggregateInputType | true
    }

  export interface DailyAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyAssignment'], meta: { name: 'DailyAssignment' } }
    /**
     * Find zero or one DailyAssignment that matches the filter.
     * @param {DailyAssignmentFindUniqueArgs} args - Arguments to find a DailyAssignment
     * @example
     * // Get one DailyAssignment
     * const dailyAssignment = await prisma.dailyAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyAssignmentFindUniqueArgs>(args: SelectSubset<T, DailyAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DailyAssignment
     * @example
     * // Get one DailyAssignment
     * const dailyAssignment = await prisma.dailyAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFindFirstArgs} args - Arguments to find a DailyAssignment
     * @example
     * // Get one DailyAssignment
     * const dailyAssignment = await prisma.dailyAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyAssignmentFindFirstArgs>(args?: SelectSubset<T, DailyAssignmentFindFirstArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFindFirstOrThrowArgs} args - Arguments to find a DailyAssignment
     * @example
     * // Get one DailyAssignment
     * const dailyAssignment = await prisma.dailyAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyAssignments
     * const dailyAssignments = await prisma.dailyAssignment.findMany()
     * 
     * // Get first 10 DailyAssignments
     * const dailyAssignments = await prisma.dailyAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyAssignmentWithIdOnly = await prisma.dailyAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyAssignmentFindManyArgs>(args?: SelectSubset<T, DailyAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyAssignment.
     * @param {DailyAssignmentCreateArgs} args - Arguments to create a DailyAssignment.
     * @example
     * // Create one DailyAssignment
     * const DailyAssignment = await prisma.dailyAssignment.create({
     *   data: {
     *     // ... data to create a DailyAssignment
     *   }
     * })
     * 
     */
    create<T extends DailyAssignmentCreateArgs>(args: SelectSubset<T, DailyAssignmentCreateArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyAssignments.
     * @param {DailyAssignmentCreateManyArgs} args - Arguments to create many DailyAssignments.
     * @example
     * // Create many DailyAssignments
     * const dailyAssignment = await prisma.dailyAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyAssignmentCreateManyArgs>(args?: SelectSubset<T, DailyAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyAssignments and returns the data saved in the database.
     * @param {DailyAssignmentCreateManyAndReturnArgs} args - Arguments to create many DailyAssignments.
     * @example
     * // Create many DailyAssignments
     * const dailyAssignment = await prisma.dailyAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyAssignments and only return the `id`
     * const dailyAssignmentWithIdOnly = await prisma.dailyAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyAssignment.
     * @param {DailyAssignmentDeleteArgs} args - Arguments to delete one DailyAssignment.
     * @example
     * // Delete one DailyAssignment
     * const DailyAssignment = await prisma.dailyAssignment.delete({
     *   where: {
     *     // ... filter to delete one DailyAssignment
     *   }
     * })
     * 
     */
    delete<T extends DailyAssignmentDeleteArgs>(args: SelectSubset<T, DailyAssignmentDeleteArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyAssignment.
     * @param {DailyAssignmentUpdateArgs} args - Arguments to update one DailyAssignment.
     * @example
     * // Update one DailyAssignment
     * const dailyAssignment = await prisma.dailyAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyAssignmentUpdateArgs>(args: SelectSubset<T, DailyAssignmentUpdateArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyAssignments.
     * @param {DailyAssignmentDeleteManyArgs} args - Arguments to filter DailyAssignments to delete.
     * @example
     * // Delete a few DailyAssignments
     * const { count } = await prisma.dailyAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyAssignmentDeleteManyArgs>(args?: SelectSubset<T, DailyAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyAssignments
     * const dailyAssignment = await prisma.dailyAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyAssignmentUpdateManyArgs>(args: SelectSubset<T, DailyAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAssignments and returns the data updated in the database.
     * @param {DailyAssignmentUpdateManyAndReturnArgs} args - Arguments to update many DailyAssignments.
     * @example
     * // Update many DailyAssignments
     * const dailyAssignment = await prisma.dailyAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyAssignments and only return the `id`
     * const dailyAssignmentWithIdOnly = await prisma.dailyAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyAssignment.
     * @param {DailyAssignmentUpsertArgs} args - Arguments to update or create a DailyAssignment.
     * @example
     * // Update or create a DailyAssignment
     * const dailyAssignment = await prisma.dailyAssignment.upsert({
     *   create: {
     *     // ... data to create a DailyAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DailyAssignmentUpsertArgs>(args: SelectSubset<T, DailyAssignmentUpsertArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentCountArgs} args - Arguments to filter DailyAssignments to count.
     * @example
     * // Count the number of DailyAssignments
     * const count = await prisma.dailyAssignment.count({
     *   where: {
     *     // ... the filter for the DailyAssignments we want to count
     *   }
     * })
    **/
    count<T extends DailyAssignmentCountArgs>(
      args?: Subset<T, DailyAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyAssignmentAggregateArgs>(args: Subset<T, DailyAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDailyAssignmentAggregateType<T>>

    /**
     * Group by DailyAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DailyAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyAssignment model
   */
  readonly fields: DailyAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipality<T extends DailyAssignment$municipalityArgs<ExtArgs> = {}>(args?: Subset<T, DailyAssignment$municipalityArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    driver<T extends DailyAssignment$driverArgs<ExtArgs> = {}>(args?: Subset<T, DailyAssignment$driverArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assistants<T extends DailyAssignment$assistantsArgs<ExtArgs> = {}>(args?: Subset<T, DailyAssignment$assistantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fractions<T extends DailyAssignment$fractionsArgs<ExtArgs> = {}>(args?: Subset<T, DailyAssignment$fractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyAssignment model
   */
  interface DailyAssignmentFieldRefs {
    readonly id: FieldRef<"DailyAssignment", 'Int'>
    readonly date: FieldRef<"DailyAssignment", 'DateTime'>
    readonly regionId: FieldRef<"DailyAssignment", 'Int'>
    readonly vehicleId: FieldRef<"DailyAssignment", 'Int'>
    readonly driverId: FieldRef<"DailyAssignment", 'Int'>
    readonly type: FieldRef<"DailyAssignment", 'DailyAssignmentType'>
    readonly shift: FieldRef<"DailyAssignment", 'String'>
    readonly municipalityId: FieldRef<"DailyAssignment", 'Int'>
    readonly equipment: FieldRef<"DailyAssignment", 'Json'>
    readonly workType: FieldRef<"DailyAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DailyAssignment findUnique
   */
  export type DailyAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignment to fetch.
     */
    where: DailyAssignmentWhereUniqueInput
  }

  /**
   * DailyAssignment findUniqueOrThrow
   */
  export type DailyAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignment to fetch.
     */
    where: DailyAssignmentWhereUniqueInput
  }

  /**
   * DailyAssignment findFirst
   */
  export type DailyAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignment to fetch.
     */
    where?: DailyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignments to fetch.
     */
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAssignments.
     */
    cursor?: DailyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAssignments.
     */
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * DailyAssignment findFirstOrThrow
   */
  export type DailyAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignment to fetch.
     */
    where?: DailyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignments to fetch.
     */
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAssignments.
     */
    cursor?: DailyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAssignments.
     */
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * DailyAssignment findMany
   */
  export type DailyAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignments to fetch.
     */
    where?: DailyAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignments to fetch.
     */
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyAssignments.
     */
    cursor?: DailyAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignments.
     */
    skip?: number
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * DailyAssignment create
   */
  export type DailyAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyAssignment.
     */
    data: XOR<DailyAssignmentCreateInput, DailyAssignmentUncheckedCreateInput>
  }

  /**
   * DailyAssignment createMany
   */
  export type DailyAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyAssignments.
     */
    data: DailyAssignmentCreateManyInput | DailyAssignmentCreateManyInput[]
  }

  /**
   * DailyAssignment createManyAndReturn
   */
  export type DailyAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many DailyAssignments.
     */
    data: DailyAssignmentCreateManyInput | DailyAssignmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyAssignment update
   */
  export type DailyAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyAssignment.
     */
    data: XOR<DailyAssignmentUpdateInput, DailyAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DailyAssignment to update.
     */
    where: DailyAssignmentWhereUniqueInput
  }

  /**
   * DailyAssignment updateMany
   */
  export type DailyAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyAssignments.
     */
    data: XOR<DailyAssignmentUpdateManyMutationInput, DailyAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DailyAssignments to update
     */
    where?: DailyAssignmentWhereInput
    /**
     * Limit how many DailyAssignments to update.
     */
    limit?: number
  }

  /**
   * DailyAssignment updateManyAndReturn
   */
  export type DailyAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update DailyAssignments.
     */
    data: XOR<DailyAssignmentUpdateManyMutationInput, DailyAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DailyAssignments to update
     */
    where?: DailyAssignmentWhereInput
    /**
     * Limit how many DailyAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyAssignment upsert
   */
  export type DailyAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyAssignment to update in case it exists.
     */
    where: DailyAssignmentWhereUniqueInput
    /**
     * In case the DailyAssignment found by the `where` argument doesn't exist, create a new DailyAssignment with this data.
     */
    create: XOR<DailyAssignmentCreateInput, DailyAssignmentUncheckedCreateInput>
    /**
     * In case the DailyAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyAssignmentUpdateInput, DailyAssignmentUncheckedUpdateInput>
  }

  /**
   * DailyAssignment delete
   */
  export type DailyAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DailyAssignment to delete.
     */
    where: DailyAssignmentWhereUniqueInput
  }

  /**
   * DailyAssignment deleteMany
   */
  export type DailyAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAssignments to delete
     */
    where?: DailyAssignmentWhereInput
    /**
     * Limit how many DailyAssignments to delete.
     */
    limit?: number
  }

  /**
   * DailyAssignment.municipality
   */
  export type DailyAssignment$municipalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
  }

  /**
   * DailyAssignment.driver
   */
  export type DailyAssignment$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * DailyAssignment.assistants
   */
  export type DailyAssignment$assistantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    where?: DailyAssignmentAssistantWhereInput
    orderBy?: DailyAssignmentAssistantOrderByWithRelationInput | DailyAssignmentAssistantOrderByWithRelationInput[]
    cursor?: DailyAssignmentAssistantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentAssistantScalarFieldEnum | DailyAssignmentAssistantScalarFieldEnum[]
  }

  /**
   * DailyAssignment.fractions
   */
  export type DailyAssignment$fractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    where?: DailyAssignmentFractionWhereInput
    orderBy?: DailyAssignmentFractionOrderByWithRelationInput | DailyAssignmentFractionOrderByWithRelationInput[]
    cursor?: DailyAssignmentFractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentFractionScalarFieldEnum | DailyAssignmentFractionScalarFieldEnum[]
  }

  /**
   * DailyAssignment without action
   */
  export type DailyAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model DailyAssignmentAssistant
   */

  export type AggregateDailyAssignmentAssistant = {
    _count: DailyAssignmentAssistantCountAggregateOutputType | null
    _avg: DailyAssignmentAssistantAvgAggregateOutputType | null
    _sum: DailyAssignmentAssistantSumAggregateOutputType | null
    _min: DailyAssignmentAssistantMinAggregateOutputType | null
    _max: DailyAssignmentAssistantMaxAggregateOutputType | null
  }

  export type DailyAssignmentAssistantAvgAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    employeeId: number | null
  }

  export type DailyAssignmentAssistantSumAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    employeeId: number | null
  }

  export type DailyAssignmentAssistantMinAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    employeeId: number | null
  }

  export type DailyAssignmentAssistantMaxAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    employeeId: number | null
  }

  export type DailyAssignmentAssistantCountAggregateOutputType = {
    id: number
    dailyAssignmentId: number
    employeeId: number
    _all: number
  }


  export type DailyAssignmentAssistantAvgAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    employeeId?: true
  }

  export type DailyAssignmentAssistantSumAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    employeeId?: true
  }

  export type DailyAssignmentAssistantMinAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    employeeId?: true
  }

  export type DailyAssignmentAssistantMaxAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    employeeId?: true
  }

  export type DailyAssignmentAssistantCountAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    employeeId?: true
    _all?: true
  }

  export type DailyAssignmentAssistantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAssignmentAssistant to aggregate.
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentAssistants to fetch.
     */
    orderBy?: DailyAssignmentAssistantOrderByWithRelationInput | DailyAssignmentAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyAssignmentAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyAssignmentAssistants
    **/
    _count?: true | DailyAssignmentAssistantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyAssignmentAssistantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyAssignmentAssistantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyAssignmentAssistantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyAssignmentAssistantMaxAggregateInputType
  }

  export type GetDailyAssignmentAssistantAggregateType<T extends DailyAssignmentAssistantAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyAssignmentAssistant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyAssignmentAssistant[P]>
      : GetScalarType<T[P], AggregateDailyAssignmentAssistant[P]>
  }




  export type DailyAssignmentAssistantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentAssistantWhereInput
    orderBy?: DailyAssignmentAssistantOrderByWithAggregationInput | DailyAssignmentAssistantOrderByWithAggregationInput[]
    by: DailyAssignmentAssistantScalarFieldEnum[] | DailyAssignmentAssistantScalarFieldEnum
    having?: DailyAssignmentAssistantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyAssignmentAssistantCountAggregateInputType | true
    _avg?: DailyAssignmentAssistantAvgAggregateInputType
    _sum?: DailyAssignmentAssistantSumAggregateInputType
    _min?: DailyAssignmentAssistantMinAggregateInputType
    _max?: DailyAssignmentAssistantMaxAggregateInputType
  }

  export type DailyAssignmentAssistantGroupByOutputType = {
    id: number
    dailyAssignmentId: number
    employeeId: number
    _count: DailyAssignmentAssistantCountAggregateOutputType | null
    _avg: DailyAssignmentAssistantAvgAggregateOutputType | null
    _sum: DailyAssignmentAssistantSumAggregateOutputType | null
    _min: DailyAssignmentAssistantMinAggregateOutputType | null
    _max: DailyAssignmentAssistantMaxAggregateOutputType | null
  }

  type GetDailyAssignmentAssistantGroupByPayload<T extends DailyAssignmentAssistantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyAssignmentAssistantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyAssignmentAssistantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyAssignmentAssistantGroupByOutputType[P]>
            : GetScalarType<T[P], DailyAssignmentAssistantGroupByOutputType[P]>
        }
      >
    >


  export type DailyAssignmentAssistantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyAssignmentId?: boolean
    employeeId?: boolean
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignmentAssistant"]>

  export type DailyAssignmentAssistantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyAssignmentId?: boolean
    employeeId?: boolean
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignmentAssistant"]>

  export type DailyAssignmentAssistantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyAssignmentId?: boolean
    employeeId?: boolean
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignmentAssistant"]>

  export type DailyAssignmentAssistantSelectScalar = {
    id?: boolean
    dailyAssignmentId?: boolean
    employeeId?: boolean
  }

  export type DailyAssignmentAssistantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dailyAssignmentId" | "employeeId", ExtArgs["result"]["dailyAssignmentAssistant"]>
  export type DailyAssignmentAssistantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DailyAssignmentAssistantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DailyAssignmentAssistantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $DailyAssignmentAssistantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyAssignmentAssistant"
    objects: {
      dailyAssignment: Prisma.$DailyAssignmentPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dailyAssignmentId: number
      employeeId: number
    }, ExtArgs["result"]["dailyAssignmentAssistant"]>
    composites: {}
  }

  type DailyAssignmentAssistantGetPayload<S extends boolean | null | undefined | DailyAssignmentAssistantDefaultArgs> = $Result.GetResult<Prisma.$DailyAssignmentAssistantPayload, S>

  type DailyAssignmentAssistantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyAssignmentAssistantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyAssignmentAssistantCountAggregateInputType | true
    }

  export interface DailyAssignmentAssistantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyAssignmentAssistant'], meta: { name: 'DailyAssignmentAssistant' } }
    /**
     * Find zero or one DailyAssignmentAssistant that matches the filter.
     * @param {DailyAssignmentAssistantFindUniqueArgs} args - Arguments to find a DailyAssignmentAssistant
     * @example
     * // Get one DailyAssignmentAssistant
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyAssignmentAssistantFindUniqueArgs>(args: SelectSubset<T, DailyAssignmentAssistantFindUniqueArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyAssignmentAssistant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyAssignmentAssistantFindUniqueOrThrowArgs} args - Arguments to find a DailyAssignmentAssistant
     * @example
     * // Get one DailyAssignmentAssistant
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyAssignmentAssistantFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyAssignmentAssistantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyAssignmentAssistant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantFindFirstArgs} args - Arguments to find a DailyAssignmentAssistant
     * @example
     * // Get one DailyAssignmentAssistant
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyAssignmentAssistantFindFirstArgs>(args?: SelectSubset<T, DailyAssignmentAssistantFindFirstArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyAssignmentAssistant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantFindFirstOrThrowArgs} args - Arguments to find a DailyAssignmentAssistant
     * @example
     * // Get one DailyAssignmentAssistant
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyAssignmentAssistantFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyAssignmentAssistantFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyAssignmentAssistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyAssignmentAssistants
     * const dailyAssignmentAssistants = await prisma.dailyAssignmentAssistant.findMany()
     * 
     * // Get first 10 DailyAssignmentAssistants
     * const dailyAssignmentAssistants = await prisma.dailyAssignmentAssistant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyAssignmentAssistantWithIdOnly = await prisma.dailyAssignmentAssistant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyAssignmentAssistantFindManyArgs>(args?: SelectSubset<T, DailyAssignmentAssistantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyAssignmentAssistant.
     * @param {DailyAssignmentAssistantCreateArgs} args - Arguments to create a DailyAssignmentAssistant.
     * @example
     * // Create one DailyAssignmentAssistant
     * const DailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.create({
     *   data: {
     *     // ... data to create a DailyAssignmentAssistant
     *   }
     * })
     * 
     */
    create<T extends DailyAssignmentAssistantCreateArgs>(args: SelectSubset<T, DailyAssignmentAssistantCreateArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyAssignmentAssistants.
     * @param {DailyAssignmentAssistantCreateManyArgs} args - Arguments to create many DailyAssignmentAssistants.
     * @example
     * // Create many DailyAssignmentAssistants
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyAssignmentAssistantCreateManyArgs>(args?: SelectSubset<T, DailyAssignmentAssistantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyAssignmentAssistants and returns the data saved in the database.
     * @param {DailyAssignmentAssistantCreateManyAndReturnArgs} args - Arguments to create many DailyAssignmentAssistants.
     * @example
     * // Create many DailyAssignmentAssistants
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyAssignmentAssistants and only return the `id`
     * const dailyAssignmentAssistantWithIdOnly = await prisma.dailyAssignmentAssistant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyAssignmentAssistantCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyAssignmentAssistantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyAssignmentAssistant.
     * @param {DailyAssignmentAssistantDeleteArgs} args - Arguments to delete one DailyAssignmentAssistant.
     * @example
     * // Delete one DailyAssignmentAssistant
     * const DailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.delete({
     *   where: {
     *     // ... filter to delete one DailyAssignmentAssistant
     *   }
     * })
     * 
     */
    delete<T extends DailyAssignmentAssistantDeleteArgs>(args: SelectSubset<T, DailyAssignmentAssistantDeleteArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyAssignmentAssistant.
     * @param {DailyAssignmentAssistantUpdateArgs} args - Arguments to update one DailyAssignmentAssistant.
     * @example
     * // Update one DailyAssignmentAssistant
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyAssignmentAssistantUpdateArgs>(args: SelectSubset<T, DailyAssignmentAssistantUpdateArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyAssignmentAssistants.
     * @param {DailyAssignmentAssistantDeleteManyArgs} args - Arguments to filter DailyAssignmentAssistants to delete.
     * @example
     * // Delete a few DailyAssignmentAssistants
     * const { count } = await prisma.dailyAssignmentAssistant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyAssignmentAssistantDeleteManyArgs>(args?: SelectSubset<T, DailyAssignmentAssistantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAssignmentAssistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyAssignmentAssistants
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyAssignmentAssistantUpdateManyArgs>(args: SelectSubset<T, DailyAssignmentAssistantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAssignmentAssistants and returns the data updated in the database.
     * @param {DailyAssignmentAssistantUpdateManyAndReturnArgs} args - Arguments to update many DailyAssignmentAssistants.
     * @example
     * // Update many DailyAssignmentAssistants
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyAssignmentAssistants and only return the `id`
     * const dailyAssignmentAssistantWithIdOnly = await prisma.dailyAssignmentAssistant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyAssignmentAssistantUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyAssignmentAssistantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyAssignmentAssistant.
     * @param {DailyAssignmentAssistantUpsertArgs} args - Arguments to update or create a DailyAssignmentAssistant.
     * @example
     * // Update or create a DailyAssignmentAssistant
     * const dailyAssignmentAssistant = await prisma.dailyAssignmentAssistant.upsert({
     *   create: {
     *     // ... data to create a DailyAssignmentAssistant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyAssignmentAssistant we want to update
     *   }
     * })
     */
    upsert<T extends DailyAssignmentAssistantUpsertArgs>(args: SelectSubset<T, DailyAssignmentAssistantUpsertArgs<ExtArgs>>): Prisma__DailyAssignmentAssistantClient<$Result.GetResult<Prisma.$DailyAssignmentAssistantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyAssignmentAssistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantCountArgs} args - Arguments to filter DailyAssignmentAssistants to count.
     * @example
     * // Count the number of DailyAssignmentAssistants
     * const count = await prisma.dailyAssignmentAssistant.count({
     *   where: {
     *     // ... the filter for the DailyAssignmentAssistants we want to count
     *   }
     * })
    **/
    count<T extends DailyAssignmentAssistantCountArgs>(
      args?: Subset<T, DailyAssignmentAssistantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyAssignmentAssistantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyAssignmentAssistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyAssignmentAssistantAggregateArgs>(args: Subset<T, DailyAssignmentAssistantAggregateArgs>): Prisma.PrismaPromise<GetDailyAssignmentAssistantAggregateType<T>>

    /**
     * Group by DailyAssignmentAssistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentAssistantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyAssignmentAssistantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyAssignmentAssistantGroupByArgs['orderBy'] }
        : { orderBy?: DailyAssignmentAssistantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyAssignmentAssistantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyAssignmentAssistantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyAssignmentAssistant model
   */
  readonly fields: DailyAssignmentAssistantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyAssignmentAssistant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyAssignmentAssistantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailyAssignment<T extends DailyAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyAssignmentDefaultArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyAssignmentAssistant model
   */
  interface DailyAssignmentAssistantFieldRefs {
    readonly id: FieldRef<"DailyAssignmentAssistant", 'Int'>
    readonly dailyAssignmentId: FieldRef<"DailyAssignmentAssistant", 'Int'>
    readonly employeeId: FieldRef<"DailyAssignmentAssistant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DailyAssignmentAssistant findUnique
   */
  export type DailyAssignmentAssistantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentAssistant to fetch.
     */
    where: DailyAssignmentAssistantWhereUniqueInput
  }

  /**
   * DailyAssignmentAssistant findUniqueOrThrow
   */
  export type DailyAssignmentAssistantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentAssistant to fetch.
     */
    where: DailyAssignmentAssistantWhereUniqueInput
  }

  /**
   * DailyAssignmentAssistant findFirst
   */
  export type DailyAssignmentAssistantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentAssistant to fetch.
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentAssistants to fetch.
     */
    orderBy?: DailyAssignmentAssistantOrderByWithRelationInput | DailyAssignmentAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAssignmentAssistants.
     */
    cursor?: DailyAssignmentAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAssignmentAssistants.
     */
    distinct?: DailyAssignmentAssistantScalarFieldEnum | DailyAssignmentAssistantScalarFieldEnum[]
  }

  /**
   * DailyAssignmentAssistant findFirstOrThrow
   */
  export type DailyAssignmentAssistantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentAssistant to fetch.
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentAssistants to fetch.
     */
    orderBy?: DailyAssignmentAssistantOrderByWithRelationInput | DailyAssignmentAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAssignmentAssistants.
     */
    cursor?: DailyAssignmentAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAssignmentAssistants.
     */
    distinct?: DailyAssignmentAssistantScalarFieldEnum | DailyAssignmentAssistantScalarFieldEnum[]
  }

  /**
   * DailyAssignmentAssistant findMany
   */
  export type DailyAssignmentAssistantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentAssistants to fetch.
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentAssistants to fetch.
     */
    orderBy?: DailyAssignmentAssistantOrderByWithRelationInput | DailyAssignmentAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyAssignmentAssistants.
     */
    cursor?: DailyAssignmentAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentAssistants.
     */
    skip?: number
    distinct?: DailyAssignmentAssistantScalarFieldEnum | DailyAssignmentAssistantScalarFieldEnum[]
  }

  /**
   * DailyAssignmentAssistant create
   */
  export type DailyAssignmentAssistantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyAssignmentAssistant.
     */
    data: XOR<DailyAssignmentAssistantCreateInput, DailyAssignmentAssistantUncheckedCreateInput>
  }

  /**
   * DailyAssignmentAssistant createMany
   */
  export type DailyAssignmentAssistantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyAssignmentAssistants.
     */
    data: DailyAssignmentAssistantCreateManyInput | DailyAssignmentAssistantCreateManyInput[]
  }

  /**
   * DailyAssignmentAssistant createManyAndReturn
   */
  export type DailyAssignmentAssistantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * The data used to create many DailyAssignmentAssistants.
     */
    data: DailyAssignmentAssistantCreateManyInput | DailyAssignmentAssistantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyAssignmentAssistant update
   */
  export type DailyAssignmentAssistantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyAssignmentAssistant.
     */
    data: XOR<DailyAssignmentAssistantUpdateInput, DailyAssignmentAssistantUncheckedUpdateInput>
    /**
     * Choose, which DailyAssignmentAssistant to update.
     */
    where: DailyAssignmentAssistantWhereUniqueInput
  }

  /**
   * DailyAssignmentAssistant updateMany
   */
  export type DailyAssignmentAssistantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyAssignmentAssistants.
     */
    data: XOR<DailyAssignmentAssistantUpdateManyMutationInput, DailyAssignmentAssistantUncheckedUpdateManyInput>
    /**
     * Filter which DailyAssignmentAssistants to update
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * Limit how many DailyAssignmentAssistants to update.
     */
    limit?: number
  }

  /**
   * DailyAssignmentAssistant updateManyAndReturn
   */
  export type DailyAssignmentAssistantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * The data used to update DailyAssignmentAssistants.
     */
    data: XOR<DailyAssignmentAssistantUpdateManyMutationInput, DailyAssignmentAssistantUncheckedUpdateManyInput>
    /**
     * Filter which DailyAssignmentAssistants to update
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * Limit how many DailyAssignmentAssistants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyAssignmentAssistant upsert
   */
  export type DailyAssignmentAssistantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyAssignmentAssistant to update in case it exists.
     */
    where: DailyAssignmentAssistantWhereUniqueInput
    /**
     * In case the DailyAssignmentAssistant found by the `where` argument doesn't exist, create a new DailyAssignmentAssistant with this data.
     */
    create: XOR<DailyAssignmentAssistantCreateInput, DailyAssignmentAssistantUncheckedCreateInput>
    /**
     * In case the DailyAssignmentAssistant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyAssignmentAssistantUpdateInput, DailyAssignmentAssistantUncheckedUpdateInput>
  }

  /**
   * DailyAssignmentAssistant delete
   */
  export type DailyAssignmentAssistantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
    /**
     * Filter which DailyAssignmentAssistant to delete.
     */
    where: DailyAssignmentAssistantWhereUniqueInput
  }

  /**
   * DailyAssignmentAssistant deleteMany
   */
  export type DailyAssignmentAssistantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAssignmentAssistants to delete
     */
    where?: DailyAssignmentAssistantWhereInput
    /**
     * Limit how many DailyAssignmentAssistants to delete.
     */
    limit?: number
  }

  /**
   * DailyAssignmentAssistant without action
   */
  export type DailyAssignmentAssistantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentAssistant
     */
    select?: DailyAssignmentAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentAssistant
     */
    omit?: DailyAssignmentAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentAssistantInclude<ExtArgs> | null
  }


  /**
   * Model DailyAssignmentFraction
   */

  export type AggregateDailyAssignmentFraction = {
    _count: DailyAssignmentFractionCountAggregateOutputType | null
    _avg: DailyAssignmentFractionAvgAggregateOutputType | null
    _sum: DailyAssignmentFractionSumAggregateOutputType | null
    _min: DailyAssignmentFractionMinAggregateOutputType | null
    _max: DailyAssignmentFractionMaxAggregateOutputType | null
  }

  export type DailyAssignmentFractionAvgAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    fractionId: number | null
  }

  export type DailyAssignmentFractionSumAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    fractionId: number | null
  }

  export type DailyAssignmentFractionMinAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    fractionId: number | null
  }

  export type DailyAssignmentFractionMaxAggregateOutputType = {
    id: number | null
    dailyAssignmentId: number | null
    fractionId: number | null
  }

  export type DailyAssignmentFractionCountAggregateOutputType = {
    id: number
    dailyAssignmentId: number
    fractionId: number
    _all: number
  }


  export type DailyAssignmentFractionAvgAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    fractionId?: true
  }

  export type DailyAssignmentFractionSumAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    fractionId?: true
  }

  export type DailyAssignmentFractionMinAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    fractionId?: true
  }

  export type DailyAssignmentFractionMaxAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    fractionId?: true
  }

  export type DailyAssignmentFractionCountAggregateInputType = {
    id?: true
    dailyAssignmentId?: true
    fractionId?: true
    _all?: true
  }

  export type DailyAssignmentFractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAssignmentFraction to aggregate.
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentFractions to fetch.
     */
    orderBy?: DailyAssignmentFractionOrderByWithRelationInput | DailyAssignmentFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyAssignmentFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyAssignmentFractions
    **/
    _count?: true | DailyAssignmentFractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyAssignmentFractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyAssignmentFractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyAssignmentFractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyAssignmentFractionMaxAggregateInputType
  }

  export type GetDailyAssignmentFractionAggregateType<T extends DailyAssignmentFractionAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyAssignmentFraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyAssignmentFraction[P]>
      : GetScalarType<T[P], AggregateDailyAssignmentFraction[P]>
  }




  export type DailyAssignmentFractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyAssignmentFractionWhereInput
    orderBy?: DailyAssignmentFractionOrderByWithAggregationInput | DailyAssignmentFractionOrderByWithAggregationInput[]
    by: DailyAssignmentFractionScalarFieldEnum[] | DailyAssignmentFractionScalarFieldEnum
    having?: DailyAssignmentFractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyAssignmentFractionCountAggregateInputType | true
    _avg?: DailyAssignmentFractionAvgAggregateInputType
    _sum?: DailyAssignmentFractionSumAggregateInputType
    _min?: DailyAssignmentFractionMinAggregateInputType
    _max?: DailyAssignmentFractionMaxAggregateInputType
  }

  export type DailyAssignmentFractionGroupByOutputType = {
    id: number
    dailyAssignmentId: number
    fractionId: number
    _count: DailyAssignmentFractionCountAggregateOutputType | null
    _avg: DailyAssignmentFractionAvgAggregateOutputType | null
    _sum: DailyAssignmentFractionSumAggregateOutputType | null
    _min: DailyAssignmentFractionMinAggregateOutputType | null
    _max: DailyAssignmentFractionMaxAggregateOutputType | null
  }

  type GetDailyAssignmentFractionGroupByPayload<T extends DailyAssignmentFractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyAssignmentFractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyAssignmentFractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyAssignmentFractionGroupByOutputType[P]>
            : GetScalarType<T[P], DailyAssignmentFractionGroupByOutputType[P]>
        }
      >
    >


  export type DailyAssignmentFractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyAssignmentId?: boolean
    fractionId?: boolean
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignmentFraction"]>

  export type DailyAssignmentFractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyAssignmentId?: boolean
    fractionId?: boolean
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignmentFraction"]>

  export type DailyAssignmentFractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dailyAssignmentId?: boolean
    fractionId?: boolean
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyAssignmentFraction"]>

  export type DailyAssignmentFractionSelectScalar = {
    id?: boolean
    dailyAssignmentId?: boolean
    fractionId?: boolean
  }

  export type DailyAssignmentFractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dailyAssignmentId" | "fractionId", ExtArgs["result"]["dailyAssignmentFraction"]>
  export type DailyAssignmentFractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type DailyAssignmentFractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }
  export type DailyAssignmentFractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignment?: boolean | DailyAssignmentDefaultArgs<ExtArgs>
    fraction?: boolean | FractionDefaultArgs<ExtArgs>
  }

  export type $DailyAssignmentFractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyAssignmentFraction"
    objects: {
      dailyAssignment: Prisma.$DailyAssignmentPayload<ExtArgs>
      fraction: Prisma.$FractionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dailyAssignmentId: number
      fractionId: number
    }, ExtArgs["result"]["dailyAssignmentFraction"]>
    composites: {}
  }

  type DailyAssignmentFractionGetPayload<S extends boolean | null | undefined | DailyAssignmentFractionDefaultArgs> = $Result.GetResult<Prisma.$DailyAssignmentFractionPayload, S>

  type DailyAssignmentFractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyAssignmentFractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyAssignmentFractionCountAggregateInputType | true
    }

  export interface DailyAssignmentFractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyAssignmentFraction'], meta: { name: 'DailyAssignmentFraction' } }
    /**
     * Find zero or one DailyAssignmentFraction that matches the filter.
     * @param {DailyAssignmentFractionFindUniqueArgs} args - Arguments to find a DailyAssignmentFraction
     * @example
     * // Get one DailyAssignmentFraction
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyAssignmentFractionFindUniqueArgs>(args: SelectSubset<T, DailyAssignmentFractionFindUniqueArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyAssignmentFraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyAssignmentFractionFindUniqueOrThrowArgs} args - Arguments to find a DailyAssignmentFraction
     * @example
     * // Get one DailyAssignmentFraction
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyAssignmentFractionFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyAssignmentFractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyAssignmentFraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionFindFirstArgs} args - Arguments to find a DailyAssignmentFraction
     * @example
     * // Get one DailyAssignmentFraction
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyAssignmentFractionFindFirstArgs>(args?: SelectSubset<T, DailyAssignmentFractionFindFirstArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyAssignmentFraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionFindFirstOrThrowArgs} args - Arguments to find a DailyAssignmentFraction
     * @example
     * // Get one DailyAssignmentFraction
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyAssignmentFractionFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyAssignmentFractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyAssignmentFractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyAssignmentFractions
     * const dailyAssignmentFractions = await prisma.dailyAssignmentFraction.findMany()
     * 
     * // Get first 10 DailyAssignmentFractions
     * const dailyAssignmentFractions = await prisma.dailyAssignmentFraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyAssignmentFractionWithIdOnly = await prisma.dailyAssignmentFraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyAssignmentFractionFindManyArgs>(args?: SelectSubset<T, DailyAssignmentFractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyAssignmentFraction.
     * @param {DailyAssignmentFractionCreateArgs} args - Arguments to create a DailyAssignmentFraction.
     * @example
     * // Create one DailyAssignmentFraction
     * const DailyAssignmentFraction = await prisma.dailyAssignmentFraction.create({
     *   data: {
     *     // ... data to create a DailyAssignmentFraction
     *   }
     * })
     * 
     */
    create<T extends DailyAssignmentFractionCreateArgs>(args: SelectSubset<T, DailyAssignmentFractionCreateArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyAssignmentFractions.
     * @param {DailyAssignmentFractionCreateManyArgs} args - Arguments to create many DailyAssignmentFractions.
     * @example
     * // Create many DailyAssignmentFractions
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyAssignmentFractionCreateManyArgs>(args?: SelectSubset<T, DailyAssignmentFractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyAssignmentFractions and returns the data saved in the database.
     * @param {DailyAssignmentFractionCreateManyAndReturnArgs} args - Arguments to create many DailyAssignmentFractions.
     * @example
     * // Create many DailyAssignmentFractions
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyAssignmentFractions and only return the `id`
     * const dailyAssignmentFractionWithIdOnly = await prisma.dailyAssignmentFraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyAssignmentFractionCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyAssignmentFractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyAssignmentFraction.
     * @param {DailyAssignmentFractionDeleteArgs} args - Arguments to delete one DailyAssignmentFraction.
     * @example
     * // Delete one DailyAssignmentFraction
     * const DailyAssignmentFraction = await prisma.dailyAssignmentFraction.delete({
     *   where: {
     *     // ... filter to delete one DailyAssignmentFraction
     *   }
     * })
     * 
     */
    delete<T extends DailyAssignmentFractionDeleteArgs>(args: SelectSubset<T, DailyAssignmentFractionDeleteArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyAssignmentFraction.
     * @param {DailyAssignmentFractionUpdateArgs} args - Arguments to update one DailyAssignmentFraction.
     * @example
     * // Update one DailyAssignmentFraction
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyAssignmentFractionUpdateArgs>(args: SelectSubset<T, DailyAssignmentFractionUpdateArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyAssignmentFractions.
     * @param {DailyAssignmentFractionDeleteManyArgs} args - Arguments to filter DailyAssignmentFractions to delete.
     * @example
     * // Delete a few DailyAssignmentFractions
     * const { count } = await prisma.dailyAssignmentFraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyAssignmentFractionDeleteManyArgs>(args?: SelectSubset<T, DailyAssignmentFractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAssignmentFractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyAssignmentFractions
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyAssignmentFractionUpdateManyArgs>(args: SelectSubset<T, DailyAssignmentFractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyAssignmentFractions and returns the data updated in the database.
     * @param {DailyAssignmentFractionUpdateManyAndReturnArgs} args - Arguments to update many DailyAssignmentFractions.
     * @example
     * // Update many DailyAssignmentFractions
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyAssignmentFractions and only return the `id`
     * const dailyAssignmentFractionWithIdOnly = await prisma.dailyAssignmentFraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyAssignmentFractionUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyAssignmentFractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyAssignmentFraction.
     * @param {DailyAssignmentFractionUpsertArgs} args - Arguments to update or create a DailyAssignmentFraction.
     * @example
     * // Update or create a DailyAssignmentFraction
     * const dailyAssignmentFraction = await prisma.dailyAssignmentFraction.upsert({
     *   create: {
     *     // ... data to create a DailyAssignmentFraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyAssignmentFraction we want to update
     *   }
     * })
     */
    upsert<T extends DailyAssignmentFractionUpsertArgs>(args: SelectSubset<T, DailyAssignmentFractionUpsertArgs<ExtArgs>>): Prisma__DailyAssignmentFractionClient<$Result.GetResult<Prisma.$DailyAssignmentFractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyAssignmentFractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionCountArgs} args - Arguments to filter DailyAssignmentFractions to count.
     * @example
     * // Count the number of DailyAssignmentFractions
     * const count = await prisma.dailyAssignmentFraction.count({
     *   where: {
     *     // ... the filter for the DailyAssignmentFractions we want to count
     *   }
     * })
    **/
    count<T extends DailyAssignmentFractionCountArgs>(
      args?: Subset<T, DailyAssignmentFractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyAssignmentFractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyAssignmentFraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyAssignmentFractionAggregateArgs>(args: Subset<T, DailyAssignmentFractionAggregateArgs>): Prisma.PrismaPromise<GetDailyAssignmentFractionAggregateType<T>>

    /**
     * Group by DailyAssignmentFraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyAssignmentFractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyAssignmentFractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyAssignmentFractionGroupByArgs['orderBy'] }
        : { orderBy?: DailyAssignmentFractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyAssignmentFractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyAssignmentFractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyAssignmentFraction model
   */
  readonly fields: DailyAssignmentFractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyAssignmentFraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyAssignmentFractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailyAssignment<T extends DailyAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyAssignmentDefaultArgs<ExtArgs>>): Prisma__DailyAssignmentClient<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fraction<T extends FractionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FractionDefaultArgs<ExtArgs>>): Prisma__FractionClient<$Result.GetResult<Prisma.$FractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyAssignmentFraction model
   */
  interface DailyAssignmentFractionFieldRefs {
    readonly id: FieldRef<"DailyAssignmentFraction", 'Int'>
    readonly dailyAssignmentId: FieldRef<"DailyAssignmentFraction", 'Int'>
    readonly fractionId: FieldRef<"DailyAssignmentFraction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DailyAssignmentFraction findUnique
   */
  export type DailyAssignmentFractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentFraction to fetch.
     */
    where: DailyAssignmentFractionWhereUniqueInput
  }

  /**
   * DailyAssignmentFraction findUniqueOrThrow
   */
  export type DailyAssignmentFractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentFraction to fetch.
     */
    where: DailyAssignmentFractionWhereUniqueInput
  }

  /**
   * DailyAssignmentFraction findFirst
   */
  export type DailyAssignmentFractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentFraction to fetch.
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentFractions to fetch.
     */
    orderBy?: DailyAssignmentFractionOrderByWithRelationInput | DailyAssignmentFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAssignmentFractions.
     */
    cursor?: DailyAssignmentFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAssignmentFractions.
     */
    distinct?: DailyAssignmentFractionScalarFieldEnum | DailyAssignmentFractionScalarFieldEnum[]
  }

  /**
   * DailyAssignmentFraction findFirstOrThrow
   */
  export type DailyAssignmentFractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentFraction to fetch.
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentFractions to fetch.
     */
    orderBy?: DailyAssignmentFractionOrderByWithRelationInput | DailyAssignmentFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyAssignmentFractions.
     */
    cursor?: DailyAssignmentFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentFractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyAssignmentFractions.
     */
    distinct?: DailyAssignmentFractionScalarFieldEnum | DailyAssignmentFractionScalarFieldEnum[]
  }

  /**
   * DailyAssignmentFraction findMany
   */
  export type DailyAssignmentFractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * Filter, which DailyAssignmentFractions to fetch.
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyAssignmentFractions to fetch.
     */
    orderBy?: DailyAssignmentFractionOrderByWithRelationInput | DailyAssignmentFractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyAssignmentFractions.
     */
    cursor?: DailyAssignmentFractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyAssignmentFractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyAssignmentFractions.
     */
    skip?: number
    distinct?: DailyAssignmentFractionScalarFieldEnum | DailyAssignmentFractionScalarFieldEnum[]
  }

  /**
   * DailyAssignmentFraction create
   */
  export type DailyAssignmentFractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyAssignmentFraction.
     */
    data: XOR<DailyAssignmentFractionCreateInput, DailyAssignmentFractionUncheckedCreateInput>
  }

  /**
   * DailyAssignmentFraction createMany
   */
  export type DailyAssignmentFractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyAssignmentFractions.
     */
    data: DailyAssignmentFractionCreateManyInput | DailyAssignmentFractionCreateManyInput[]
  }

  /**
   * DailyAssignmentFraction createManyAndReturn
   */
  export type DailyAssignmentFractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * The data used to create many DailyAssignmentFractions.
     */
    data: DailyAssignmentFractionCreateManyInput | DailyAssignmentFractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyAssignmentFraction update
   */
  export type DailyAssignmentFractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyAssignmentFraction.
     */
    data: XOR<DailyAssignmentFractionUpdateInput, DailyAssignmentFractionUncheckedUpdateInput>
    /**
     * Choose, which DailyAssignmentFraction to update.
     */
    where: DailyAssignmentFractionWhereUniqueInput
  }

  /**
   * DailyAssignmentFraction updateMany
   */
  export type DailyAssignmentFractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyAssignmentFractions.
     */
    data: XOR<DailyAssignmentFractionUpdateManyMutationInput, DailyAssignmentFractionUncheckedUpdateManyInput>
    /**
     * Filter which DailyAssignmentFractions to update
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * Limit how many DailyAssignmentFractions to update.
     */
    limit?: number
  }

  /**
   * DailyAssignmentFraction updateManyAndReturn
   */
  export type DailyAssignmentFractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * The data used to update DailyAssignmentFractions.
     */
    data: XOR<DailyAssignmentFractionUpdateManyMutationInput, DailyAssignmentFractionUncheckedUpdateManyInput>
    /**
     * Filter which DailyAssignmentFractions to update
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * Limit how many DailyAssignmentFractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyAssignmentFraction upsert
   */
  export type DailyAssignmentFractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyAssignmentFraction to update in case it exists.
     */
    where: DailyAssignmentFractionWhereUniqueInput
    /**
     * In case the DailyAssignmentFraction found by the `where` argument doesn't exist, create a new DailyAssignmentFraction with this data.
     */
    create: XOR<DailyAssignmentFractionCreateInput, DailyAssignmentFractionUncheckedCreateInput>
    /**
     * In case the DailyAssignmentFraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyAssignmentFractionUpdateInput, DailyAssignmentFractionUncheckedUpdateInput>
  }

  /**
   * DailyAssignmentFraction delete
   */
  export type DailyAssignmentFractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
    /**
     * Filter which DailyAssignmentFraction to delete.
     */
    where: DailyAssignmentFractionWhereUniqueInput
  }

  /**
   * DailyAssignmentFraction deleteMany
   */
  export type DailyAssignmentFractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyAssignmentFractions to delete
     */
    where?: DailyAssignmentFractionWhereInput
    /**
     * Limit how many DailyAssignmentFractions to delete.
     */
    limit?: number
  }

  /**
   * DailyAssignmentFraction without action
   */
  export type DailyAssignmentFractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignmentFraction
     */
    select?: DailyAssignmentFractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignmentFraction
     */
    omit?: DailyAssignmentFractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentFractionInclude<ExtArgs> | null
  }


  /**
   * Model VehicleFaultReport
   */

  export type AggregateVehicleFaultReport = {
    _count: VehicleFaultReportCountAggregateOutputType | null
    _avg: VehicleFaultReportAvgAggregateOutputType | null
    _sum: VehicleFaultReportSumAggregateOutputType | null
    _min: VehicleFaultReportMinAggregateOutputType | null
    _max: VehicleFaultReportMaxAggregateOutputType | null
  }

  export type VehicleFaultReportAvgAggregateOutputType = {
    id: number | null
    vehicleId: number | null
  }

  export type VehicleFaultReportSumAggregateOutputType = {
    id: number | null
    vehicleId: number | null
  }

  export type VehicleFaultReportMinAggregateOutputType = {
    id: number | null
    vehicleId: number | null
    reportedBy: string | null
    description: string | null
    reportedAt: Date | null
    resolvedAt: Date | null
    isResolved: boolean | null
  }

  export type VehicleFaultReportMaxAggregateOutputType = {
    id: number | null
    vehicleId: number | null
    reportedBy: string | null
    description: string | null
    reportedAt: Date | null
    resolvedAt: Date | null
    isResolved: boolean | null
  }

  export type VehicleFaultReportCountAggregateOutputType = {
    id: number
    vehicleId: number
    reportedBy: number
    description: number
    reportedAt: number
    resolvedAt: number
    isResolved: number
    _all: number
  }


  export type VehicleFaultReportAvgAggregateInputType = {
    id?: true
    vehicleId?: true
  }

  export type VehicleFaultReportSumAggregateInputType = {
    id?: true
    vehicleId?: true
  }

  export type VehicleFaultReportMinAggregateInputType = {
    id?: true
    vehicleId?: true
    reportedBy?: true
    description?: true
    reportedAt?: true
    resolvedAt?: true
    isResolved?: true
  }

  export type VehicleFaultReportMaxAggregateInputType = {
    id?: true
    vehicleId?: true
    reportedBy?: true
    description?: true
    reportedAt?: true
    resolvedAt?: true
    isResolved?: true
  }

  export type VehicleFaultReportCountAggregateInputType = {
    id?: true
    vehicleId?: true
    reportedBy?: true
    description?: true
    reportedAt?: true
    resolvedAt?: true
    isResolved?: true
    _all?: true
  }

  export type VehicleFaultReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleFaultReport to aggregate.
     */
    where?: VehicleFaultReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleFaultReports to fetch.
     */
    orderBy?: VehicleFaultReportOrderByWithRelationInput | VehicleFaultReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleFaultReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleFaultReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleFaultReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleFaultReports
    **/
    _count?: true | VehicleFaultReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleFaultReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleFaultReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleFaultReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleFaultReportMaxAggregateInputType
  }

  export type GetVehicleFaultReportAggregateType<T extends VehicleFaultReportAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleFaultReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleFaultReport[P]>
      : GetScalarType<T[P], AggregateVehicleFaultReport[P]>
  }




  export type VehicleFaultReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleFaultReportWhereInput
    orderBy?: VehicleFaultReportOrderByWithAggregationInput | VehicleFaultReportOrderByWithAggregationInput[]
    by: VehicleFaultReportScalarFieldEnum[] | VehicleFaultReportScalarFieldEnum
    having?: VehicleFaultReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleFaultReportCountAggregateInputType | true
    _avg?: VehicleFaultReportAvgAggregateInputType
    _sum?: VehicleFaultReportSumAggregateInputType
    _min?: VehicleFaultReportMinAggregateInputType
    _max?: VehicleFaultReportMaxAggregateInputType
  }

  export type VehicleFaultReportGroupByOutputType = {
    id: number
    vehicleId: number
    reportedBy: string
    description: string | null
    reportedAt: Date
    resolvedAt: Date | null
    isResolved: boolean
    _count: VehicleFaultReportCountAggregateOutputType | null
    _avg: VehicleFaultReportAvgAggregateOutputType | null
    _sum: VehicleFaultReportSumAggregateOutputType | null
    _min: VehicleFaultReportMinAggregateOutputType | null
    _max: VehicleFaultReportMaxAggregateOutputType | null
  }

  type GetVehicleFaultReportGroupByPayload<T extends VehicleFaultReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleFaultReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleFaultReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleFaultReportGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleFaultReportGroupByOutputType[P]>
        }
      >
    >


  export type VehicleFaultReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleId?: boolean
    reportedBy?: boolean
    description?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    isResolved?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleFaultReport"]>

  export type VehicleFaultReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleId?: boolean
    reportedBy?: boolean
    description?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    isResolved?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleFaultReport"]>

  export type VehicleFaultReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleId?: boolean
    reportedBy?: boolean
    description?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    isResolved?: boolean
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleFaultReport"]>

  export type VehicleFaultReportSelectScalar = {
    id?: boolean
    vehicleId?: boolean
    reportedBy?: boolean
    description?: boolean
    reportedAt?: boolean
    resolvedAt?: boolean
    isResolved?: boolean
  }

  export type VehicleFaultReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicleId" | "reportedBy" | "description" | "reportedAt" | "resolvedAt" | "isResolved", ExtArgs["result"]["vehicleFaultReport"]>
  export type VehicleFaultReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type VehicleFaultReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type VehicleFaultReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $VehicleFaultReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleFaultReport"
    objects: {
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vehicleId: number
      reportedBy: string
      description: string | null
      reportedAt: Date
      resolvedAt: Date | null
      isResolved: boolean
    }, ExtArgs["result"]["vehicleFaultReport"]>
    composites: {}
  }

  type VehicleFaultReportGetPayload<S extends boolean | null | undefined | VehicleFaultReportDefaultArgs> = $Result.GetResult<Prisma.$VehicleFaultReportPayload, S>

  type VehicleFaultReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFaultReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleFaultReportCountAggregateInputType | true
    }

  export interface VehicleFaultReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleFaultReport'], meta: { name: 'VehicleFaultReport' } }
    /**
     * Find zero or one VehicleFaultReport that matches the filter.
     * @param {VehicleFaultReportFindUniqueArgs} args - Arguments to find a VehicleFaultReport
     * @example
     * // Get one VehicleFaultReport
     * const vehicleFaultReport = await prisma.vehicleFaultReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFaultReportFindUniqueArgs>(args: SelectSubset<T, VehicleFaultReportFindUniqueArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleFaultReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFaultReportFindUniqueOrThrowArgs} args - Arguments to find a VehicleFaultReport
     * @example
     * // Get one VehicleFaultReport
     * const vehicleFaultReport = await prisma.vehicleFaultReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFaultReportFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFaultReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleFaultReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportFindFirstArgs} args - Arguments to find a VehicleFaultReport
     * @example
     * // Get one VehicleFaultReport
     * const vehicleFaultReport = await prisma.vehicleFaultReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFaultReportFindFirstArgs>(args?: SelectSubset<T, VehicleFaultReportFindFirstArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleFaultReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportFindFirstOrThrowArgs} args - Arguments to find a VehicleFaultReport
     * @example
     * // Get one VehicleFaultReport
     * const vehicleFaultReport = await prisma.vehicleFaultReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFaultReportFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFaultReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleFaultReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleFaultReports
     * const vehicleFaultReports = await prisma.vehicleFaultReport.findMany()
     * 
     * // Get first 10 VehicleFaultReports
     * const vehicleFaultReports = await prisma.vehicleFaultReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleFaultReportWithIdOnly = await prisma.vehicleFaultReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFaultReportFindManyArgs>(args?: SelectSubset<T, VehicleFaultReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleFaultReport.
     * @param {VehicleFaultReportCreateArgs} args - Arguments to create a VehicleFaultReport.
     * @example
     * // Create one VehicleFaultReport
     * const VehicleFaultReport = await prisma.vehicleFaultReport.create({
     *   data: {
     *     // ... data to create a VehicleFaultReport
     *   }
     * })
     * 
     */
    create<T extends VehicleFaultReportCreateArgs>(args: SelectSubset<T, VehicleFaultReportCreateArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleFaultReports.
     * @param {VehicleFaultReportCreateManyArgs} args - Arguments to create many VehicleFaultReports.
     * @example
     * // Create many VehicleFaultReports
     * const vehicleFaultReport = await prisma.vehicleFaultReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleFaultReportCreateManyArgs>(args?: SelectSubset<T, VehicleFaultReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleFaultReports and returns the data saved in the database.
     * @param {VehicleFaultReportCreateManyAndReturnArgs} args - Arguments to create many VehicleFaultReports.
     * @example
     * // Create many VehicleFaultReports
     * const vehicleFaultReport = await prisma.vehicleFaultReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleFaultReports and only return the `id`
     * const vehicleFaultReportWithIdOnly = await prisma.vehicleFaultReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleFaultReportCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleFaultReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleFaultReport.
     * @param {VehicleFaultReportDeleteArgs} args - Arguments to delete one VehicleFaultReport.
     * @example
     * // Delete one VehicleFaultReport
     * const VehicleFaultReport = await prisma.vehicleFaultReport.delete({
     *   where: {
     *     // ... filter to delete one VehicleFaultReport
     *   }
     * })
     * 
     */
    delete<T extends VehicleFaultReportDeleteArgs>(args: SelectSubset<T, VehicleFaultReportDeleteArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleFaultReport.
     * @param {VehicleFaultReportUpdateArgs} args - Arguments to update one VehicleFaultReport.
     * @example
     * // Update one VehicleFaultReport
     * const vehicleFaultReport = await prisma.vehicleFaultReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleFaultReportUpdateArgs>(args: SelectSubset<T, VehicleFaultReportUpdateArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleFaultReports.
     * @param {VehicleFaultReportDeleteManyArgs} args - Arguments to filter VehicleFaultReports to delete.
     * @example
     * // Delete a few VehicleFaultReports
     * const { count } = await prisma.vehicleFaultReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleFaultReportDeleteManyArgs>(args?: SelectSubset<T, VehicleFaultReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleFaultReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleFaultReports
     * const vehicleFaultReport = await prisma.vehicleFaultReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleFaultReportUpdateManyArgs>(args: SelectSubset<T, VehicleFaultReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleFaultReports and returns the data updated in the database.
     * @param {VehicleFaultReportUpdateManyAndReturnArgs} args - Arguments to update many VehicleFaultReports.
     * @example
     * // Update many VehicleFaultReports
     * const vehicleFaultReport = await prisma.vehicleFaultReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleFaultReports and only return the `id`
     * const vehicleFaultReportWithIdOnly = await prisma.vehicleFaultReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleFaultReportUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleFaultReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleFaultReport.
     * @param {VehicleFaultReportUpsertArgs} args - Arguments to update or create a VehicleFaultReport.
     * @example
     * // Update or create a VehicleFaultReport
     * const vehicleFaultReport = await prisma.vehicleFaultReport.upsert({
     *   create: {
     *     // ... data to create a VehicleFaultReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleFaultReport we want to update
     *   }
     * })
     */
    upsert<T extends VehicleFaultReportUpsertArgs>(args: SelectSubset<T, VehicleFaultReportUpsertArgs<ExtArgs>>): Prisma__VehicleFaultReportClient<$Result.GetResult<Prisma.$VehicleFaultReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleFaultReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportCountArgs} args - Arguments to filter VehicleFaultReports to count.
     * @example
     * // Count the number of VehicleFaultReports
     * const count = await prisma.vehicleFaultReport.count({
     *   where: {
     *     // ... the filter for the VehicleFaultReports we want to count
     *   }
     * })
    **/
    count<T extends VehicleFaultReportCountArgs>(
      args?: Subset<T, VehicleFaultReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleFaultReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleFaultReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleFaultReportAggregateArgs>(args: Subset<T, VehicleFaultReportAggregateArgs>): Prisma.PrismaPromise<GetVehicleFaultReportAggregateType<T>>

    /**
     * Group by VehicleFaultReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFaultReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleFaultReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleFaultReportGroupByArgs['orderBy'] }
        : { orderBy?: VehicleFaultReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleFaultReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleFaultReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleFaultReport model
   */
  readonly fields: VehicleFaultReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleFaultReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleFaultReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleFaultReport model
   */
  interface VehicleFaultReportFieldRefs {
    readonly id: FieldRef<"VehicleFaultReport", 'Int'>
    readonly vehicleId: FieldRef<"VehicleFaultReport", 'Int'>
    readonly reportedBy: FieldRef<"VehicleFaultReport", 'String'>
    readonly description: FieldRef<"VehicleFaultReport", 'String'>
    readonly reportedAt: FieldRef<"VehicleFaultReport", 'DateTime'>
    readonly resolvedAt: FieldRef<"VehicleFaultReport", 'DateTime'>
    readonly isResolved: FieldRef<"VehicleFaultReport", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * VehicleFaultReport findUnique
   */
  export type VehicleFaultReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * Filter, which VehicleFaultReport to fetch.
     */
    where: VehicleFaultReportWhereUniqueInput
  }

  /**
   * VehicleFaultReport findUniqueOrThrow
   */
  export type VehicleFaultReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * Filter, which VehicleFaultReport to fetch.
     */
    where: VehicleFaultReportWhereUniqueInput
  }

  /**
   * VehicleFaultReport findFirst
   */
  export type VehicleFaultReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * Filter, which VehicleFaultReport to fetch.
     */
    where?: VehicleFaultReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleFaultReports to fetch.
     */
    orderBy?: VehicleFaultReportOrderByWithRelationInput | VehicleFaultReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleFaultReports.
     */
    cursor?: VehicleFaultReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleFaultReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleFaultReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleFaultReports.
     */
    distinct?: VehicleFaultReportScalarFieldEnum | VehicleFaultReportScalarFieldEnum[]
  }

  /**
   * VehicleFaultReport findFirstOrThrow
   */
  export type VehicleFaultReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * Filter, which VehicleFaultReport to fetch.
     */
    where?: VehicleFaultReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleFaultReports to fetch.
     */
    orderBy?: VehicleFaultReportOrderByWithRelationInput | VehicleFaultReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleFaultReports.
     */
    cursor?: VehicleFaultReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleFaultReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleFaultReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleFaultReports.
     */
    distinct?: VehicleFaultReportScalarFieldEnum | VehicleFaultReportScalarFieldEnum[]
  }

  /**
   * VehicleFaultReport findMany
   */
  export type VehicleFaultReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * Filter, which VehicleFaultReports to fetch.
     */
    where?: VehicleFaultReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleFaultReports to fetch.
     */
    orderBy?: VehicleFaultReportOrderByWithRelationInput | VehicleFaultReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleFaultReports.
     */
    cursor?: VehicleFaultReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleFaultReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleFaultReports.
     */
    skip?: number
    distinct?: VehicleFaultReportScalarFieldEnum | VehicleFaultReportScalarFieldEnum[]
  }

  /**
   * VehicleFaultReport create
   */
  export type VehicleFaultReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleFaultReport.
     */
    data: XOR<VehicleFaultReportCreateInput, VehicleFaultReportUncheckedCreateInput>
  }

  /**
   * VehicleFaultReport createMany
   */
  export type VehicleFaultReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleFaultReports.
     */
    data: VehicleFaultReportCreateManyInput | VehicleFaultReportCreateManyInput[]
  }

  /**
   * VehicleFaultReport createManyAndReturn
   */
  export type VehicleFaultReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleFaultReports.
     */
    data: VehicleFaultReportCreateManyInput | VehicleFaultReportCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleFaultReport update
   */
  export type VehicleFaultReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleFaultReport.
     */
    data: XOR<VehicleFaultReportUpdateInput, VehicleFaultReportUncheckedUpdateInput>
    /**
     * Choose, which VehicleFaultReport to update.
     */
    where: VehicleFaultReportWhereUniqueInput
  }

  /**
   * VehicleFaultReport updateMany
   */
  export type VehicleFaultReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleFaultReports.
     */
    data: XOR<VehicleFaultReportUpdateManyMutationInput, VehicleFaultReportUncheckedUpdateManyInput>
    /**
     * Filter which VehicleFaultReports to update
     */
    where?: VehicleFaultReportWhereInput
    /**
     * Limit how many VehicleFaultReports to update.
     */
    limit?: number
  }

  /**
   * VehicleFaultReport updateManyAndReturn
   */
  export type VehicleFaultReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * The data used to update VehicleFaultReports.
     */
    data: XOR<VehicleFaultReportUpdateManyMutationInput, VehicleFaultReportUncheckedUpdateManyInput>
    /**
     * Filter which VehicleFaultReports to update
     */
    where?: VehicleFaultReportWhereInput
    /**
     * Limit how many VehicleFaultReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleFaultReport upsert
   */
  export type VehicleFaultReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleFaultReport to update in case it exists.
     */
    where: VehicleFaultReportWhereUniqueInput
    /**
     * In case the VehicleFaultReport found by the `where` argument doesn't exist, create a new VehicleFaultReport with this data.
     */
    create: XOR<VehicleFaultReportCreateInput, VehicleFaultReportUncheckedCreateInput>
    /**
     * In case the VehicleFaultReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleFaultReportUpdateInput, VehicleFaultReportUncheckedUpdateInput>
  }

  /**
   * VehicleFaultReport delete
   */
  export type VehicleFaultReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
    /**
     * Filter which VehicleFaultReport to delete.
     */
    where: VehicleFaultReportWhereUniqueInput
  }

  /**
   * VehicleFaultReport deleteMany
   */
  export type VehicleFaultReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleFaultReports to delete
     */
    where?: VehicleFaultReportWhereInput
    /**
     * Limit how many VehicleFaultReports to delete.
     */
    limit?: number
  }

  /**
   * VehicleFaultReport without action
   */
  export type VehicleFaultReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleFaultReport
     */
    select?: VehicleFaultReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleFaultReport
     */
    omit?: VehicleFaultReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleFaultReportInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrder
   */

  export type AggregateWorkOrder = {
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  export type WorkOrderAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type WorkOrderSumAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type WorkOrderMinAggregateOutputType = {
    id: number | null
    type: string | null
    dateReceived: Date | null
    realizationDate: Date | null
    quantity: number | null
    orderNumber: string | null
    bagNumber: string | null
    executionDate: Date | null
    receivedBy: string | null
    address: string | null
    municipality: string | null
    company: string | null
    wasteType: string | null
    rodzaj: string | null
    kontener: string | null
    description: string | null
    notes: string | null
    failureReason: string | null
    vehicle: string | null
    responsible: string | null
    completed: boolean | null
    zlecenie: string | null
  }

  export type WorkOrderMaxAggregateOutputType = {
    id: number | null
    type: string | null
    dateReceived: Date | null
    realizationDate: Date | null
    quantity: number | null
    orderNumber: string | null
    bagNumber: string | null
    executionDate: Date | null
    receivedBy: string | null
    address: string | null
    municipality: string | null
    company: string | null
    wasteType: string | null
    rodzaj: string | null
    kontener: string | null
    description: string | null
    notes: string | null
    failureReason: string | null
    vehicle: string | null
    responsible: string | null
    completed: boolean | null
    zlecenie: string | null
  }

  export type WorkOrderCountAggregateOutputType = {
    id: number
    type: number
    dateReceived: number
    realizationDate: number
    quantity: number
    orderNumber: number
    bagNumber: number
    executionDate: number
    receivedBy: number
    address: number
    municipality: number
    company: number
    wasteType: number
    rodzaj: number
    kontener: number
    description: number
    notes: number
    failureReason: number
    vehicle: number
    responsible: number
    completed: number
    zlecenie: number
    _all: number
  }


  export type WorkOrderAvgAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type WorkOrderSumAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type WorkOrderMinAggregateInputType = {
    id?: true
    type?: true
    dateReceived?: true
    realizationDate?: true
    quantity?: true
    orderNumber?: true
    bagNumber?: true
    executionDate?: true
    receivedBy?: true
    address?: true
    municipality?: true
    company?: true
    wasteType?: true
    rodzaj?: true
    kontener?: true
    description?: true
    notes?: true
    failureReason?: true
    vehicle?: true
    responsible?: true
    completed?: true
    zlecenie?: true
  }

  export type WorkOrderMaxAggregateInputType = {
    id?: true
    type?: true
    dateReceived?: true
    realizationDate?: true
    quantity?: true
    orderNumber?: true
    bagNumber?: true
    executionDate?: true
    receivedBy?: true
    address?: true
    municipality?: true
    company?: true
    wasteType?: true
    rodzaj?: true
    kontener?: true
    description?: true
    notes?: true
    failureReason?: true
    vehicle?: true
    responsible?: true
    completed?: true
    zlecenie?: true
  }

  export type WorkOrderCountAggregateInputType = {
    id?: true
    type?: true
    dateReceived?: true
    realizationDate?: true
    quantity?: true
    orderNumber?: true
    bagNumber?: true
    executionDate?: true
    receivedBy?: true
    address?: true
    municipality?: true
    company?: true
    wasteType?: true
    rodzaj?: true
    kontener?: true
    description?: true
    notes?: true
    failureReason?: true
    vehicle?: true
    responsible?: true
    completed?: true
    zlecenie?: true
    _all?: true
  }

  export type WorkOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrder to aggregate.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrders
    **/
    _count?: true | WorkOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderMaxAggregateInputType
  }

  export type GetWorkOrderAggregateType<T extends WorkOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrder[P]>
      : GetScalarType<T[P], AggregateWorkOrder[P]>
  }




  export type WorkOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithAggregationInput | WorkOrderOrderByWithAggregationInput[]
    by: WorkOrderScalarFieldEnum[] | WorkOrderScalarFieldEnum
    having?: WorkOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderCountAggregateInputType | true
    _avg?: WorkOrderAvgAggregateInputType
    _sum?: WorkOrderSumAggregateInputType
    _min?: WorkOrderMinAggregateInputType
    _max?: WorkOrderMaxAggregateInputType
  }

  export type WorkOrderGroupByOutputType = {
    id: number
    type: string
    dateReceived: Date
    realizationDate: Date | null
    quantity: number | null
    orderNumber: string | null
    bagNumber: string | null
    executionDate: Date
    receivedBy: string
    address: string
    municipality: string | null
    company: string | null
    wasteType: string | null
    rodzaj: string | null
    kontener: string | null
    description: string | null
    notes: string | null
    failureReason: string | null
    vehicle: string | null
    responsible: string | null
    completed: boolean
    zlecenie: string | null
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  type GetWorkOrderGroupByPayload<T extends WorkOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    dateReceived?: boolean
    realizationDate?: boolean
    quantity?: boolean
    orderNumber?: boolean
    bagNumber?: boolean
    executionDate?: boolean
    receivedBy?: boolean
    address?: boolean
    municipality?: boolean
    company?: boolean
    wasteType?: boolean
    rodzaj?: boolean
    kontener?: boolean
    description?: boolean
    notes?: boolean
    failureReason?: boolean
    vehicle?: boolean
    responsible?: boolean
    completed?: boolean
    zlecenie?: boolean
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    dateReceived?: boolean
    realizationDate?: boolean
    quantity?: boolean
    orderNumber?: boolean
    bagNumber?: boolean
    executionDate?: boolean
    receivedBy?: boolean
    address?: boolean
    municipality?: boolean
    company?: boolean
    wasteType?: boolean
    rodzaj?: boolean
    kontener?: boolean
    description?: boolean
    notes?: boolean
    failureReason?: boolean
    vehicle?: boolean
    responsible?: boolean
    completed?: boolean
    zlecenie?: boolean
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    dateReceived?: boolean
    realizationDate?: boolean
    quantity?: boolean
    orderNumber?: boolean
    bagNumber?: boolean
    executionDate?: boolean
    receivedBy?: boolean
    address?: boolean
    municipality?: boolean
    company?: boolean
    wasteType?: boolean
    rodzaj?: boolean
    kontener?: boolean
    description?: boolean
    notes?: boolean
    failureReason?: boolean
    vehicle?: boolean
    responsible?: boolean
    completed?: boolean
    zlecenie?: boolean
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectScalar = {
    id?: boolean
    type?: boolean
    dateReceived?: boolean
    realizationDate?: boolean
    quantity?: boolean
    orderNumber?: boolean
    bagNumber?: boolean
    executionDate?: boolean
    receivedBy?: boolean
    address?: boolean
    municipality?: boolean
    company?: boolean
    wasteType?: boolean
    rodzaj?: boolean
    kontener?: boolean
    description?: boolean
    notes?: boolean
    failureReason?: boolean
    vehicle?: boolean
    responsible?: boolean
    completed?: boolean
    zlecenie?: boolean
  }

  export type WorkOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "dateReceived" | "realizationDate" | "quantity" | "orderNumber" | "bagNumber" | "executionDate" | "receivedBy" | "address" | "municipality" | "company" | "wasteType" | "rodzaj" | "kontener" | "description" | "notes" | "failureReason" | "vehicle" | "responsible" | "completed" | "zlecenie", ExtArgs["result"]["workOrder"]>

  export type $WorkOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      dateReceived: Date
      realizationDate: Date | null
      quantity: number | null
      orderNumber: string | null
      bagNumber: string | null
      executionDate: Date
      receivedBy: string
      address: string
      municipality: string | null
      company: string | null
      wasteType: string | null
      rodzaj: string | null
      kontener: string | null
      description: string | null
      notes: string | null
      failureReason: string | null
      vehicle: string | null
      responsible: string | null
      completed: boolean
      zlecenie: string | null
    }, ExtArgs["result"]["workOrder"]>
    composites: {}
  }

  type WorkOrderGetPayload<S extends boolean | null | undefined | WorkOrderDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderPayload, S>

  type WorkOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkOrderCountAggregateInputType | true
    }

  export interface WorkOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrder'], meta: { name: 'WorkOrder' } }
    /**
     * Find zero or one WorkOrder that matches the filter.
     * @param {WorkOrderFindUniqueArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderFindUniqueArgs>(args: SelectSubset<T, WorkOrderFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkOrderFindUniqueOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderFindFirstArgs>(args?: SelectSubset<T, WorkOrderFindFirstArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrders
     * const workOrders = await prisma.workOrder.findMany()
     * 
     * // Get first 10 WorkOrders
     * const workOrders = await prisma.workOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderFindManyArgs>(args?: SelectSubset<T, WorkOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkOrder.
     * @param {WorkOrderCreateArgs} args - Arguments to create a WorkOrder.
     * @example
     * // Create one WorkOrder
     * const WorkOrder = await prisma.workOrder.create({
     *   data: {
     *     // ... data to create a WorkOrder
     *   }
     * })
     * 
     */
    create<T extends WorkOrderCreateArgs>(args: SelectSubset<T, WorkOrderCreateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkOrders.
     * @param {WorkOrderCreateManyArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderCreateManyArgs>(args?: SelectSubset<T, WorkOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrders and returns the data saved in the database.
     * @param {WorkOrderCreateManyAndReturnArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkOrder.
     * @param {WorkOrderDeleteArgs} args - Arguments to delete one WorkOrder.
     * @example
     * // Delete one WorkOrder
     * const WorkOrder = await prisma.workOrder.delete({
     *   where: {
     *     // ... filter to delete one WorkOrder
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderDeleteArgs>(args: SelectSubset<T, WorkOrderDeleteArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkOrder.
     * @param {WorkOrderUpdateArgs} args - Arguments to update one WorkOrder.
     * @example
     * // Update one WorkOrder
     * const workOrder = await prisma.workOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderUpdateArgs>(args: SelectSubset<T, WorkOrderUpdateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkOrders.
     * @param {WorkOrderDeleteManyArgs} args - Arguments to filter WorkOrders to delete.
     * @example
     * // Delete a few WorkOrders
     * const { count } = await prisma.workOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderDeleteManyArgs>(args?: SelectSubset<T, WorkOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderUpdateManyArgs>(args: SelectSubset<T, WorkOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders and returns the data updated in the database.
     * @param {WorkOrderUpdateManyAndReturnArgs} args - Arguments to update many WorkOrders.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkOrder.
     * @param {WorkOrderUpsertArgs} args - Arguments to update or create a WorkOrder.
     * @example
     * // Update or create a WorkOrder
     * const workOrder = await prisma.workOrder.upsert({
     *   create: {
     *     // ... data to create a WorkOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrder we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderUpsertArgs>(args: SelectSubset<T, WorkOrderUpsertArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderCountArgs} args - Arguments to filter WorkOrders to count.
     * @example
     * // Count the number of WorkOrders
     * const count = await prisma.workOrder.count({
     *   where: {
     *     // ... the filter for the WorkOrders we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderCountArgs>(
      args?: Subset<T, WorkOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderAggregateArgs>(args: Subset<T, WorkOrderAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderAggregateType<T>>

    /**
     * Group by WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrder model
   */
  readonly fields: WorkOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrder model
   */
  interface WorkOrderFieldRefs {
    readonly id: FieldRef<"WorkOrder", 'Int'>
    readonly type: FieldRef<"WorkOrder", 'String'>
    readonly dateReceived: FieldRef<"WorkOrder", 'DateTime'>
    readonly realizationDate: FieldRef<"WorkOrder", 'DateTime'>
    readonly quantity: FieldRef<"WorkOrder", 'Int'>
    readonly orderNumber: FieldRef<"WorkOrder", 'String'>
    readonly bagNumber: FieldRef<"WorkOrder", 'String'>
    readonly executionDate: FieldRef<"WorkOrder", 'DateTime'>
    readonly receivedBy: FieldRef<"WorkOrder", 'String'>
    readonly address: FieldRef<"WorkOrder", 'String'>
    readonly municipality: FieldRef<"WorkOrder", 'String'>
    readonly company: FieldRef<"WorkOrder", 'String'>
    readonly wasteType: FieldRef<"WorkOrder", 'String'>
    readonly rodzaj: FieldRef<"WorkOrder", 'String'>
    readonly kontener: FieldRef<"WorkOrder", 'String'>
    readonly description: FieldRef<"WorkOrder", 'String'>
    readonly notes: FieldRef<"WorkOrder", 'String'>
    readonly failureReason: FieldRef<"WorkOrder", 'String'>
    readonly vehicle: FieldRef<"WorkOrder", 'String'>
    readonly responsible: FieldRef<"WorkOrder", 'String'>
    readonly completed: FieldRef<"WorkOrder", 'Boolean'>
    readonly zlecenie: FieldRef<"WorkOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrder findUnique
   */
  export type WorkOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findUniqueOrThrow
   */
  export type WorkOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findFirst
   */
  export type WorkOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findFirstOrThrow
   */
  export type WorkOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findMany
   */
  export type WorkOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Filter, which WorkOrders to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder create
   */
  export type WorkOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data needed to create a WorkOrder.
     */
    data: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
  }

  /**
   * WorkOrder createMany
   */
  export type WorkOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
  }

  /**
   * WorkOrder createManyAndReturn
   */
  export type WorkOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
  }

  /**
   * WorkOrder update
   */
  export type WorkOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data needed to update a WorkOrder.
     */
    data: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
    /**
     * Choose, which WorkOrder to update.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder updateMany
   */
  export type WorkOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to update.
     */
    limit?: number
  }

  /**
   * WorkOrder updateManyAndReturn
   */
  export type WorkOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to update.
     */
    limit?: number
  }

  /**
   * WorkOrder upsert
   */
  export type WorkOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The filter to search for the WorkOrder to update in case it exists.
     */
    where: WorkOrderWhereUniqueInput
    /**
     * In case the WorkOrder found by the `where` argument doesn't exist, create a new WorkOrder with this data.
     */
    create: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
    /**
     * In case the WorkOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
  }

  /**
   * WorkOrder delete
   */
  export type WorkOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Filter which WorkOrder to delete.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder deleteMany
   */
  export type WorkOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrders to delete
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to delete.
     */
    limit?: number
  }

  /**
   * WorkOrder without action
   */
  export type WorkOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
  }


  /**
   * Model Municipality
   */

  export type AggregateMunicipality = {
    _count: MunicipalityCountAggregateOutputType | null
    _avg: MunicipalityAvgAggregateOutputType | null
    _sum: MunicipalitySumAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  export type MunicipalityAvgAggregateOutputType = {
    id: number | null
  }

  export type MunicipalitySumAggregateOutputType = {
    id: number | null
  }

  export type MunicipalityMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MunicipalityMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MunicipalityCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MunicipalityAvgAggregateInputType = {
    id?: true
  }

  export type MunicipalitySumAggregateInputType = {
    id?: true
  }

  export type MunicipalityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MunicipalityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MunicipalityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MunicipalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipality to aggregate.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipalities
    **/
    _count?: true | MunicipalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipalityMaxAggregateInputType
  }

  export type GetMunicipalityAggregateType<T extends MunicipalityAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipality[P]>
      : GetScalarType<T[P], AggregateMunicipality[P]>
  }




  export type MunicipalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithAggregationInput | MunicipalityOrderByWithAggregationInput[]
    by: MunicipalityScalarFieldEnum[] | MunicipalityScalarFieldEnum
    having?: MunicipalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipalityCountAggregateInputType | true
    _avg?: MunicipalityAvgAggregateInputType
    _sum?: MunicipalitySumAggregateInputType
    _min?: MunicipalityMinAggregateInputType
    _max?: MunicipalityMaxAggregateInputType
  }

  export type MunicipalityGroupByOutputType = {
    id: number
    name: string
    _count: MunicipalityCountAggregateOutputType | null
    _avg: MunicipalityAvgAggregateOutputType | null
    _sum: MunicipalitySumAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  type GetMunicipalityGroupByPayload<T extends MunicipalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
        }
      >
    >


  export type MunicipalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    dailyAssignments?: boolean | Municipality$dailyAssignmentsArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type MunicipalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["municipality"]>
  export type MunicipalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyAssignments?: boolean | Municipality$dailyAssignmentsArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MunicipalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MunicipalityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MunicipalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipality"
    objects: {
      dailyAssignments: Prisma.$DailyAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["municipality"]>
    composites: {}
  }

  type MunicipalityGetPayload<S extends boolean | null | undefined | MunicipalityDefaultArgs> = $Result.GetResult<Prisma.$MunicipalityPayload, S>

  type MunicipalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MunicipalityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MunicipalityCountAggregateInputType | true
    }

  export interface MunicipalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipality'], meta: { name: 'Municipality' } }
    /**
     * Find zero or one Municipality that matches the filter.
     * @param {MunicipalityFindUniqueArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipalityFindUniqueArgs>(args: SelectSubset<T, MunicipalityFindUniqueArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Municipality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MunicipalityFindUniqueOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipalityFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Municipality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipalityFindFirstArgs>(args?: SelectSubset<T, MunicipalityFindFirstArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Municipality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipalityFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Municipalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipalities
     * const municipalities = await prisma.municipality.findMany()
     * 
     * // Get first 10 Municipalities
     * const municipalities = await prisma.municipality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const municipalityWithIdOnly = await prisma.municipality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MunicipalityFindManyArgs>(args?: SelectSubset<T, MunicipalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Municipality.
     * @param {MunicipalityCreateArgs} args - Arguments to create a Municipality.
     * @example
     * // Create one Municipality
     * const Municipality = await prisma.municipality.create({
     *   data: {
     *     // ... data to create a Municipality
     *   }
     * })
     * 
     */
    create<T extends MunicipalityCreateArgs>(args: SelectSubset<T, MunicipalityCreateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Municipalities.
     * @param {MunicipalityCreateManyArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipalityCreateManyArgs>(args?: SelectSubset<T, MunicipalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Municipalities and returns the data saved in the database.
     * @param {MunicipalityCreateManyAndReturnArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MunicipalityCreateManyAndReturnArgs>(args?: SelectSubset<T, MunicipalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Municipality.
     * @param {MunicipalityDeleteArgs} args - Arguments to delete one Municipality.
     * @example
     * // Delete one Municipality
     * const Municipality = await prisma.municipality.delete({
     *   where: {
     *     // ... filter to delete one Municipality
     *   }
     * })
     * 
     */
    delete<T extends MunicipalityDeleteArgs>(args: SelectSubset<T, MunicipalityDeleteArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Municipality.
     * @param {MunicipalityUpdateArgs} args - Arguments to update one Municipality.
     * @example
     * // Update one Municipality
     * const municipality = await prisma.municipality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipalityUpdateArgs>(args: SelectSubset<T, MunicipalityUpdateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Municipalities.
     * @param {MunicipalityDeleteManyArgs} args - Arguments to filter Municipalities to delete.
     * @example
     * // Delete a few Municipalities
     * const { count } = await prisma.municipality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipalityDeleteManyArgs>(args?: SelectSubset<T, MunicipalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipalityUpdateManyArgs>(args: SelectSubset<T, MunicipalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities and returns the data updated in the database.
     * @param {MunicipalityUpdateManyAndReturnArgs} args - Arguments to update many Municipalities.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MunicipalityUpdateManyAndReturnArgs>(args: SelectSubset<T, MunicipalityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Municipality.
     * @param {MunicipalityUpsertArgs} args - Arguments to update or create a Municipality.
     * @example
     * // Update or create a Municipality
     * const municipality = await prisma.municipality.upsert({
     *   create: {
     *     // ... data to create a Municipality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipality we want to update
     *   }
     * })
     */
    upsert<T extends MunicipalityUpsertArgs>(args: SelectSubset<T, MunicipalityUpsertArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityCountArgs} args - Arguments to filter Municipalities to count.
     * @example
     * // Count the number of Municipalities
     * const count = await prisma.municipality.count({
     *   where: {
     *     // ... the filter for the Municipalities we want to count
     *   }
     * })
    **/
    count<T extends MunicipalityCountArgs>(
      args?: Subset<T, MunicipalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipalityAggregateArgs>(args: Subset<T, MunicipalityAggregateArgs>): Prisma.PrismaPromise<GetMunicipalityAggregateType<T>>

    /**
     * Group by Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipalityGroupByArgs['orderBy'] }
        : { orderBy?: MunicipalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipality model
   */
  readonly fields: MunicipalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailyAssignments<T extends Municipality$dailyAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$dailyAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipality model
   */
  interface MunicipalityFieldRefs {
    readonly id: FieldRef<"Municipality", 'Int'>
    readonly name: FieldRef<"Municipality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Municipality findUnique
   */
  export type MunicipalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findUniqueOrThrow
   */
  export type MunicipalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findFirst
   */
  export type MunicipalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findFirstOrThrow
   */
  export type MunicipalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findMany
   */
  export type MunicipalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipalities to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality create
   */
  export type MunicipalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipality.
     */
    data: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
  }

  /**
   * Municipality createMany
   */
  export type MunicipalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
  }

  /**
   * Municipality createManyAndReturn
   */
  export type MunicipalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
  }

  /**
   * Municipality update
   */
  export type MunicipalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipality.
     */
    data: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
    /**
     * Choose, which Municipality to update.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality updateMany
   */
  export type MunicipalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
    /**
     * Limit how many Municipalities to update.
     */
    limit?: number
  }

  /**
   * Municipality updateManyAndReturn
   */
  export type MunicipalityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
    /**
     * Limit how many Municipalities to update.
     */
    limit?: number
  }

  /**
   * Municipality upsert
   */
  export type MunicipalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipality to update in case it exists.
     */
    where: MunicipalityWhereUniqueInput
    /**
     * In case the Municipality found by the `where` argument doesn't exist, create a new Municipality with this data.
     */
    create: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
    /**
     * In case the Municipality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
  }

  /**
   * Municipality delete
   */
  export type MunicipalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter which Municipality to delete.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality deleteMany
   */
  export type MunicipalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipalities to delete
     */
    where?: MunicipalityWhereInput
    /**
     * Limit how many Municipalities to delete.
     */
    limit?: number
  }

  /**
   * Municipality.dailyAssignments
   */
  export type Municipality$dailyAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyAssignment
     */
    select?: DailyAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyAssignment
     */
    omit?: DailyAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyAssignmentInclude<ExtArgs> | null
    where?: DailyAssignmentWhereInput
    orderBy?: DailyAssignmentOrderByWithRelationInput | DailyAssignmentOrderByWithRelationInput[]
    cursor?: DailyAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyAssignmentScalarFieldEnum | DailyAssignmentScalarFieldEnum[]
  }

  /**
   * Municipality without action
   */
  export type MunicipalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
  }


  /**
   * Model RodzajAbsencji
   */

  export type AggregateRodzajAbsencji = {
    _count: RodzajAbsencjiCountAggregateOutputType | null
    _avg: RodzajAbsencjiAvgAggregateOutputType | null
    _sum: RodzajAbsencjiSumAggregateOutputType | null
    _min: RodzajAbsencjiMinAggregateOutputType | null
    _max: RodzajAbsencjiMaxAggregateOutputType | null
  }

  export type RodzajAbsencjiAvgAggregateOutputType = {
    id: number | null
  }

  export type RodzajAbsencjiSumAggregateOutputType = {
    id: number | null
  }

  export type RodzajAbsencjiMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    color: string | null
    notes: string | null
  }

  export type RodzajAbsencjiMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    color: string | null
    notes: string | null
  }

  export type RodzajAbsencjiCountAggregateOutputType = {
    id: number
    name: number
    code: number
    color: number
    notes: number
    _all: number
  }


  export type RodzajAbsencjiAvgAggregateInputType = {
    id?: true
  }

  export type RodzajAbsencjiSumAggregateInputType = {
    id?: true
  }

  export type RodzajAbsencjiMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    notes?: true
  }

  export type RodzajAbsencjiMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    notes?: true
  }

  export type RodzajAbsencjiCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    notes?: true
    _all?: true
  }

  export type RodzajAbsencjiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RodzajAbsencji to aggregate.
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RodzajAbsencjis to fetch.
     */
    orderBy?: RodzajAbsencjiOrderByWithRelationInput | RodzajAbsencjiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RodzajAbsencjiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RodzajAbsencjis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RodzajAbsencjis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RodzajAbsencjis
    **/
    _count?: true | RodzajAbsencjiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RodzajAbsencjiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RodzajAbsencjiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RodzajAbsencjiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RodzajAbsencjiMaxAggregateInputType
  }

  export type GetRodzajAbsencjiAggregateType<T extends RodzajAbsencjiAggregateArgs> = {
        [P in keyof T & keyof AggregateRodzajAbsencji]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRodzajAbsencji[P]>
      : GetScalarType<T[P], AggregateRodzajAbsencji[P]>
  }




  export type RodzajAbsencjiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RodzajAbsencjiWhereInput
    orderBy?: RodzajAbsencjiOrderByWithAggregationInput | RodzajAbsencjiOrderByWithAggregationInput[]
    by: RodzajAbsencjiScalarFieldEnum[] | RodzajAbsencjiScalarFieldEnum
    having?: RodzajAbsencjiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RodzajAbsencjiCountAggregateInputType | true
    _avg?: RodzajAbsencjiAvgAggregateInputType
    _sum?: RodzajAbsencjiSumAggregateInputType
    _min?: RodzajAbsencjiMinAggregateInputType
    _max?: RodzajAbsencjiMaxAggregateInputType
  }

  export type RodzajAbsencjiGroupByOutputType = {
    id: number
    name: string
    code: string | null
    color: string | null
    notes: string | null
    _count: RodzajAbsencjiCountAggregateOutputType | null
    _avg: RodzajAbsencjiAvgAggregateOutputType | null
    _sum: RodzajAbsencjiSumAggregateOutputType | null
    _min: RodzajAbsencjiMinAggregateOutputType | null
    _max: RodzajAbsencjiMaxAggregateOutputType | null
  }

  type GetRodzajAbsencjiGroupByPayload<T extends RodzajAbsencjiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RodzajAbsencjiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RodzajAbsencjiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RodzajAbsencjiGroupByOutputType[P]>
            : GetScalarType<T[P], RodzajAbsencjiGroupByOutputType[P]>
        }
      >
    >


  export type RodzajAbsencjiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    notes?: boolean
    workCardEntries?: boolean | RodzajAbsencji$workCardEntriesArgs<ExtArgs>
    _count?: boolean | RodzajAbsencjiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rodzajAbsencji"]>

  export type RodzajAbsencjiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    notes?: boolean
  }, ExtArgs["result"]["rodzajAbsencji"]>

  export type RodzajAbsencjiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    notes?: boolean
  }, ExtArgs["result"]["rodzajAbsencji"]>

  export type RodzajAbsencjiSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    notes?: boolean
  }

  export type RodzajAbsencjiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "color" | "notes", ExtArgs["result"]["rodzajAbsencji"]>
  export type RodzajAbsencjiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workCardEntries?: boolean | RodzajAbsencji$workCardEntriesArgs<ExtArgs>
    _count?: boolean | RodzajAbsencjiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RodzajAbsencjiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RodzajAbsencjiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RodzajAbsencjiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RodzajAbsencji"
    objects: {
      workCardEntries: Prisma.$WorkCardEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string | null
      color: string | null
      notes: string | null
    }, ExtArgs["result"]["rodzajAbsencji"]>
    composites: {}
  }

  type RodzajAbsencjiGetPayload<S extends boolean | null | undefined | RodzajAbsencjiDefaultArgs> = $Result.GetResult<Prisma.$RodzajAbsencjiPayload, S>

  type RodzajAbsencjiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RodzajAbsencjiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RodzajAbsencjiCountAggregateInputType | true
    }

  export interface RodzajAbsencjiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RodzajAbsencji'], meta: { name: 'RodzajAbsencji' } }
    /**
     * Find zero or one RodzajAbsencji that matches the filter.
     * @param {RodzajAbsencjiFindUniqueArgs} args - Arguments to find a RodzajAbsencji
     * @example
     * // Get one RodzajAbsencji
     * const rodzajAbsencji = await prisma.rodzajAbsencji.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RodzajAbsencjiFindUniqueArgs>(args: SelectSubset<T, RodzajAbsencjiFindUniqueArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RodzajAbsencji that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RodzajAbsencjiFindUniqueOrThrowArgs} args - Arguments to find a RodzajAbsencji
     * @example
     * // Get one RodzajAbsencji
     * const rodzajAbsencji = await prisma.rodzajAbsencji.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RodzajAbsencjiFindUniqueOrThrowArgs>(args: SelectSubset<T, RodzajAbsencjiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RodzajAbsencji that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiFindFirstArgs} args - Arguments to find a RodzajAbsencji
     * @example
     * // Get one RodzajAbsencji
     * const rodzajAbsencji = await prisma.rodzajAbsencji.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RodzajAbsencjiFindFirstArgs>(args?: SelectSubset<T, RodzajAbsencjiFindFirstArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RodzajAbsencji that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiFindFirstOrThrowArgs} args - Arguments to find a RodzajAbsencji
     * @example
     * // Get one RodzajAbsencji
     * const rodzajAbsencji = await prisma.rodzajAbsencji.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RodzajAbsencjiFindFirstOrThrowArgs>(args?: SelectSubset<T, RodzajAbsencjiFindFirstOrThrowArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RodzajAbsencjis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RodzajAbsencjis
     * const rodzajAbsencjis = await prisma.rodzajAbsencji.findMany()
     * 
     * // Get first 10 RodzajAbsencjis
     * const rodzajAbsencjis = await prisma.rodzajAbsencji.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rodzajAbsencjiWithIdOnly = await prisma.rodzajAbsencji.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RodzajAbsencjiFindManyArgs>(args?: SelectSubset<T, RodzajAbsencjiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RodzajAbsencji.
     * @param {RodzajAbsencjiCreateArgs} args - Arguments to create a RodzajAbsencji.
     * @example
     * // Create one RodzajAbsencji
     * const RodzajAbsencji = await prisma.rodzajAbsencji.create({
     *   data: {
     *     // ... data to create a RodzajAbsencji
     *   }
     * })
     * 
     */
    create<T extends RodzajAbsencjiCreateArgs>(args: SelectSubset<T, RodzajAbsencjiCreateArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RodzajAbsencjis.
     * @param {RodzajAbsencjiCreateManyArgs} args - Arguments to create many RodzajAbsencjis.
     * @example
     * // Create many RodzajAbsencjis
     * const rodzajAbsencji = await prisma.rodzajAbsencji.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RodzajAbsencjiCreateManyArgs>(args?: SelectSubset<T, RodzajAbsencjiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RodzajAbsencjis and returns the data saved in the database.
     * @param {RodzajAbsencjiCreateManyAndReturnArgs} args - Arguments to create many RodzajAbsencjis.
     * @example
     * // Create many RodzajAbsencjis
     * const rodzajAbsencji = await prisma.rodzajAbsencji.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RodzajAbsencjis and only return the `id`
     * const rodzajAbsencjiWithIdOnly = await prisma.rodzajAbsencji.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RodzajAbsencjiCreateManyAndReturnArgs>(args?: SelectSubset<T, RodzajAbsencjiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RodzajAbsencji.
     * @param {RodzajAbsencjiDeleteArgs} args - Arguments to delete one RodzajAbsencji.
     * @example
     * // Delete one RodzajAbsencji
     * const RodzajAbsencji = await prisma.rodzajAbsencji.delete({
     *   where: {
     *     // ... filter to delete one RodzajAbsencji
     *   }
     * })
     * 
     */
    delete<T extends RodzajAbsencjiDeleteArgs>(args: SelectSubset<T, RodzajAbsencjiDeleteArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RodzajAbsencji.
     * @param {RodzajAbsencjiUpdateArgs} args - Arguments to update one RodzajAbsencji.
     * @example
     * // Update one RodzajAbsencji
     * const rodzajAbsencji = await prisma.rodzajAbsencji.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RodzajAbsencjiUpdateArgs>(args: SelectSubset<T, RodzajAbsencjiUpdateArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RodzajAbsencjis.
     * @param {RodzajAbsencjiDeleteManyArgs} args - Arguments to filter RodzajAbsencjis to delete.
     * @example
     * // Delete a few RodzajAbsencjis
     * const { count } = await prisma.rodzajAbsencji.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RodzajAbsencjiDeleteManyArgs>(args?: SelectSubset<T, RodzajAbsencjiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RodzajAbsencjis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RodzajAbsencjis
     * const rodzajAbsencji = await prisma.rodzajAbsencji.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RodzajAbsencjiUpdateManyArgs>(args: SelectSubset<T, RodzajAbsencjiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RodzajAbsencjis and returns the data updated in the database.
     * @param {RodzajAbsencjiUpdateManyAndReturnArgs} args - Arguments to update many RodzajAbsencjis.
     * @example
     * // Update many RodzajAbsencjis
     * const rodzajAbsencji = await prisma.rodzajAbsencji.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RodzajAbsencjis and only return the `id`
     * const rodzajAbsencjiWithIdOnly = await prisma.rodzajAbsencji.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RodzajAbsencjiUpdateManyAndReturnArgs>(args: SelectSubset<T, RodzajAbsencjiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RodzajAbsencji.
     * @param {RodzajAbsencjiUpsertArgs} args - Arguments to update or create a RodzajAbsencji.
     * @example
     * // Update or create a RodzajAbsencji
     * const rodzajAbsencji = await prisma.rodzajAbsencji.upsert({
     *   create: {
     *     // ... data to create a RodzajAbsencji
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RodzajAbsencji we want to update
     *   }
     * })
     */
    upsert<T extends RodzajAbsencjiUpsertArgs>(args: SelectSubset<T, RodzajAbsencjiUpsertArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RodzajAbsencjis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiCountArgs} args - Arguments to filter RodzajAbsencjis to count.
     * @example
     * // Count the number of RodzajAbsencjis
     * const count = await prisma.rodzajAbsencji.count({
     *   where: {
     *     // ... the filter for the RodzajAbsencjis we want to count
     *   }
     * })
    **/
    count<T extends RodzajAbsencjiCountArgs>(
      args?: Subset<T, RodzajAbsencjiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RodzajAbsencjiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RodzajAbsencji.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RodzajAbsencjiAggregateArgs>(args: Subset<T, RodzajAbsencjiAggregateArgs>): Prisma.PrismaPromise<GetRodzajAbsencjiAggregateType<T>>

    /**
     * Group by RodzajAbsencji.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RodzajAbsencjiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RodzajAbsencjiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RodzajAbsencjiGroupByArgs['orderBy'] }
        : { orderBy?: RodzajAbsencjiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RodzajAbsencjiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRodzajAbsencjiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RodzajAbsencji model
   */
  readonly fields: RodzajAbsencjiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RodzajAbsencji.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RodzajAbsencjiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workCardEntries<T extends RodzajAbsencji$workCardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, RodzajAbsencji$workCardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RodzajAbsencji model
   */
  interface RodzajAbsencjiFieldRefs {
    readonly id: FieldRef<"RodzajAbsencji", 'Int'>
    readonly name: FieldRef<"RodzajAbsencji", 'String'>
    readonly code: FieldRef<"RodzajAbsencji", 'String'>
    readonly color: FieldRef<"RodzajAbsencji", 'String'>
    readonly notes: FieldRef<"RodzajAbsencji", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RodzajAbsencji findUnique
   */
  export type RodzajAbsencjiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * Filter, which RodzajAbsencji to fetch.
     */
    where: RodzajAbsencjiWhereUniqueInput
  }

  /**
   * RodzajAbsencji findUniqueOrThrow
   */
  export type RodzajAbsencjiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * Filter, which RodzajAbsencji to fetch.
     */
    where: RodzajAbsencjiWhereUniqueInput
  }

  /**
   * RodzajAbsencji findFirst
   */
  export type RodzajAbsencjiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * Filter, which RodzajAbsencji to fetch.
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RodzajAbsencjis to fetch.
     */
    orderBy?: RodzajAbsencjiOrderByWithRelationInput | RodzajAbsencjiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RodzajAbsencjis.
     */
    cursor?: RodzajAbsencjiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RodzajAbsencjis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RodzajAbsencjis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RodzajAbsencjis.
     */
    distinct?: RodzajAbsencjiScalarFieldEnum | RodzajAbsencjiScalarFieldEnum[]
  }

  /**
   * RodzajAbsencji findFirstOrThrow
   */
  export type RodzajAbsencjiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * Filter, which RodzajAbsencji to fetch.
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RodzajAbsencjis to fetch.
     */
    orderBy?: RodzajAbsencjiOrderByWithRelationInput | RodzajAbsencjiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RodzajAbsencjis.
     */
    cursor?: RodzajAbsencjiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RodzajAbsencjis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RodzajAbsencjis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RodzajAbsencjis.
     */
    distinct?: RodzajAbsencjiScalarFieldEnum | RodzajAbsencjiScalarFieldEnum[]
  }

  /**
   * RodzajAbsencji findMany
   */
  export type RodzajAbsencjiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * Filter, which RodzajAbsencjis to fetch.
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RodzajAbsencjis to fetch.
     */
    orderBy?: RodzajAbsencjiOrderByWithRelationInput | RodzajAbsencjiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RodzajAbsencjis.
     */
    cursor?: RodzajAbsencjiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RodzajAbsencjis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RodzajAbsencjis.
     */
    skip?: number
    distinct?: RodzajAbsencjiScalarFieldEnum | RodzajAbsencjiScalarFieldEnum[]
  }

  /**
   * RodzajAbsencji create
   */
  export type RodzajAbsencjiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * The data needed to create a RodzajAbsencji.
     */
    data: XOR<RodzajAbsencjiCreateInput, RodzajAbsencjiUncheckedCreateInput>
  }

  /**
   * RodzajAbsencji createMany
   */
  export type RodzajAbsencjiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RodzajAbsencjis.
     */
    data: RodzajAbsencjiCreateManyInput | RodzajAbsencjiCreateManyInput[]
  }

  /**
   * RodzajAbsencji createManyAndReturn
   */
  export type RodzajAbsencjiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * The data used to create many RodzajAbsencjis.
     */
    data: RodzajAbsencjiCreateManyInput | RodzajAbsencjiCreateManyInput[]
  }

  /**
   * RodzajAbsencji update
   */
  export type RodzajAbsencjiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * The data needed to update a RodzajAbsencji.
     */
    data: XOR<RodzajAbsencjiUpdateInput, RodzajAbsencjiUncheckedUpdateInput>
    /**
     * Choose, which RodzajAbsencji to update.
     */
    where: RodzajAbsencjiWhereUniqueInput
  }

  /**
   * RodzajAbsencji updateMany
   */
  export type RodzajAbsencjiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RodzajAbsencjis.
     */
    data: XOR<RodzajAbsencjiUpdateManyMutationInput, RodzajAbsencjiUncheckedUpdateManyInput>
    /**
     * Filter which RodzajAbsencjis to update
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * Limit how many RodzajAbsencjis to update.
     */
    limit?: number
  }

  /**
   * RodzajAbsencji updateManyAndReturn
   */
  export type RodzajAbsencjiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * The data used to update RodzajAbsencjis.
     */
    data: XOR<RodzajAbsencjiUpdateManyMutationInput, RodzajAbsencjiUncheckedUpdateManyInput>
    /**
     * Filter which RodzajAbsencjis to update
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * Limit how many RodzajAbsencjis to update.
     */
    limit?: number
  }

  /**
   * RodzajAbsencji upsert
   */
  export type RodzajAbsencjiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * The filter to search for the RodzajAbsencji to update in case it exists.
     */
    where: RodzajAbsencjiWhereUniqueInput
    /**
     * In case the RodzajAbsencji found by the `where` argument doesn't exist, create a new RodzajAbsencji with this data.
     */
    create: XOR<RodzajAbsencjiCreateInput, RodzajAbsencjiUncheckedCreateInput>
    /**
     * In case the RodzajAbsencji was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RodzajAbsencjiUpdateInput, RodzajAbsencjiUncheckedUpdateInput>
  }

  /**
   * RodzajAbsencji delete
   */
  export type RodzajAbsencjiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    /**
     * Filter which RodzajAbsencji to delete.
     */
    where: RodzajAbsencjiWhereUniqueInput
  }

  /**
   * RodzajAbsencji deleteMany
   */
  export type RodzajAbsencjiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RodzajAbsencjis to delete
     */
    where?: RodzajAbsencjiWhereInput
    /**
     * Limit how many RodzajAbsencjis to delete.
     */
    limit?: number
  }

  /**
   * RodzajAbsencji.workCardEntries
   */
  export type RodzajAbsencji$workCardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    where?: WorkCardEntryWhereInput
    orderBy?: WorkCardEntryOrderByWithRelationInput | WorkCardEntryOrderByWithRelationInput[]
    cursor?: WorkCardEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkCardEntryScalarFieldEnum | WorkCardEntryScalarFieldEnum[]
  }

  /**
   * RodzajAbsencji without action
   */
  export type RodzajAbsencjiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
  }


  /**
   * Model WorkCardEntry
   */

  export type AggregateWorkCardEntry = {
    _count: WorkCardEntryCountAggregateOutputType | null
    _avg: WorkCardEntryAvgAggregateOutputType | null
    _sum: WorkCardEntrySumAggregateOutputType | null
    _min: WorkCardEntryMinAggregateOutputType | null
    _max: WorkCardEntryMaxAggregateOutputType | null
  }

  export type WorkCardEntryAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    actualTotal: number | null
    absenceTypeId: number | null
  }

  export type WorkCardEntrySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    actualTotal: number | null
    absenceTypeId: number | null
  }

  export type WorkCardEntryMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    actualFrom: string | null
    actualTo: string | null
    actualTotal: number | null
    absenceTypeId: number | null
    onCall: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkCardEntryMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    actualFrom: string | null
    actualTo: string | null
    actualTotal: number | null
    absenceTypeId: number | null
    onCall: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkCardEntryCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    actualFrom: number
    actualTo: number
    actualTotal: number
    absenceTypeId: number
    onCall: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkCardEntryAvgAggregateInputType = {
    id?: true
    employeeId?: true
    actualTotal?: true
    absenceTypeId?: true
  }

  export type WorkCardEntrySumAggregateInputType = {
    id?: true
    employeeId?: true
    actualTotal?: true
    absenceTypeId?: true
  }

  export type WorkCardEntryMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    actualFrom?: true
    actualTo?: true
    actualTotal?: true
    absenceTypeId?: true
    onCall?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkCardEntryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    actualFrom?: true
    actualTo?: true
    actualTotal?: true
    absenceTypeId?: true
    onCall?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkCardEntryCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    actualFrom?: true
    actualTo?: true
    actualTotal?: true
    absenceTypeId?: true
    onCall?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkCardEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkCardEntry to aggregate.
     */
    where?: WorkCardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkCardEntries to fetch.
     */
    orderBy?: WorkCardEntryOrderByWithRelationInput | WorkCardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkCardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkCardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkCardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkCardEntries
    **/
    _count?: true | WorkCardEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkCardEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkCardEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkCardEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkCardEntryMaxAggregateInputType
  }

  export type GetWorkCardEntryAggregateType<T extends WorkCardEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkCardEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkCardEntry[P]>
      : GetScalarType<T[P], AggregateWorkCardEntry[P]>
  }




  export type WorkCardEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkCardEntryWhereInput
    orderBy?: WorkCardEntryOrderByWithAggregationInput | WorkCardEntryOrderByWithAggregationInput[]
    by: WorkCardEntryScalarFieldEnum[] | WorkCardEntryScalarFieldEnum
    having?: WorkCardEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkCardEntryCountAggregateInputType | true
    _avg?: WorkCardEntryAvgAggregateInputType
    _sum?: WorkCardEntrySumAggregateInputType
    _min?: WorkCardEntryMinAggregateInputType
    _max?: WorkCardEntryMaxAggregateInputType
  }

  export type WorkCardEntryGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    actualFrom: string | null
    actualTo: string | null
    actualTotal: number | null
    absenceTypeId: number | null
    onCall: boolean
    createdAt: Date
    updatedAt: Date
    _count: WorkCardEntryCountAggregateOutputType | null
    _avg: WorkCardEntryAvgAggregateOutputType | null
    _sum: WorkCardEntrySumAggregateOutputType | null
    _min: WorkCardEntryMinAggregateOutputType | null
    _max: WorkCardEntryMaxAggregateOutputType | null
  }

  type GetWorkCardEntryGroupByPayload<T extends WorkCardEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkCardEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkCardEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkCardEntryGroupByOutputType[P]>
            : GetScalarType<T[P], WorkCardEntryGroupByOutputType[P]>
        }
      >
    >


  export type WorkCardEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    actualFrom?: boolean
    actualTo?: boolean
    actualTotal?: boolean
    absenceTypeId?: boolean
    onCall?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    absenceType?: boolean | WorkCardEntry$absenceTypeArgs<ExtArgs>
  }, ExtArgs["result"]["workCardEntry"]>

  export type WorkCardEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    actualFrom?: boolean
    actualTo?: boolean
    actualTotal?: boolean
    absenceTypeId?: boolean
    onCall?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    absenceType?: boolean | WorkCardEntry$absenceTypeArgs<ExtArgs>
  }, ExtArgs["result"]["workCardEntry"]>

  export type WorkCardEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    actualFrom?: boolean
    actualTo?: boolean
    actualTotal?: boolean
    absenceTypeId?: boolean
    onCall?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    absenceType?: boolean | WorkCardEntry$absenceTypeArgs<ExtArgs>
  }, ExtArgs["result"]["workCardEntry"]>

  export type WorkCardEntrySelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    actualFrom?: boolean
    actualTo?: boolean
    actualTotal?: boolean
    absenceTypeId?: boolean
    onCall?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkCardEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "actualFrom" | "actualTo" | "actualTotal" | "absenceTypeId" | "onCall" | "createdAt" | "updatedAt", ExtArgs["result"]["workCardEntry"]>
  export type WorkCardEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    absenceType?: boolean | WorkCardEntry$absenceTypeArgs<ExtArgs>
  }
  export type WorkCardEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    absenceType?: boolean | WorkCardEntry$absenceTypeArgs<ExtArgs>
  }
  export type WorkCardEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    absenceType?: boolean | WorkCardEntry$absenceTypeArgs<ExtArgs>
  }

  export type $WorkCardEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkCardEntry"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      absenceType: Prisma.$RodzajAbsencjiPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      actualFrom: string | null
      actualTo: string | null
      actualTotal: number | null
      absenceTypeId: number | null
      onCall: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workCardEntry"]>
    composites: {}
  }

  type WorkCardEntryGetPayload<S extends boolean | null | undefined | WorkCardEntryDefaultArgs> = $Result.GetResult<Prisma.$WorkCardEntryPayload, S>

  type WorkCardEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkCardEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkCardEntryCountAggregateInputType | true
    }

  export interface WorkCardEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkCardEntry'], meta: { name: 'WorkCardEntry' } }
    /**
     * Find zero or one WorkCardEntry that matches the filter.
     * @param {WorkCardEntryFindUniqueArgs} args - Arguments to find a WorkCardEntry
     * @example
     * // Get one WorkCardEntry
     * const workCardEntry = await prisma.workCardEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkCardEntryFindUniqueArgs>(args: SelectSubset<T, WorkCardEntryFindUniqueArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkCardEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkCardEntryFindUniqueOrThrowArgs} args - Arguments to find a WorkCardEntry
     * @example
     * // Get one WorkCardEntry
     * const workCardEntry = await prisma.workCardEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkCardEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkCardEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkCardEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryFindFirstArgs} args - Arguments to find a WorkCardEntry
     * @example
     * // Get one WorkCardEntry
     * const workCardEntry = await prisma.workCardEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkCardEntryFindFirstArgs>(args?: SelectSubset<T, WorkCardEntryFindFirstArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkCardEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryFindFirstOrThrowArgs} args - Arguments to find a WorkCardEntry
     * @example
     * // Get one WorkCardEntry
     * const workCardEntry = await prisma.workCardEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkCardEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkCardEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkCardEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkCardEntries
     * const workCardEntries = await prisma.workCardEntry.findMany()
     * 
     * // Get first 10 WorkCardEntries
     * const workCardEntries = await prisma.workCardEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workCardEntryWithIdOnly = await prisma.workCardEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkCardEntryFindManyArgs>(args?: SelectSubset<T, WorkCardEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkCardEntry.
     * @param {WorkCardEntryCreateArgs} args - Arguments to create a WorkCardEntry.
     * @example
     * // Create one WorkCardEntry
     * const WorkCardEntry = await prisma.workCardEntry.create({
     *   data: {
     *     // ... data to create a WorkCardEntry
     *   }
     * })
     * 
     */
    create<T extends WorkCardEntryCreateArgs>(args: SelectSubset<T, WorkCardEntryCreateArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkCardEntries.
     * @param {WorkCardEntryCreateManyArgs} args - Arguments to create many WorkCardEntries.
     * @example
     * // Create many WorkCardEntries
     * const workCardEntry = await prisma.workCardEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkCardEntryCreateManyArgs>(args?: SelectSubset<T, WorkCardEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkCardEntries and returns the data saved in the database.
     * @param {WorkCardEntryCreateManyAndReturnArgs} args - Arguments to create many WorkCardEntries.
     * @example
     * // Create many WorkCardEntries
     * const workCardEntry = await prisma.workCardEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkCardEntries and only return the `id`
     * const workCardEntryWithIdOnly = await prisma.workCardEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkCardEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkCardEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkCardEntry.
     * @param {WorkCardEntryDeleteArgs} args - Arguments to delete one WorkCardEntry.
     * @example
     * // Delete one WorkCardEntry
     * const WorkCardEntry = await prisma.workCardEntry.delete({
     *   where: {
     *     // ... filter to delete one WorkCardEntry
     *   }
     * })
     * 
     */
    delete<T extends WorkCardEntryDeleteArgs>(args: SelectSubset<T, WorkCardEntryDeleteArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkCardEntry.
     * @param {WorkCardEntryUpdateArgs} args - Arguments to update one WorkCardEntry.
     * @example
     * // Update one WorkCardEntry
     * const workCardEntry = await prisma.workCardEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkCardEntryUpdateArgs>(args: SelectSubset<T, WorkCardEntryUpdateArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkCardEntries.
     * @param {WorkCardEntryDeleteManyArgs} args - Arguments to filter WorkCardEntries to delete.
     * @example
     * // Delete a few WorkCardEntries
     * const { count } = await prisma.workCardEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkCardEntryDeleteManyArgs>(args?: SelectSubset<T, WorkCardEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkCardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkCardEntries
     * const workCardEntry = await prisma.workCardEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkCardEntryUpdateManyArgs>(args: SelectSubset<T, WorkCardEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkCardEntries and returns the data updated in the database.
     * @param {WorkCardEntryUpdateManyAndReturnArgs} args - Arguments to update many WorkCardEntries.
     * @example
     * // Update many WorkCardEntries
     * const workCardEntry = await prisma.workCardEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkCardEntries and only return the `id`
     * const workCardEntryWithIdOnly = await prisma.workCardEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkCardEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkCardEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkCardEntry.
     * @param {WorkCardEntryUpsertArgs} args - Arguments to update or create a WorkCardEntry.
     * @example
     * // Update or create a WorkCardEntry
     * const workCardEntry = await prisma.workCardEntry.upsert({
     *   create: {
     *     // ... data to create a WorkCardEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkCardEntry we want to update
     *   }
     * })
     */
    upsert<T extends WorkCardEntryUpsertArgs>(args: SelectSubset<T, WorkCardEntryUpsertArgs<ExtArgs>>): Prisma__WorkCardEntryClient<$Result.GetResult<Prisma.$WorkCardEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkCardEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryCountArgs} args - Arguments to filter WorkCardEntries to count.
     * @example
     * // Count the number of WorkCardEntries
     * const count = await prisma.workCardEntry.count({
     *   where: {
     *     // ... the filter for the WorkCardEntries we want to count
     *   }
     * })
    **/
    count<T extends WorkCardEntryCountArgs>(
      args?: Subset<T, WorkCardEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkCardEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkCardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkCardEntryAggregateArgs>(args: Subset<T, WorkCardEntryAggregateArgs>): Prisma.PrismaPromise<GetWorkCardEntryAggregateType<T>>

    /**
     * Group by WorkCardEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCardEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkCardEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkCardEntryGroupByArgs['orderBy'] }
        : { orderBy?: WorkCardEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkCardEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkCardEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkCardEntry model
   */
  readonly fields: WorkCardEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkCardEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkCardEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    absenceType<T extends WorkCardEntry$absenceTypeArgs<ExtArgs> = {}>(args?: Subset<T, WorkCardEntry$absenceTypeArgs<ExtArgs>>): Prisma__RodzajAbsencjiClient<$Result.GetResult<Prisma.$RodzajAbsencjiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkCardEntry model
   */
  interface WorkCardEntryFieldRefs {
    readonly id: FieldRef<"WorkCardEntry", 'Int'>
    readonly employeeId: FieldRef<"WorkCardEntry", 'Int'>
    readonly date: FieldRef<"WorkCardEntry", 'DateTime'>
    readonly actualFrom: FieldRef<"WorkCardEntry", 'String'>
    readonly actualTo: FieldRef<"WorkCardEntry", 'String'>
    readonly actualTotal: FieldRef<"WorkCardEntry", 'Float'>
    readonly absenceTypeId: FieldRef<"WorkCardEntry", 'Int'>
    readonly onCall: FieldRef<"WorkCardEntry", 'Boolean'>
    readonly createdAt: FieldRef<"WorkCardEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkCardEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkCardEntry findUnique
   */
  export type WorkCardEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkCardEntry to fetch.
     */
    where: WorkCardEntryWhereUniqueInput
  }

  /**
   * WorkCardEntry findUniqueOrThrow
   */
  export type WorkCardEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkCardEntry to fetch.
     */
    where: WorkCardEntryWhereUniqueInput
  }

  /**
   * WorkCardEntry findFirst
   */
  export type WorkCardEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkCardEntry to fetch.
     */
    where?: WorkCardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkCardEntries to fetch.
     */
    orderBy?: WorkCardEntryOrderByWithRelationInput | WorkCardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkCardEntries.
     */
    cursor?: WorkCardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkCardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkCardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkCardEntries.
     */
    distinct?: WorkCardEntryScalarFieldEnum | WorkCardEntryScalarFieldEnum[]
  }

  /**
   * WorkCardEntry findFirstOrThrow
   */
  export type WorkCardEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkCardEntry to fetch.
     */
    where?: WorkCardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkCardEntries to fetch.
     */
    orderBy?: WorkCardEntryOrderByWithRelationInput | WorkCardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkCardEntries.
     */
    cursor?: WorkCardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkCardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkCardEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkCardEntries.
     */
    distinct?: WorkCardEntryScalarFieldEnum | WorkCardEntryScalarFieldEnum[]
  }

  /**
   * WorkCardEntry findMany
   */
  export type WorkCardEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * Filter, which WorkCardEntries to fetch.
     */
    where?: WorkCardEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkCardEntries to fetch.
     */
    orderBy?: WorkCardEntryOrderByWithRelationInput | WorkCardEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkCardEntries.
     */
    cursor?: WorkCardEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkCardEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkCardEntries.
     */
    skip?: number
    distinct?: WorkCardEntryScalarFieldEnum | WorkCardEntryScalarFieldEnum[]
  }

  /**
   * WorkCardEntry create
   */
  export type WorkCardEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkCardEntry.
     */
    data: XOR<WorkCardEntryCreateInput, WorkCardEntryUncheckedCreateInput>
  }

  /**
   * WorkCardEntry createMany
   */
  export type WorkCardEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkCardEntries.
     */
    data: WorkCardEntryCreateManyInput | WorkCardEntryCreateManyInput[]
  }

  /**
   * WorkCardEntry createManyAndReturn
   */
  export type WorkCardEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * The data used to create many WorkCardEntries.
     */
    data: WorkCardEntryCreateManyInput | WorkCardEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkCardEntry update
   */
  export type WorkCardEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkCardEntry.
     */
    data: XOR<WorkCardEntryUpdateInput, WorkCardEntryUncheckedUpdateInput>
    /**
     * Choose, which WorkCardEntry to update.
     */
    where: WorkCardEntryWhereUniqueInput
  }

  /**
   * WorkCardEntry updateMany
   */
  export type WorkCardEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkCardEntries.
     */
    data: XOR<WorkCardEntryUpdateManyMutationInput, WorkCardEntryUncheckedUpdateManyInput>
    /**
     * Filter which WorkCardEntries to update
     */
    where?: WorkCardEntryWhereInput
    /**
     * Limit how many WorkCardEntries to update.
     */
    limit?: number
  }

  /**
   * WorkCardEntry updateManyAndReturn
   */
  export type WorkCardEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * The data used to update WorkCardEntries.
     */
    data: XOR<WorkCardEntryUpdateManyMutationInput, WorkCardEntryUncheckedUpdateManyInput>
    /**
     * Filter which WorkCardEntries to update
     */
    where?: WorkCardEntryWhereInput
    /**
     * Limit how many WorkCardEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkCardEntry upsert
   */
  export type WorkCardEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkCardEntry to update in case it exists.
     */
    where: WorkCardEntryWhereUniqueInput
    /**
     * In case the WorkCardEntry found by the `where` argument doesn't exist, create a new WorkCardEntry with this data.
     */
    create: XOR<WorkCardEntryCreateInput, WorkCardEntryUncheckedCreateInput>
    /**
     * In case the WorkCardEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkCardEntryUpdateInput, WorkCardEntryUncheckedUpdateInput>
  }

  /**
   * WorkCardEntry delete
   */
  export type WorkCardEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
    /**
     * Filter which WorkCardEntry to delete.
     */
    where: WorkCardEntryWhereUniqueInput
  }

  /**
   * WorkCardEntry deleteMany
   */
  export type WorkCardEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkCardEntries to delete
     */
    where?: WorkCardEntryWhereInput
    /**
     * Limit how many WorkCardEntries to delete.
     */
    limit?: number
  }

  /**
   * WorkCardEntry.absenceType
   */
  export type WorkCardEntry$absenceTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RodzajAbsencji
     */
    select?: RodzajAbsencjiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RodzajAbsencji
     */
    omit?: RodzajAbsencjiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RodzajAbsencjiInclude<ExtArgs> | null
    where?: RodzajAbsencjiWhereInput
  }

  /**
   * WorkCardEntry without action
   */
  export type WorkCardEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkCardEntry
     */
    select?: WorkCardEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkCardEntry
     */
    omit?: WorkCardEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkCardEntryInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
    uploadedBy: number | null
    deletedBy: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    fileSize: number | null
    uploadedBy: number | null
    deletedBy: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    contractNumber: string | null
    parties: string | null
    description: string | null
    tags: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedBy: number | null
    uploadedAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedBy: number | null
    deletedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    contractNumber: string | null
    parties: string | null
    description: string | null
    tags: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedBy: number | null
    uploadedAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedBy: number | null
    deletedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    contractNumber: number
    parties: number
    description: number
    tags: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    uploadedBy: number
    uploadedAt: number
    updatedAt: number
    isDeleted: number
    deletedBy: number
    deletedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    fileSize?: true
    uploadedBy?: true
    deletedBy?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    fileSize?: true
    uploadedBy?: true
    deletedBy?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    contractNumber?: true
    parties?: true
    description?: true
    tags?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    uploadedAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedBy?: true
    deletedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    contractNumber?: true
    parties?: true
    description?: true
    tags?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    uploadedAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedBy?: true
    deletedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    contractNumber?: true
    parties?: true
    description?: true
    tags?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    uploadedAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedBy?: true
    deletedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    contractNumber: string | null
    parties: string
    description: string | null
    tags: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt: Date
    updatedAt: Date
    isDeleted: boolean
    deletedBy: number | null
    deletedAt: Date | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    parties?: boolean
    description?: boolean
    tags?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    deletedAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Document$deleterArgs<ExtArgs>
    attachments?: boolean | Document$attachmentsArgs<ExtArgs>
    annotations?: boolean | Document$annotationsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    parties?: boolean
    description?: boolean
    tags?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    deletedAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Document$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractNumber?: boolean
    parties?: boolean
    description?: boolean
    tags?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    deletedAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Document$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    contractNumber?: boolean
    parties?: boolean
    description?: boolean
    tags?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedBy?: boolean
    deletedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractNumber" | "parties" | "description" | "tags" | "fileName" | "filePath" | "fileSize" | "mimeType" | "uploadedBy" | "uploadedAt" | "updatedAt" | "isDeleted" | "deletedBy" | "deletedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Document$deleterArgs<ExtArgs>
    attachments?: boolean | Document$attachmentsArgs<ExtArgs>
    annotations?: boolean | Document$annotationsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Document$deleterArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    deleter?: boolean | Document$deleterArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
      deleter: Prisma.$UserPayload<ExtArgs> | null
      attachments: Prisma.$DocumentAttachmentPayload<ExtArgs>[]
      annotations: Prisma.$DocumentAnnotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contractNumber: string | null
      parties: string
      description: string | null
      tags: string | null
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      uploadedBy: number
      uploadedAt: Date
      updatedAt: Date
      isDeleted: boolean
      deletedBy: number | null
      deletedAt: Date | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deleter<T extends Document$deleterArgs<ExtArgs> = {}>(args?: Subset<T, Document$deleterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Document$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Document$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    annotations<T extends Document$annotationsArgs<ExtArgs> = {}>(args?: Subset<T, Document$annotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly contractNumber: FieldRef<"Document", 'String'>
    readonly parties: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly tags: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'Int'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly isDeleted: FieldRef<"Document", 'Boolean'>
    readonly deletedBy: FieldRef<"Document", 'Int'>
    readonly deletedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.deleter
   */
  export type Document$deleterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Document.attachments
   */
  export type Document$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    cursor?: DocumentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * Document.annotations
   */
  export type Document$annotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    where?: DocumentAnnotationWhereInput
    orderBy?: DocumentAnnotationOrderByWithRelationInput | DocumentAnnotationOrderByWithRelationInput[]
    cursor?: DocumentAnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAnnotationScalarFieldEnum | DocumentAnnotationScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentAttachment
   */

  export type AggregateDocumentAttachment = {
    _count: DocumentAttachmentCountAggregateOutputType | null
    _avg: DocumentAttachmentAvgAggregateOutputType | null
    _sum: DocumentAttachmentSumAggregateOutputType | null
    _min: DocumentAttachmentMinAggregateOutputType | null
    _max: DocumentAttachmentMaxAggregateOutputType | null
  }

  export type DocumentAttachmentAvgAggregateOutputType = {
    id: number | null
    documentId: number | null
    fileSize: number | null
    uploadedBy: number | null
  }

  export type DocumentAttachmentSumAggregateOutputType = {
    id: number | null
    documentId: number | null
    fileSize: number | null
    uploadedBy: number | null
  }

  export type DocumentAttachmentMinAggregateOutputType = {
    id: number | null
    documentId: number | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedBy: number | null
    uploadedAt: Date | null
    isDeleted: boolean | null
  }

  export type DocumentAttachmentMaxAggregateOutputType = {
    id: number | null
    documentId: number | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedBy: number | null
    uploadedAt: Date | null
    isDeleted: boolean | null
  }

  export type DocumentAttachmentCountAggregateOutputType = {
    id: number
    documentId: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    uploadedBy: number
    uploadedAt: number
    isDeleted: number
    _all: number
  }


  export type DocumentAttachmentAvgAggregateInputType = {
    id?: true
    documentId?: true
    fileSize?: true
    uploadedBy?: true
  }

  export type DocumentAttachmentSumAggregateInputType = {
    id?: true
    documentId?: true
    fileSize?: true
    uploadedBy?: true
  }

  export type DocumentAttachmentMinAggregateInputType = {
    id?: true
    documentId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    uploadedAt?: true
    isDeleted?: true
  }

  export type DocumentAttachmentMaxAggregateInputType = {
    id?: true
    documentId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    uploadedAt?: true
    isDeleted?: true
  }

  export type DocumentAttachmentCountAggregateInputType = {
    id?: true
    documentId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    uploadedAt?: true
    isDeleted?: true
    _all?: true
  }

  export type DocumentAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAttachment to aggregate.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentAttachments
    **/
    _count?: true | DocumentAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAttachmentMaxAggregateInputType
  }

  export type GetDocumentAttachmentAggregateType<T extends DocumentAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAttachment[P]>
      : GetScalarType<T[P], AggregateDocumentAttachment[P]>
  }




  export type DocumentAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithAggregationInput | DocumentAttachmentOrderByWithAggregationInput[]
    by: DocumentAttachmentScalarFieldEnum[] | DocumentAttachmentScalarFieldEnum
    having?: DocumentAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAttachmentCountAggregateInputType | true
    _avg?: DocumentAttachmentAvgAggregateInputType
    _sum?: DocumentAttachmentSumAggregateInputType
    _min?: DocumentAttachmentMinAggregateInputType
    _max?: DocumentAttachmentMaxAggregateInputType
  }

  export type DocumentAttachmentGroupByOutputType = {
    id: number
    documentId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt: Date
    isDeleted: boolean
    _count: DocumentAttachmentCountAggregateOutputType | null
    _avg: DocumentAttachmentAvgAggregateOutputType | null
    _sum: DocumentAttachmentSumAggregateOutputType | null
    _min: DocumentAttachmentMinAggregateOutputType | null
    _max: DocumentAttachmentMaxAggregateOutputType | null
  }

  type GetDocumentAttachmentGroupByPayload<T extends DocumentAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    isDeleted?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    isDeleted?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    isDeleted?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectScalar = {
    id?: boolean
    documentId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    isDeleted?: boolean
  }

  export type DocumentAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "fileName" | "filePath" | "fileSize" | "mimeType" | "uploadedBy" | "uploadedAt" | "isDeleted", ExtArgs["result"]["documentAttachment"]>
  export type DocumentAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentAttachment"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      documentId: number
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      uploadedBy: number
      uploadedAt: Date
      isDeleted: boolean
    }, ExtArgs["result"]["documentAttachment"]>
    composites: {}
  }

  type DocumentAttachmentGetPayload<S extends boolean | null | undefined | DocumentAttachmentDefaultArgs> = $Result.GetResult<Prisma.$DocumentAttachmentPayload, S>

  type DocumentAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentAttachmentCountAggregateInputType | true
    }

  export interface DocumentAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentAttachment'], meta: { name: 'DocumentAttachment' } }
    /**
     * Find zero or one DocumentAttachment that matches the filter.
     * @param {DocumentAttachmentFindUniqueArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentAttachmentFindUniqueArgs>(args: SelectSubset<T, DocumentAttachmentFindUniqueArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentAttachmentFindUniqueOrThrowArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindFirstArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentAttachmentFindFirstArgs>(args?: SelectSubset<T, DocumentAttachmentFindFirstArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindFirstOrThrowArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAttachments
     * const documentAttachments = await prisma.documentAttachment.findMany()
     * 
     * // Get first 10 DocumentAttachments
     * const documentAttachments = await prisma.documentAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentAttachmentFindManyArgs>(args?: SelectSubset<T, DocumentAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentAttachment.
     * @param {DocumentAttachmentCreateArgs} args - Arguments to create a DocumentAttachment.
     * @example
     * // Create one DocumentAttachment
     * const DocumentAttachment = await prisma.documentAttachment.create({
     *   data: {
     *     // ... data to create a DocumentAttachment
     *   }
     * })
     * 
     */
    create<T extends DocumentAttachmentCreateArgs>(args: SelectSubset<T, DocumentAttachmentCreateArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentAttachments.
     * @param {DocumentAttachmentCreateManyArgs} args - Arguments to create many DocumentAttachments.
     * @example
     * // Create many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentAttachmentCreateManyArgs>(args?: SelectSubset<T, DocumentAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentAttachments and returns the data saved in the database.
     * @param {DocumentAttachmentCreateManyAndReturnArgs} args - Arguments to create many DocumentAttachments.
     * @example
     * // Create many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentAttachments and only return the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentAttachment.
     * @param {DocumentAttachmentDeleteArgs} args - Arguments to delete one DocumentAttachment.
     * @example
     * // Delete one DocumentAttachment
     * const DocumentAttachment = await prisma.documentAttachment.delete({
     *   where: {
     *     // ... filter to delete one DocumentAttachment
     *   }
     * })
     * 
     */
    delete<T extends DocumentAttachmentDeleteArgs>(args: SelectSubset<T, DocumentAttachmentDeleteArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentAttachment.
     * @param {DocumentAttachmentUpdateArgs} args - Arguments to update one DocumentAttachment.
     * @example
     * // Update one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentAttachmentUpdateArgs>(args: SelectSubset<T, DocumentAttachmentUpdateArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentAttachments.
     * @param {DocumentAttachmentDeleteManyArgs} args - Arguments to filter DocumentAttachments to delete.
     * @example
     * // Delete a few DocumentAttachments
     * const { count } = await prisma.documentAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentAttachmentDeleteManyArgs>(args?: SelectSubset<T, DocumentAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentAttachmentUpdateManyArgs>(args: SelectSubset<T, DocumentAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAttachments and returns the data updated in the database.
     * @param {DocumentAttachmentUpdateManyAndReturnArgs} args - Arguments to update many DocumentAttachments.
     * @example
     * // Update many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentAttachments and only return the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentAttachment.
     * @param {DocumentAttachmentUpsertArgs} args - Arguments to update or create a DocumentAttachment.
     * @example
     * // Update or create a DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.upsert({
     *   create: {
     *     // ... data to create a DocumentAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAttachment we want to update
     *   }
     * })
     */
    upsert<T extends DocumentAttachmentUpsertArgs>(args: SelectSubset<T, DocumentAttachmentUpsertArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentCountArgs} args - Arguments to filter DocumentAttachments to count.
     * @example
     * // Count the number of DocumentAttachments
     * const count = await prisma.documentAttachment.count({
     *   where: {
     *     // ... the filter for the DocumentAttachments we want to count
     *   }
     * })
    **/
    count<T extends DocumentAttachmentCountArgs>(
      args?: Subset<T, DocumentAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAttachmentAggregateArgs>(args: Subset<T, DocumentAttachmentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAttachmentAggregateType<T>>

    /**
     * Group by DocumentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentAttachment model
   */
  readonly fields: DocumentAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentAttachment model
   */
  interface DocumentAttachmentFieldRefs {
    readonly id: FieldRef<"DocumentAttachment", 'Int'>
    readonly documentId: FieldRef<"DocumentAttachment", 'Int'>
    readonly fileName: FieldRef<"DocumentAttachment", 'String'>
    readonly filePath: FieldRef<"DocumentAttachment", 'String'>
    readonly fileSize: FieldRef<"DocumentAttachment", 'Int'>
    readonly mimeType: FieldRef<"DocumentAttachment", 'String'>
    readonly uploadedBy: FieldRef<"DocumentAttachment", 'Int'>
    readonly uploadedAt: FieldRef<"DocumentAttachment", 'DateTime'>
    readonly isDeleted: FieldRef<"DocumentAttachment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DocumentAttachment findUnique
   */
  export type DocumentAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment findUniqueOrThrow
   */
  export type DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment findFirst
   */
  export type DocumentAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAttachments.
     */
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * DocumentAttachment findFirstOrThrow
   */
  export type DocumentAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAttachments.
     */
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * DocumentAttachment findMany
   */
  export type DocumentAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachments to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * DocumentAttachment create
   */
  export type DocumentAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentAttachment.
     */
    data: XOR<DocumentAttachmentCreateInput, DocumentAttachmentUncheckedCreateInput>
  }

  /**
   * DocumentAttachment createMany
   */
  export type DocumentAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentAttachments.
     */
    data: DocumentAttachmentCreateManyInput | DocumentAttachmentCreateManyInput[]
  }

  /**
   * DocumentAttachment createManyAndReturn
   */
  export type DocumentAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentAttachments.
     */
    data: DocumentAttachmentCreateManyInput | DocumentAttachmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAttachment update
   */
  export type DocumentAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentAttachment.
     */
    data: XOR<DocumentAttachmentUpdateInput, DocumentAttachmentUncheckedUpdateInput>
    /**
     * Choose, which DocumentAttachment to update.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment updateMany
   */
  export type DocumentAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentAttachments.
     */
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAttachments to update
     */
    where?: DocumentAttachmentWhereInput
    /**
     * Limit how many DocumentAttachments to update.
     */
    limit?: number
  }

  /**
   * DocumentAttachment updateManyAndReturn
   */
  export type DocumentAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update DocumentAttachments.
     */
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAttachments to update
     */
    where?: DocumentAttachmentWhereInput
    /**
     * Limit how many DocumentAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAttachment upsert
   */
  export type DocumentAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentAttachment to update in case it exists.
     */
    where: DocumentAttachmentWhereUniqueInput
    /**
     * In case the DocumentAttachment found by the `where` argument doesn't exist, create a new DocumentAttachment with this data.
     */
    create: XOR<DocumentAttachmentCreateInput, DocumentAttachmentUncheckedCreateInput>
    /**
     * In case the DocumentAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentAttachmentUpdateInput, DocumentAttachmentUncheckedUpdateInput>
  }

  /**
   * DocumentAttachment delete
   */
  export type DocumentAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter which DocumentAttachment to delete.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment deleteMany
   */
  export type DocumentAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAttachments to delete
     */
    where?: DocumentAttachmentWhereInput
    /**
     * Limit how many DocumentAttachments to delete.
     */
    limit?: number
  }

  /**
   * DocumentAttachment without action
   */
  export type DocumentAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentAnnotation
   */

  export type AggregateDocumentAnnotation = {
    _count: DocumentAnnotationCountAggregateOutputType | null
    _avg: DocumentAnnotationAvgAggregateOutputType | null
    _sum: DocumentAnnotationSumAggregateOutputType | null
    _min: DocumentAnnotationMinAggregateOutputType | null
    _max: DocumentAnnotationMaxAggregateOutputType | null
  }

  export type DocumentAnnotationAvgAggregateOutputType = {
    id: number | null
    documentId: number | null
    userId: number | null
    page: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
  }

  export type DocumentAnnotationSumAggregateOutputType = {
    id: number | null
    documentId: number | null
    userId: number | null
    page: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
  }

  export type DocumentAnnotationMinAggregateOutputType = {
    id: number | null
    documentId: number | null
    userId: number | null
    type: string | null
    page: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    content: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentAnnotationMaxAggregateOutputType = {
    id: number | null
    documentId: number | null
    userId: number | null
    type: string | null
    page: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    content: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentAnnotationCountAggregateOutputType = {
    id: number
    documentId: number
    userId: number
    type: number
    page: number
    x: number
    y: number
    width: number
    height: number
    content: number
    color: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAnnotationAvgAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    page?: true
    x?: true
    y?: true
    width?: true
    height?: true
  }

  export type DocumentAnnotationSumAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    page?: true
    x?: true
    y?: true
    width?: true
    height?: true
  }

  export type DocumentAnnotationMinAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    type?: true
    page?: true
    x?: true
    y?: true
    width?: true
    height?: true
    content?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentAnnotationMaxAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    type?: true
    page?: true
    x?: true
    y?: true
    width?: true
    height?: true
    content?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentAnnotationCountAggregateInputType = {
    id?: true
    documentId?: true
    userId?: true
    type?: true
    page?: true
    x?: true
    y?: true
    width?: true
    height?: true
    content?: true
    color?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAnnotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAnnotation to aggregate.
     */
    where?: DocumentAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAnnotations to fetch.
     */
    orderBy?: DocumentAnnotationOrderByWithRelationInput | DocumentAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAnnotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentAnnotations
    **/
    _count?: true | DocumentAnnotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAnnotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentAnnotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAnnotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAnnotationMaxAggregateInputType
  }

  export type GetDocumentAnnotationAggregateType<T extends DocumentAnnotationAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAnnotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAnnotation[P]>
      : GetScalarType<T[P], AggregateDocumentAnnotation[P]>
  }




  export type DocumentAnnotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAnnotationWhereInput
    orderBy?: DocumentAnnotationOrderByWithAggregationInput | DocumentAnnotationOrderByWithAggregationInput[]
    by: DocumentAnnotationScalarFieldEnum[] | DocumentAnnotationScalarFieldEnum
    having?: DocumentAnnotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAnnotationCountAggregateInputType | true
    _avg?: DocumentAnnotationAvgAggregateInputType
    _sum?: DocumentAnnotationSumAggregateInputType
    _min?: DocumentAnnotationMinAggregateInputType
    _max?: DocumentAnnotationMaxAggregateInputType
  }

  export type DocumentAnnotationGroupByOutputType = {
    id: number
    documentId: number
    userId: number
    type: string
    page: number
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    content: string | null
    color: string | null
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentAnnotationCountAggregateOutputType | null
    _avg: DocumentAnnotationAvgAggregateOutputType | null
    _sum: DocumentAnnotationSumAggregateOutputType | null
    _min: DocumentAnnotationMinAggregateOutputType | null
    _max: DocumentAnnotationMaxAggregateOutputType | null
  }

  type GetDocumentAnnotationGroupByPayload<T extends DocumentAnnotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAnnotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAnnotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAnnotationGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAnnotationGroupByOutputType[P]>
        }
      >
    >


  export type DocumentAnnotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    type?: boolean
    page?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    content?: boolean
    color?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAnnotation"]>

  export type DocumentAnnotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    type?: boolean
    page?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    content?: boolean
    color?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAnnotation"]>

  export type DocumentAnnotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    userId?: boolean
    type?: boolean
    page?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    content?: boolean
    color?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentAnnotation"]>

  export type DocumentAnnotationSelectScalar = {
    id?: boolean
    documentId?: boolean
    userId?: boolean
    type?: boolean
    page?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    content?: boolean
    color?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentAnnotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "userId" | "type" | "page" | "x" | "y" | "width" | "height" | "content" | "color" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["documentAnnotation"]>
  export type DocumentAnnotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentAnnotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentAnnotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentAnnotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentAnnotation"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      documentId: number
      userId: number
      type: string
      page: number
      x: number | null
      y: number | null
      width: number | null
      height: number | null
      content: string | null
      color: string | null
      data: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentAnnotation"]>
    composites: {}
  }

  type DocumentAnnotationGetPayload<S extends boolean | null | undefined | DocumentAnnotationDefaultArgs> = $Result.GetResult<Prisma.$DocumentAnnotationPayload, S>

  type DocumentAnnotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentAnnotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentAnnotationCountAggregateInputType | true
    }

  export interface DocumentAnnotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentAnnotation'], meta: { name: 'DocumentAnnotation' } }
    /**
     * Find zero or one DocumentAnnotation that matches the filter.
     * @param {DocumentAnnotationFindUniqueArgs} args - Arguments to find a DocumentAnnotation
     * @example
     * // Get one DocumentAnnotation
     * const documentAnnotation = await prisma.documentAnnotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentAnnotationFindUniqueArgs>(args: SelectSubset<T, DocumentAnnotationFindUniqueArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentAnnotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentAnnotationFindUniqueOrThrowArgs} args - Arguments to find a DocumentAnnotation
     * @example
     * // Get one DocumentAnnotation
     * const documentAnnotation = await prisma.documentAnnotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentAnnotationFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentAnnotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAnnotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationFindFirstArgs} args - Arguments to find a DocumentAnnotation
     * @example
     * // Get one DocumentAnnotation
     * const documentAnnotation = await prisma.documentAnnotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentAnnotationFindFirstArgs>(args?: SelectSubset<T, DocumentAnnotationFindFirstArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAnnotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationFindFirstOrThrowArgs} args - Arguments to find a DocumentAnnotation
     * @example
     * // Get one DocumentAnnotation
     * const documentAnnotation = await prisma.documentAnnotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentAnnotationFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentAnnotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentAnnotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAnnotations
     * const documentAnnotations = await prisma.documentAnnotation.findMany()
     * 
     * // Get first 10 DocumentAnnotations
     * const documentAnnotations = await prisma.documentAnnotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAnnotationWithIdOnly = await prisma.documentAnnotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentAnnotationFindManyArgs>(args?: SelectSubset<T, DocumentAnnotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentAnnotation.
     * @param {DocumentAnnotationCreateArgs} args - Arguments to create a DocumentAnnotation.
     * @example
     * // Create one DocumentAnnotation
     * const DocumentAnnotation = await prisma.documentAnnotation.create({
     *   data: {
     *     // ... data to create a DocumentAnnotation
     *   }
     * })
     * 
     */
    create<T extends DocumentAnnotationCreateArgs>(args: SelectSubset<T, DocumentAnnotationCreateArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentAnnotations.
     * @param {DocumentAnnotationCreateManyArgs} args - Arguments to create many DocumentAnnotations.
     * @example
     * // Create many DocumentAnnotations
     * const documentAnnotation = await prisma.documentAnnotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentAnnotationCreateManyArgs>(args?: SelectSubset<T, DocumentAnnotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentAnnotations and returns the data saved in the database.
     * @param {DocumentAnnotationCreateManyAndReturnArgs} args - Arguments to create many DocumentAnnotations.
     * @example
     * // Create many DocumentAnnotations
     * const documentAnnotation = await prisma.documentAnnotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentAnnotations and only return the `id`
     * const documentAnnotationWithIdOnly = await prisma.documentAnnotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentAnnotationCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentAnnotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentAnnotation.
     * @param {DocumentAnnotationDeleteArgs} args - Arguments to delete one DocumentAnnotation.
     * @example
     * // Delete one DocumentAnnotation
     * const DocumentAnnotation = await prisma.documentAnnotation.delete({
     *   where: {
     *     // ... filter to delete one DocumentAnnotation
     *   }
     * })
     * 
     */
    delete<T extends DocumentAnnotationDeleteArgs>(args: SelectSubset<T, DocumentAnnotationDeleteArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentAnnotation.
     * @param {DocumentAnnotationUpdateArgs} args - Arguments to update one DocumentAnnotation.
     * @example
     * // Update one DocumentAnnotation
     * const documentAnnotation = await prisma.documentAnnotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentAnnotationUpdateArgs>(args: SelectSubset<T, DocumentAnnotationUpdateArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentAnnotations.
     * @param {DocumentAnnotationDeleteManyArgs} args - Arguments to filter DocumentAnnotations to delete.
     * @example
     * // Delete a few DocumentAnnotations
     * const { count } = await prisma.documentAnnotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentAnnotationDeleteManyArgs>(args?: SelectSubset<T, DocumentAnnotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAnnotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAnnotations
     * const documentAnnotation = await prisma.documentAnnotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentAnnotationUpdateManyArgs>(args: SelectSubset<T, DocumentAnnotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAnnotations and returns the data updated in the database.
     * @param {DocumentAnnotationUpdateManyAndReturnArgs} args - Arguments to update many DocumentAnnotations.
     * @example
     * // Update many DocumentAnnotations
     * const documentAnnotation = await prisma.documentAnnotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentAnnotations and only return the `id`
     * const documentAnnotationWithIdOnly = await prisma.documentAnnotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentAnnotationUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentAnnotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentAnnotation.
     * @param {DocumentAnnotationUpsertArgs} args - Arguments to update or create a DocumentAnnotation.
     * @example
     * // Update or create a DocumentAnnotation
     * const documentAnnotation = await prisma.documentAnnotation.upsert({
     *   create: {
     *     // ... data to create a DocumentAnnotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAnnotation we want to update
     *   }
     * })
     */
    upsert<T extends DocumentAnnotationUpsertArgs>(args: SelectSubset<T, DocumentAnnotationUpsertArgs<ExtArgs>>): Prisma__DocumentAnnotationClient<$Result.GetResult<Prisma.$DocumentAnnotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentAnnotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationCountArgs} args - Arguments to filter DocumentAnnotations to count.
     * @example
     * // Count the number of DocumentAnnotations
     * const count = await prisma.documentAnnotation.count({
     *   where: {
     *     // ... the filter for the DocumentAnnotations we want to count
     *   }
     * })
    **/
    count<T extends DocumentAnnotationCountArgs>(
      args?: Subset<T, DocumentAnnotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAnnotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAnnotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAnnotationAggregateArgs>(args: Subset<T, DocumentAnnotationAggregateArgs>): Prisma.PrismaPromise<GetDocumentAnnotationAggregateType<T>>

    /**
     * Group by DocumentAnnotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAnnotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentAnnotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentAnnotationGroupByArgs['orderBy'] }
        : { orderBy?: DocumentAnnotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentAnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentAnnotation model
   */
  readonly fields: DocumentAnnotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentAnnotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentAnnotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentAnnotation model
   */
  interface DocumentAnnotationFieldRefs {
    readonly id: FieldRef<"DocumentAnnotation", 'Int'>
    readonly documentId: FieldRef<"DocumentAnnotation", 'Int'>
    readonly userId: FieldRef<"DocumentAnnotation", 'Int'>
    readonly type: FieldRef<"DocumentAnnotation", 'String'>
    readonly page: FieldRef<"DocumentAnnotation", 'Int'>
    readonly x: FieldRef<"DocumentAnnotation", 'Float'>
    readonly y: FieldRef<"DocumentAnnotation", 'Float'>
    readonly width: FieldRef<"DocumentAnnotation", 'Float'>
    readonly height: FieldRef<"DocumentAnnotation", 'Float'>
    readonly content: FieldRef<"DocumentAnnotation", 'String'>
    readonly color: FieldRef<"DocumentAnnotation", 'String'>
    readonly data: FieldRef<"DocumentAnnotation", 'Json'>
    readonly createdAt: FieldRef<"DocumentAnnotation", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentAnnotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentAnnotation findUnique
   */
  export type DocumentAnnotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAnnotation to fetch.
     */
    where: DocumentAnnotationWhereUniqueInput
  }

  /**
   * DocumentAnnotation findUniqueOrThrow
   */
  export type DocumentAnnotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAnnotation to fetch.
     */
    where: DocumentAnnotationWhereUniqueInput
  }

  /**
   * DocumentAnnotation findFirst
   */
  export type DocumentAnnotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAnnotation to fetch.
     */
    where?: DocumentAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAnnotations to fetch.
     */
    orderBy?: DocumentAnnotationOrderByWithRelationInput | DocumentAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAnnotations.
     */
    cursor?: DocumentAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAnnotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAnnotations.
     */
    distinct?: DocumentAnnotationScalarFieldEnum | DocumentAnnotationScalarFieldEnum[]
  }

  /**
   * DocumentAnnotation findFirstOrThrow
   */
  export type DocumentAnnotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAnnotation to fetch.
     */
    where?: DocumentAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAnnotations to fetch.
     */
    orderBy?: DocumentAnnotationOrderByWithRelationInput | DocumentAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAnnotations.
     */
    cursor?: DocumentAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAnnotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAnnotations.
     */
    distinct?: DocumentAnnotationScalarFieldEnum | DocumentAnnotationScalarFieldEnum[]
  }

  /**
   * DocumentAnnotation findMany
   */
  export type DocumentAnnotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAnnotations to fetch.
     */
    where?: DocumentAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAnnotations to fetch.
     */
    orderBy?: DocumentAnnotationOrderByWithRelationInput | DocumentAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentAnnotations.
     */
    cursor?: DocumentAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAnnotations.
     */
    skip?: number
    distinct?: DocumentAnnotationScalarFieldEnum | DocumentAnnotationScalarFieldEnum[]
  }

  /**
   * DocumentAnnotation create
   */
  export type DocumentAnnotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentAnnotation.
     */
    data: XOR<DocumentAnnotationCreateInput, DocumentAnnotationUncheckedCreateInput>
  }

  /**
   * DocumentAnnotation createMany
   */
  export type DocumentAnnotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentAnnotations.
     */
    data: DocumentAnnotationCreateManyInput | DocumentAnnotationCreateManyInput[]
  }

  /**
   * DocumentAnnotation createManyAndReturn
   */
  export type DocumentAnnotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentAnnotations.
     */
    data: DocumentAnnotationCreateManyInput | DocumentAnnotationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAnnotation update
   */
  export type DocumentAnnotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentAnnotation.
     */
    data: XOR<DocumentAnnotationUpdateInput, DocumentAnnotationUncheckedUpdateInput>
    /**
     * Choose, which DocumentAnnotation to update.
     */
    where: DocumentAnnotationWhereUniqueInput
  }

  /**
   * DocumentAnnotation updateMany
   */
  export type DocumentAnnotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentAnnotations.
     */
    data: XOR<DocumentAnnotationUpdateManyMutationInput, DocumentAnnotationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAnnotations to update
     */
    where?: DocumentAnnotationWhereInput
    /**
     * Limit how many DocumentAnnotations to update.
     */
    limit?: number
  }

  /**
   * DocumentAnnotation updateManyAndReturn
   */
  export type DocumentAnnotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * The data used to update DocumentAnnotations.
     */
    data: XOR<DocumentAnnotationUpdateManyMutationInput, DocumentAnnotationUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAnnotations to update
     */
    where?: DocumentAnnotationWhereInput
    /**
     * Limit how many DocumentAnnotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAnnotation upsert
   */
  export type DocumentAnnotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentAnnotation to update in case it exists.
     */
    where: DocumentAnnotationWhereUniqueInput
    /**
     * In case the DocumentAnnotation found by the `where` argument doesn't exist, create a new DocumentAnnotation with this data.
     */
    create: XOR<DocumentAnnotationCreateInput, DocumentAnnotationUncheckedCreateInput>
    /**
     * In case the DocumentAnnotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentAnnotationUpdateInput, DocumentAnnotationUncheckedUpdateInput>
  }

  /**
   * DocumentAnnotation delete
   */
  export type DocumentAnnotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
    /**
     * Filter which DocumentAnnotation to delete.
     */
    where: DocumentAnnotationWhereUniqueInput
  }

  /**
   * DocumentAnnotation deleteMany
   */
  export type DocumentAnnotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAnnotations to delete
     */
    where?: DocumentAnnotationWhereInput
    /**
     * Limit how many DocumentAnnotations to delete.
     */
    limit?: number
  }

  /**
   * DocumentAnnotation without action
   */
  export type DocumentAnnotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAnnotation
     */
    select?: DocumentAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAnnotation
     */
    omit?: DocumentAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAnnotationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    surname: 'surname',
    position: 'position',
    phone: 'phone',
    email: 'email',
    hiredAt: 'hiredAt',
    terminatedAt: 'terminatedAt',
    notes: 'notes',
    hasDisabilityCertificate: 'hasDisabilityCertificate'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    registrationNumber: 'registrationNumber',
    vehicleType: 'vehicleType',
    capacity: 'capacity',
    fuelType: 'fuelType',
    purchaseDate: 'purchaseDate',
    isActive: 'isActive',
    faultStatus: 'faultStatus'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    unitName: 'unitName',
    notes: 'notes'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const FractionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    color: 'color'
  };

  export type FractionScalarFieldEnum = (typeof FractionScalarFieldEnum)[keyof typeof FractionScalarFieldEnum]


  export const PointScalarFieldEnum: {
    id: 'id',
    type: 'type',
    town: 'town',
    street: 'street',
    number: 'number',
    notes: 'notes',
    companyName: 'companyName',
    activityNotes: 'activityNotes',
    startDate: 'startDate',
    endDate: 'endDate',
    isIndefinite: 'isIndefinite',
    kompostownik: 'kompostownik',
    regionId: 'regionId'
  };

  export type PointScalarFieldEnum = (typeof PointScalarFieldEnum)[keyof typeof PointScalarFieldEnum]


  export const PointFractionScalarFieldEnum: {
    id: 'id',
    pointId: 'pointId',
    fractionId: 'fractionId',
    containerSize: 'containerSize',
    pickupFrequency: 'pickupFrequency'
  };

  export type PointFractionScalarFieldEnum = (typeof PointFractionScalarFieldEnum)[keyof typeof PointFractionScalarFieldEnum]


  export const EmployeeScheduleScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    shift: 'shift',
    customHours: 'customHours',
    colorCode: 'colorCode'
  };

  export type EmployeeScheduleScalarFieldEnum = (typeof EmployeeScheduleScalarFieldEnum)[keyof typeof EmployeeScheduleScalarFieldEnum]


  export const RegionFractionScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    fractionId: 'fractionId'
  };

  export type RegionFractionScalarFieldEnum = (typeof RegionFractionScalarFieldEnum)[keyof typeof RegionFractionScalarFieldEnum]


  export const CalendarEntryScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    fractionId: 'fractionId',
    date: 'date'
  };

  export type CalendarEntryScalarFieldEnum = (typeof CalendarEntryScalarFieldEnum)[keyof typeof CalendarEntryScalarFieldEnum]


  export const DailyAssignmentScalarFieldEnum: {
    id: 'id',
    date: 'date',
    regionId: 'regionId',
    vehicleId: 'vehicleId',
    driverId: 'driverId',
    type: 'type',
    shift: 'shift',
    municipalityId: 'municipalityId',
    equipment: 'equipment',
    workType: 'workType'
  };

  export type DailyAssignmentScalarFieldEnum = (typeof DailyAssignmentScalarFieldEnum)[keyof typeof DailyAssignmentScalarFieldEnum]


  export const DailyAssignmentAssistantScalarFieldEnum: {
    id: 'id',
    dailyAssignmentId: 'dailyAssignmentId',
    employeeId: 'employeeId'
  };

  export type DailyAssignmentAssistantScalarFieldEnum = (typeof DailyAssignmentAssistantScalarFieldEnum)[keyof typeof DailyAssignmentAssistantScalarFieldEnum]


  export const DailyAssignmentFractionScalarFieldEnum: {
    id: 'id',
    dailyAssignmentId: 'dailyAssignmentId',
    fractionId: 'fractionId'
  };

  export type DailyAssignmentFractionScalarFieldEnum = (typeof DailyAssignmentFractionScalarFieldEnum)[keyof typeof DailyAssignmentFractionScalarFieldEnum]


  export const VehicleFaultReportScalarFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    reportedBy: 'reportedBy',
    description: 'description',
    reportedAt: 'reportedAt',
    resolvedAt: 'resolvedAt',
    isResolved: 'isResolved'
  };

  export type VehicleFaultReportScalarFieldEnum = (typeof VehicleFaultReportScalarFieldEnum)[keyof typeof VehicleFaultReportScalarFieldEnum]


  export const WorkOrderScalarFieldEnum: {
    id: 'id',
    type: 'type',
    dateReceived: 'dateReceived',
    realizationDate: 'realizationDate',
    quantity: 'quantity',
    orderNumber: 'orderNumber',
    bagNumber: 'bagNumber',
    executionDate: 'executionDate',
    receivedBy: 'receivedBy',
    address: 'address',
    municipality: 'municipality',
    company: 'company',
    wasteType: 'wasteType',
    rodzaj: 'rodzaj',
    kontener: 'kontener',
    description: 'description',
    notes: 'notes',
    failureReason: 'failureReason',
    vehicle: 'vehicle',
    responsible: 'responsible',
    completed: 'completed',
    zlecenie: 'zlecenie'
  };

  export type WorkOrderScalarFieldEnum = (typeof WorkOrderScalarFieldEnum)[keyof typeof WorkOrderScalarFieldEnum]


  export const MunicipalityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MunicipalityScalarFieldEnum = (typeof MunicipalityScalarFieldEnum)[keyof typeof MunicipalityScalarFieldEnum]


  export const RodzajAbsencjiScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    color: 'color',
    notes: 'notes'
  };

  export type RodzajAbsencjiScalarFieldEnum = (typeof RodzajAbsencjiScalarFieldEnum)[keyof typeof RodzajAbsencjiScalarFieldEnum]


  export const WorkCardEntryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    actualFrom: 'actualFrom',
    actualTo: 'actualTo',
    actualTotal: 'actualTotal',
    absenceTypeId: 'absenceTypeId',
    onCall: 'onCall',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkCardEntryScalarFieldEnum = (typeof WorkCardEntryScalarFieldEnum)[keyof typeof WorkCardEntryScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    contractNumber: 'contractNumber',
    parties: 'parties',
    description: 'description',
    tags: 'tags',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    deletedBy: 'deletedBy',
    deletedAt: 'deletedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentAttachmentScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    isDeleted: 'isDeleted'
  };

  export type DocumentAttachmentScalarFieldEnum = (typeof DocumentAttachmentScalarFieldEnum)[keyof typeof DocumentAttachmentScalarFieldEnum]


  export const DocumentAnnotationScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    userId: 'userId',
    type: 'type',
    page: 'page',
    x: 'x',
    y: 'y',
    width: 'width',
    height: 'height',
    content: 'content',
    color: 'color',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentAnnotationScalarFieldEnum = (typeof DocumentAnnotationScalarFieldEnum)[keyof typeof DocumentAnnotationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DailyAssignmentType'
   */
  export type EnumDailyAssignmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DailyAssignmentType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    uploadedDocuments?: DocumentListRelationFilter
    deletedDocuments?: DocumentListRelationFilter
    uploadedAttachments?: DocumentAttachmentListRelationFilter
    annotations?: DocumentAnnotationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    uploadedDocuments?: DocumentOrderByRelationAggregateInput
    deletedDocuments?: DocumentOrderByRelationAggregateInput
    uploadedAttachments?: DocumentAttachmentOrderByRelationAggregateInput
    annotations?: DocumentAnnotationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    uploadedDocuments?: DocumentListRelationFilter
    deletedDocuments?: DocumentListRelationFilter
    uploadedAttachments?: DocumentAttachmentListRelationFilter
    annotations?: DocumentAnnotationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    name?: StringFilter<"Employee"> | string
    surname?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    phone?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    hiredAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    terminatedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    notes?: StringNullableFilter<"Employee"> | string | null
    hasDisabilityCertificate?: BoolFilter<"Employee"> | boolean
    employeeSchedules?: EmployeeScheduleListRelationFilter
    drivenAssignments?: DailyAssignmentListRelationFilter
    assistantAssignments?: DailyAssignmentAssistantListRelationFilter
    workCardEntries?: WorkCardEntryListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    hiredAt?: SortOrderInput | SortOrder
    terminatedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    hasDisabilityCertificate?: SortOrder
    employeeSchedules?: EmployeeScheduleOrderByRelationAggregateInput
    drivenAssignments?: DailyAssignmentOrderByRelationAggregateInput
    assistantAssignments?: DailyAssignmentAssistantOrderByRelationAggregateInput
    workCardEntries?: WorkCardEntryOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    surname?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    phone?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    hiredAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    terminatedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    notes?: StringNullableFilter<"Employee"> | string | null
    hasDisabilityCertificate?: BoolFilter<"Employee"> | boolean
    employeeSchedules?: EmployeeScheduleListRelationFilter
    drivenAssignments?: DailyAssignmentListRelationFilter
    assistantAssignments?: DailyAssignmentAssistantListRelationFilter
    workCardEntries?: WorkCardEntryListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    hiredAt?: SortOrderInput | SortOrder
    terminatedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    hasDisabilityCertificate?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    name?: StringWithAggregatesFilter<"Employee"> | string
    surname?: StringWithAggregatesFilter<"Employee"> | string
    position?: StringWithAggregatesFilter<"Employee"> | string
    phone?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    hiredAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    terminatedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    hasDisabilityCertificate?: BoolWithAggregatesFilter<"Employee"> | boolean
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    brand?: StringFilter<"Vehicle"> | string
    registrationNumber?: StringFilter<"Vehicle"> | string
    vehicleType?: StringFilter<"Vehicle"> | string
    capacity?: FloatFilter<"Vehicle"> | number
    fuelType?: StringFilter<"Vehicle"> | string
    purchaseDate?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    isActive?: BoolFilter<"Vehicle"> | boolean
    faultStatus?: StringFilter<"Vehicle"> | string
    dailyAssignments?: DailyAssignmentListRelationFilter
    faultReports?: VehicleFaultReportListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    brand?: SortOrder
    registrationNumber?: SortOrder
    vehicleType?: SortOrder
    capacity?: SortOrder
    fuelType?: SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    faultStatus?: SortOrder
    dailyAssignments?: DailyAssignmentOrderByRelationAggregateInput
    faultReports?: VehicleFaultReportOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    registrationNumber?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    brand?: StringFilter<"Vehicle"> | string
    vehicleType?: StringFilter<"Vehicle"> | string
    capacity?: FloatFilter<"Vehicle"> | number
    fuelType?: StringFilter<"Vehicle"> | string
    purchaseDate?: DateTimeNullableFilter<"Vehicle"> | Date | string | null
    isActive?: BoolFilter<"Vehicle"> | boolean
    faultStatus?: StringFilter<"Vehicle"> | string
    dailyAssignments?: DailyAssignmentListRelationFilter
    faultReports?: VehicleFaultReportListRelationFilter
  }, "id" | "registrationNumber">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    registrationNumber?: SortOrder
    vehicleType?: SortOrder
    capacity?: SortOrder
    fuelType?: SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    faultStatus?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vehicle"> | number
    brand?: StringWithAggregatesFilter<"Vehicle"> | string
    registrationNumber?: StringWithAggregatesFilter<"Vehicle"> | string
    vehicleType?: StringWithAggregatesFilter<"Vehicle"> | string
    capacity?: FloatWithAggregatesFilter<"Vehicle"> | number
    fuelType?: StringWithAggregatesFilter<"Vehicle"> | string
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Vehicle"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Vehicle"> | boolean
    faultStatus?: StringWithAggregatesFilter<"Vehicle"> | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    unitName?: StringFilter<"Region"> | string
    notes?: StringNullableFilter<"Region"> | string | null
    points?: PointListRelationFilter
    regionFractions?: RegionFractionListRelationFilter
    calendarEntries?: CalendarEntryListRelationFilter
    dailyAssignments?: DailyAssignmentListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    unitName?: SortOrder
    notes?: SortOrderInput | SortOrder
    points?: PointOrderByRelationAggregateInput
    regionFractions?: RegionFractionOrderByRelationAggregateInput
    calendarEntries?: CalendarEntryOrderByRelationAggregateInput
    dailyAssignments?: DailyAssignmentOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    unitName?: StringFilter<"Region"> | string
    notes?: StringNullableFilter<"Region"> | string | null
    points?: PointListRelationFilter
    regionFractions?: RegionFractionListRelationFilter
    calendarEntries?: CalendarEntryListRelationFilter
    dailyAssignments?: DailyAssignmentListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    unitName?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
    unitName?: StringWithAggregatesFilter<"Region"> | string
    notes?: StringNullableWithAggregatesFilter<"Region"> | string | null
  }

  export type FractionWhereInput = {
    AND?: FractionWhereInput | FractionWhereInput[]
    OR?: FractionWhereInput[]
    NOT?: FractionWhereInput | FractionWhereInput[]
    id?: IntFilter<"Fraction"> | number
    name?: StringFilter<"Fraction"> | string
    code?: StringFilter<"Fraction"> | string
    color?: StringFilter<"Fraction"> | string
    pointFractions?: PointFractionListRelationFilter
    regionFractions?: RegionFractionListRelationFilter
    calendarEntries?: CalendarEntryListRelationFilter
    fractionsInAssignments?: DailyAssignmentFractionListRelationFilter
  }

  export type FractionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    pointFractions?: PointFractionOrderByRelationAggregateInput
    regionFractions?: RegionFractionOrderByRelationAggregateInput
    calendarEntries?: CalendarEntryOrderByRelationAggregateInput
    fractionsInAssignments?: DailyAssignmentFractionOrderByRelationAggregateInput
  }

  export type FractionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FractionWhereInput | FractionWhereInput[]
    OR?: FractionWhereInput[]
    NOT?: FractionWhereInput | FractionWhereInput[]
    name?: StringFilter<"Fraction"> | string
    code?: StringFilter<"Fraction"> | string
    color?: StringFilter<"Fraction"> | string
    pointFractions?: PointFractionListRelationFilter
    regionFractions?: RegionFractionListRelationFilter
    calendarEntries?: CalendarEntryListRelationFilter
    fractionsInAssignments?: DailyAssignmentFractionListRelationFilter
  }, "id">

  export type FractionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    _count?: FractionCountOrderByAggregateInput
    _avg?: FractionAvgOrderByAggregateInput
    _max?: FractionMaxOrderByAggregateInput
    _min?: FractionMinOrderByAggregateInput
    _sum?: FractionSumOrderByAggregateInput
  }

  export type FractionScalarWhereWithAggregatesInput = {
    AND?: FractionScalarWhereWithAggregatesInput | FractionScalarWhereWithAggregatesInput[]
    OR?: FractionScalarWhereWithAggregatesInput[]
    NOT?: FractionScalarWhereWithAggregatesInput | FractionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fraction"> | number
    name?: StringWithAggregatesFilter<"Fraction"> | string
    code?: StringWithAggregatesFilter<"Fraction"> | string
    color?: StringWithAggregatesFilter<"Fraction"> | string
  }

  export type PointWhereInput = {
    AND?: PointWhereInput | PointWhereInput[]
    OR?: PointWhereInput[]
    NOT?: PointWhereInput | PointWhereInput[]
    id?: IntFilter<"Point"> | number
    type?: StringFilter<"Point"> | string
    town?: StringFilter<"Point"> | string
    street?: StringFilter<"Point"> | string
    number?: StringFilter<"Point"> | string
    notes?: StringNullableFilter<"Point"> | string | null
    companyName?: StringNullableFilter<"Point"> | string | null
    activityNotes?: StringNullableFilter<"Point"> | string | null
    startDate?: DateTimeNullableFilter<"Point"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Point"> | Date | string | null
    isIndefinite?: BoolFilter<"Point"> | boolean
    kompostownik?: BoolFilter<"Point"> | boolean
    regionId?: IntNullableFilter<"Point"> | number | null
    region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
    pointFractions?: PointFractionListRelationFilter
  }

  export type PointOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    town?: SortOrder
    street?: SortOrder
    number?: SortOrder
    notes?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    activityNotes?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isIndefinite?: SortOrder
    kompostownik?: SortOrder
    regionId?: SortOrderInput | SortOrder
    region?: RegionOrderByWithRelationInput
    pointFractions?: PointFractionOrderByRelationAggregateInput
  }

  export type PointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PointWhereInput | PointWhereInput[]
    OR?: PointWhereInput[]
    NOT?: PointWhereInput | PointWhereInput[]
    type?: StringFilter<"Point"> | string
    town?: StringFilter<"Point"> | string
    street?: StringFilter<"Point"> | string
    number?: StringFilter<"Point"> | string
    notes?: StringNullableFilter<"Point"> | string | null
    companyName?: StringNullableFilter<"Point"> | string | null
    activityNotes?: StringNullableFilter<"Point"> | string | null
    startDate?: DateTimeNullableFilter<"Point"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Point"> | Date | string | null
    isIndefinite?: BoolFilter<"Point"> | boolean
    kompostownik?: BoolFilter<"Point"> | boolean
    regionId?: IntNullableFilter<"Point"> | number | null
    region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
    pointFractions?: PointFractionListRelationFilter
  }, "id">

  export type PointOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    town?: SortOrder
    street?: SortOrder
    number?: SortOrder
    notes?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    activityNotes?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isIndefinite?: SortOrder
    kompostownik?: SortOrder
    regionId?: SortOrderInput | SortOrder
    _count?: PointCountOrderByAggregateInput
    _avg?: PointAvgOrderByAggregateInput
    _max?: PointMaxOrderByAggregateInput
    _min?: PointMinOrderByAggregateInput
    _sum?: PointSumOrderByAggregateInput
  }

  export type PointScalarWhereWithAggregatesInput = {
    AND?: PointScalarWhereWithAggregatesInput | PointScalarWhereWithAggregatesInput[]
    OR?: PointScalarWhereWithAggregatesInput[]
    NOT?: PointScalarWhereWithAggregatesInput | PointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Point"> | number
    type?: StringWithAggregatesFilter<"Point"> | string
    town?: StringWithAggregatesFilter<"Point"> | string
    street?: StringWithAggregatesFilter<"Point"> | string
    number?: StringWithAggregatesFilter<"Point"> | string
    notes?: StringNullableWithAggregatesFilter<"Point"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"Point"> | string | null
    activityNotes?: StringNullableWithAggregatesFilter<"Point"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Point"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Point"> | Date | string | null
    isIndefinite?: BoolWithAggregatesFilter<"Point"> | boolean
    kompostownik?: BoolWithAggregatesFilter<"Point"> | boolean
    regionId?: IntNullableWithAggregatesFilter<"Point"> | number | null
  }

  export type PointFractionWhereInput = {
    AND?: PointFractionWhereInput | PointFractionWhereInput[]
    OR?: PointFractionWhereInput[]
    NOT?: PointFractionWhereInput | PointFractionWhereInput[]
    id?: IntFilter<"PointFraction"> | number
    pointId?: IntFilter<"PointFraction"> | number
    fractionId?: IntFilter<"PointFraction"> | number
    containerSize?: StringFilter<"PointFraction"> | string
    pickupFrequency?: StringFilter<"PointFraction"> | string
    point?: XOR<PointScalarRelationFilter, PointWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }

  export type PointFractionOrderByWithRelationInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
    containerSize?: SortOrder
    pickupFrequency?: SortOrder
    point?: PointOrderByWithRelationInput
    fraction?: FractionOrderByWithRelationInput
  }

  export type PointFractionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PointFractionWhereInput | PointFractionWhereInput[]
    OR?: PointFractionWhereInput[]
    NOT?: PointFractionWhereInput | PointFractionWhereInput[]
    pointId?: IntFilter<"PointFraction"> | number
    fractionId?: IntFilter<"PointFraction"> | number
    containerSize?: StringFilter<"PointFraction"> | string
    pickupFrequency?: StringFilter<"PointFraction"> | string
    point?: XOR<PointScalarRelationFilter, PointWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }, "id">

  export type PointFractionOrderByWithAggregationInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
    containerSize?: SortOrder
    pickupFrequency?: SortOrder
    _count?: PointFractionCountOrderByAggregateInput
    _avg?: PointFractionAvgOrderByAggregateInput
    _max?: PointFractionMaxOrderByAggregateInput
    _min?: PointFractionMinOrderByAggregateInput
    _sum?: PointFractionSumOrderByAggregateInput
  }

  export type PointFractionScalarWhereWithAggregatesInput = {
    AND?: PointFractionScalarWhereWithAggregatesInput | PointFractionScalarWhereWithAggregatesInput[]
    OR?: PointFractionScalarWhereWithAggregatesInput[]
    NOT?: PointFractionScalarWhereWithAggregatesInput | PointFractionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PointFraction"> | number
    pointId?: IntWithAggregatesFilter<"PointFraction"> | number
    fractionId?: IntWithAggregatesFilter<"PointFraction"> | number
    containerSize?: StringWithAggregatesFilter<"PointFraction"> | string
    pickupFrequency?: StringWithAggregatesFilter<"PointFraction"> | string
  }

  export type EmployeeScheduleWhereInput = {
    AND?: EmployeeScheduleWhereInput | EmployeeScheduleWhereInput[]
    OR?: EmployeeScheduleWhereInput[]
    NOT?: EmployeeScheduleWhereInput | EmployeeScheduleWhereInput[]
    id?: IntFilter<"EmployeeSchedule"> | number
    employeeId?: IntFilter<"EmployeeSchedule"> | number
    date?: DateTimeFilter<"EmployeeSchedule"> | Date | string
    shift?: StringFilter<"EmployeeSchedule"> | string
    customHours?: StringNullableFilter<"EmployeeSchedule"> | string | null
    colorCode?: StringNullableFilter<"EmployeeSchedule"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type EmployeeScheduleOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    shift?: SortOrder
    customHours?: SortOrderInput | SortOrder
    colorCode?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type EmployeeScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeScheduleWhereInput | EmployeeScheduleWhereInput[]
    OR?: EmployeeScheduleWhereInput[]
    NOT?: EmployeeScheduleWhereInput | EmployeeScheduleWhereInput[]
    employeeId?: IntFilter<"EmployeeSchedule"> | number
    date?: DateTimeFilter<"EmployeeSchedule"> | Date | string
    shift?: StringFilter<"EmployeeSchedule"> | string
    customHours?: StringNullableFilter<"EmployeeSchedule"> | string | null
    colorCode?: StringNullableFilter<"EmployeeSchedule"> | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type EmployeeScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    shift?: SortOrder
    customHours?: SortOrderInput | SortOrder
    colorCode?: SortOrderInput | SortOrder
    _count?: EmployeeScheduleCountOrderByAggregateInput
    _avg?: EmployeeScheduleAvgOrderByAggregateInput
    _max?: EmployeeScheduleMaxOrderByAggregateInput
    _min?: EmployeeScheduleMinOrderByAggregateInput
    _sum?: EmployeeScheduleSumOrderByAggregateInput
  }

  export type EmployeeScheduleScalarWhereWithAggregatesInput = {
    AND?: EmployeeScheduleScalarWhereWithAggregatesInput | EmployeeScheduleScalarWhereWithAggregatesInput[]
    OR?: EmployeeScheduleScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScheduleScalarWhereWithAggregatesInput | EmployeeScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeSchedule"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"EmployeeSchedule"> | Date | string
    shift?: StringWithAggregatesFilter<"EmployeeSchedule"> | string
    customHours?: StringNullableWithAggregatesFilter<"EmployeeSchedule"> | string | null
    colorCode?: StringNullableWithAggregatesFilter<"EmployeeSchedule"> | string | null
  }

  export type RegionFractionWhereInput = {
    AND?: RegionFractionWhereInput | RegionFractionWhereInput[]
    OR?: RegionFractionWhereInput[]
    NOT?: RegionFractionWhereInput | RegionFractionWhereInput[]
    id?: IntFilter<"RegionFraction"> | number
    regionId?: IntFilter<"RegionFraction"> | number
    fractionId?: IntFilter<"RegionFraction"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }

  export type RegionFractionOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    region?: RegionOrderByWithRelationInput
    fraction?: FractionOrderByWithRelationInput
  }

  export type RegionFractionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    regionId_fractionId?: RegionFractionRegionIdFractionIdCompoundUniqueInput
    AND?: RegionFractionWhereInput | RegionFractionWhereInput[]
    OR?: RegionFractionWhereInput[]
    NOT?: RegionFractionWhereInput | RegionFractionWhereInput[]
    regionId?: IntFilter<"RegionFraction"> | number
    fractionId?: IntFilter<"RegionFraction"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }, "id" | "regionId_fractionId">

  export type RegionFractionOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    _count?: RegionFractionCountOrderByAggregateInput
    _avg?: RegionFractionAvgOrderByAggregateInput
    _max?: RegionFractionMaxOrderByAggregateInput
    _min?: RegionFractionMinOrderByAggregateInput
    _sum?: RegionFractionSumOrderByAggregateInput
  }

  export type RegionFractionScalarWhereWithAggregatesInput = {
    AND?: RegionFractionScalarWhereWithAggregatesInput | RegionFractionScalarWhereWithAggregatesInput[]
    OR?: RegionFractionScalarWhereWithAggregatesInput[]
    NOT?: RegionFractionScalarWhereWithAggregatesInput | RegionFractionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegionFraction"> | number
    regionId?: IntWithAggregatesFilter<"RegionFraction"> | number
    fractionId?: IntWithAggregatesFilter<"RegionFraction"> | number
  }

  export type CalendarEntryWhereInput = {
    AND?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    OR?: CalendarEntryWhereInput[]
    NOT?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    id?: IntFilter<"CalendarEntry"> | number
    regionId?: IntFilter<"CalendarEntry"> | number
    fractionId?: IntFilter<"CalendarEntry"> | number
    date?: DateTimeFilter<"CalendarEntry"> | Date | string
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }

  export type CalendarEntryOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    date?: SortOrder
    region?: RegionOrderByWithRelationInput
    fraction?: FractionOrderByWithRelationInput
  }

  export type CalendarEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    regionId_fractionId_date?: CalendarEntryRegionIdFractionIdDateCompoundUniqueInput
    AND?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    OR?: CalendarEntryWhereInput[]
    NOT?: CalendarEntryWhereInput | CalendarEntryWhereInput[]
    regionId?: IntFilter<"CalendarEntry"> | number
    fractionId?: IntFilter<"CalendarEntry"> | number
    date?: DateTimeFilter<"CalendarEntry"> | Date | string
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }, "id" | "regionId_fractionId_date">

  export type CalendarEntryOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    date?: SortOrder
    _count?: CalendarEntryCountOrderByAggregateInput
    _avg?: CalendarEntryAvgOrderByAggregateInput
    _max?: CalendarEntryMaxOrderByAggregateInput
    _min?: CalendarEntryMinOrderByAggregateInput
    _sum?: CalendarEntrySumOrderByAggregateInput
  }

  export type CalendarEntryScalarWhereWithAggregatesInput = {
    AND?: CalendarEntryScalarWhereWithAggregatesInput | CalendarEntryScalarWhereWithAggregatesInput[]
    OR?: CalendarEntryScalarWhereWithAggregatesInput[]
    NOT?: CalendarEntryScalarWhereWithAggregatesInput | CalendarEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalendarEntry"> | number
    regionId?: IntWithAggregatesFilter<"CalendarEntry"> | number
    fractionId?: IntWithAggregatesFilter<"CalendarEntry"> | number
    date?: DateTimeWithAggregatesFilter<"CalendarEntry"> | Date | string
  }

  export type DailyAssignmentWhereInput = {
    AND?: DailyAssignmentWhereInput | DailyAssignmentWhereInput[]
    OR?: DailyAssignmentWhereInput[]
    NOT?: DailyAssignmentWhereInput | DailyAssignmentWhereInput[]
    id?: IntFilter<"DailyAssignment"> | number
    date?: DateTimeFilter<"DailyAssignment"> | Date | string
    regionId?: IntFilter<"DailyAssignment"> | number
    vehicleId?: IntFilter<"DailyAssignment"> | number
    driverId?: IntNullableFilter<"DailyAssignment"> | number | null
    type?: EnumDailyAssignmentTypeFilter<"DailyAssignment"> | $Enums.DailyAssignmentType
    shift?: StringFilter<"DailyAssignment"> | string
    municipalityId?: IntNullableFilter<"DailyAssignment"> | number | null
    equipment?: JsonNullableFilter<"DailyAssignment">
    workType?: StringNullableFilter<"DailyAssignment"> | string | null
    municipality?: XOR<MunicipalityNullableScalarRelationFilter, MunicipalityWhereInput> | null
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
    driver?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    assistants?: DailyAssignmentAssistantListRelationFilter
    fractions?: DailyAssignmentFractionListRelationFilter
  }

  export type DailyAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrderInput | SortOrder
    type?: SortOrder
    shift?: SortOrder
    municipalityId?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    workType?: SortOrderInput | SortOrder
    municipality?: MunicipalityOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    driver?: EmployeeOrderByWithRelationInput
    assistants?: DailyAssignmentAssistantOrderByRelationAggregateInput
    fractions?: DailyAssignmentFractionOrderByRelationAggregateInput
  }

  export type DailyAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyAssignmentWhereInput | DailyAssignmentWhereInput[]
    OR?: DailyAssignmentWhereInput[]
    NOT?: DailyAssignmentWhereInput | DailyAssignmentWhereInput[]
    date?: DateTimeFilter<"DailyAssignment"> | Date | string
    regionId?: IntFilter<"DailyAssignment"> | number
    vehicleId?: IntFilter<"DailyAssignment"> | number
    driverId?: IntNullableFilter<"DailyAssignment"> | number | null
    type?: EnumDailyAssignmentTypeFilter<"DailyAssignment"> | $Enums.DailyAssignmentType
    shift?: StringFilter<"DailyAssignment"> | string
    municipalityId?: IntNullableFilter<"DailyAssignment"> | number | null
    equipment?: JsonNullableFilter<"DailyAssignment">
    workType?: StringNullableFilter<"DailyAssignment"> | string | null
    municipality?: XOR<MunicipalityNullableScalarRelationFilter, MunicipalityWhereInput> | null
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
    driver?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    assistants?: DailyAssignmentAssistantListRelationFilter
    fractions?: DailyAssignmentFractionListRelationFilter
  }, "id">

  export type DailyAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrderInput | SortOrder
    type?: SortOrder
    shift?: SortOrder
    municipalityId?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    workType?: SortOrderInput | SortOrder
    _count?: DailyAssignmentCountOrderByAggregateInput
    _avg?: DailyAssignmentAvgOrderByAggregateInput
    _max?: DailyAssignmentMaxOrderByAggregateInput
    _min?: DailyAssignmentMinOrderByAggregateInput
    _sum?: DailyAssignmentSumOrderByAggregateInput
  }

  export type DailyAssignmentScalarWhereWithAggregatesInput = {
    AND?: DailyAssignmentScalarWhereWithAggregatesInput | DailyAssignmentScalarWhereWithAggregatesInput[]
    OR?: DailyAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DailyAssignmentScalarWhereWithAggregatesInput | DailyAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyAssignment"> | number
    date?: DateTimeWithAggregatesFilter<"DailyAssignment"> | Date | string
    regionId?: IntWithAggregatesFilter<"DailyAssignment"> | number
    vehicleId?: IntWithAggregatesFilter<"DailyAssignment"> | number
    driverId?: IntNullableWithAggregatesFilter<"DailyAssignment"> | number | null
    type?: EnumDailyAssignmentTypeWithAggregatesFilter<"DailyAssignment"> | $Enums.DailyAssignmentType
    shift?: StringWithAggregatesFilter<"DailyAssignment"> | string
    municipalityId?: IntNullableWithAggregatesFilter<"DailyAssignment"> | number | null
    equipment?: JsonNullableWithAggregatesFilter<"DailyAssignment">
    workType?: StringNullableWithAggregatesFilter<"DailyAssignment"> | string | null
  }

  export type DailyAssignmentAssistantWhereInput = {
    AND?: DailyAssignmentAssistantWhereInput | DailyAssignmentAssistantWhereInput[]
    OR?: DailyAssignmentAssistantWhereInput[]
    NOT?: DailyAssignmentAssistantWhereInput | DailyAssignmentAssistantWhereInput[]
    id?: IntFilter<"DailyAssignmentAssistant"> | number
    dailyAssignmentId?: IntFilter<"DailyAssignmentAssistant"> | number
    employeeId?: IntFilter<"DailyAssignmentAssistant"> | number
    dailyAssignment?: XOR<DailyAssignmentScalarRelationFilter, DailyAssignmentWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type DailyAssignmentAssistantOrderByWithRelationInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
    dailyAssignment?: DailyAssignmentOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type DailyAssignmentAssistantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyAssignmentAssistantWhereInput | DailyAssignmentAssistantWhereInput[]
    OR?: DailyAssignmentAssistantWhereInput[]
    NOT?: DailyAssignmentAssistantWhereInput | DailyAssignmentAssistantWhereInput[]
    dailyAssignmentId?: IntFilter<"DailyAssignmentAssistant"> | number
    employeeId?: IntFilter<"DailyAssignmentAssistant"> | number
    dailyAssignment?: XOR<DailyAssignmentScalarRelationFilter, DailyAssignmentWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type DailyAssignmentAssistantOrderByWithAggregationInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
    _count?: DailyAssignmentAssistantCountOrderByAggregateInput
    _avg?: DailyAssignmentAssistantAvgOrderByAggregateInput
    _max?: DailyAssignmentAssistantMaxOrderByAggregateInput
    _min?: DailyAssignmentAssistantMinOrderByAggregateInput
    _sum?: DailyAssignmentAssistantSumOrderByAggregateInput
  }

  export type DailyAssignmentAssistantScalarWhereWithAggregatesInput = {
    AND?: DailyAssignmentAssistantScalarWhereWithAggregatesInput | DailyAssignmentAssistantScalarWhereWithAggregatesInput[]
    OR?: DailyAssignmentAssistantScalarWhereWithAggregatesInput[]
    NOT?: DailyAssignmentAssistantScalarWhereWithAggregatesInput | DailyAssignmentAssistantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyAssignmentAssistant"> | number
    dailyAssignmentId?: IntWithAggregatesFilter<"DailyAssignmentAssistant"> | number
    employeeId?: IntWithAggregatesFilter<"DailyAssignmentAssistant"> | number
  }

  export type DailyAssignmentFractionWhereInput = {
    AND?: DailyAssignmentFractionWhereInput | DailyAssignmentFractionWhereInput[]
    OR?: DailyAssignmentFractionWhereInput[]
    NOT?: DailyAssignmentFractionWhereInput | DailyAssignmentFractionWhereInput[]
    id?: IntFilter<"DailyAssignmentFraction"> | number
    dailyAssignmentId?: IntFilter<"DailyAssignmentFraction"> | number
    fractionId?: IntFilter<"DailyAssignmentFraction"> | number
    dailyAssignment?: XOR<DailyAssignmentScalarRelationFilter, DailyAssignmentWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }

  export type DailyAssignmentFractionOrderByWithRelationInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
    dailyAssignment?: DailyAssignmentOrderByWithRelationInput
    fraction?: FractionOrderByWithRelationInput
  }

  export type DailyAssignmentFractionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyAssignmentFractionWhereInput | DailyAssignmentFractionWhereInput[]
    OR?: DailyAssignmentFractionWhereInput[]
    NOT?: DailyAssignmentFractionWhereInput | DailyAssignmentFractionWhereInput[]
    dailyAssignmentId?: IntFilter<"DailyAssignmentFraction"> | number
    fractionId?: IntFilter<"DailyAssignmentFraction"> | number
    dailyAssignment?: XOR<DailyAssignmentScalarRelationFilter, DailyAssignmentWhereInput>
    fraction?: XOR<FractionScalarRelationFilter, FractionWhereInput>
  }, "id">

  export type DailyAssignmentFractionOrderByWithAggregationInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
    _count?: DailyAssignmentFractionCountOrderByAggregateInput
    _avg?: DailyAssignmentFractionAvgOrderByAggregateInput
    _max?: DailyAssignmentFractionMaxOrderByAggregateInput
    _min?: DailyAssignmentFractionMinOrderByAggregateInput
    _sum?: DailyAssignmentFractionSumOrderByAggregateInput
  }

  export type DailyAssignmentFractionScalarWhereWithAggregatesInput = {
    AND?: DailyAssignmentFractionScalarWhereWithAggregatesInput | DailyAssignmentFractionScalarWhereWithAggregatesInput[]
    OR?: DailyAssignmentFractionScalarWhereWithAggregatesInput[]
    NOT?: DailyAssignmentFractionScalarWhereWithAggregatesInput | DailyAssignmentFractionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyAssignmentFraction"> | number
    dailyAssignmentId?: IntWithAggregatesFilter<"DailyAssignmentFraction"> | number
    fractionId?: IntWithAggregatesFilter<"DailyAssignmentFraction"> | number
  }

  export type VehicleFaultReportWhereInput = {
    AND?: VehicleFaultReportWhereInput | VehicleFaultReportWhereInput[]
    OR?: VehicleFaultReportWhereInput[]
    NOT?: VehicleFaultReportWhereInput | VehicleFaultReportWhereInput[]
    id?: IntFilter<"VehicleFaultReport"> | number
    vehicleId?: IntFilter<"VehicleFaultReport"> | number
    reportedBy?: StringFilter<"VehicleFaultReport"> | string
    description?: StringNullableFilter<"VehicleFaultReport"> | string | null
    reportedAt?: DateTimeFilter<"VehicleFaultReport"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"VehicleFaultReport"> | Date | string | null
    isResolved?: BoolFilter<"VehicleFaultReport"> | boolean
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type VehicleFaultReportOrderByWithRelationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    reportedBy?: SortOrder
    description?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type VehicleFaultReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VehicleFaultReportWhereInput | VehicleFaultReportWhereInput[]
    OR?: VehicleFaultReportWhereInput[]
    NOT?: VehicleFaultReportWhereInput | VehicleFaultReportWhereInput[]
    vehicleId?: IntFilter<"VehicleFaultReport"> | number
    reportedBy?: StringFilter<"VehicleFaultReport"> | string
    description?: StringNullableFilter<"VehicleFaultReport"> | string | null
    reportedAt?: DateTimeFilter<"VehicleFaultReport"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"VehicleFaultReport"> | Date | string | null
    isResolved?: BoolFilter<"VehicleFaultReport"> | boolean
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "id">

  export type VehicleFaultReportOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    reportedBy?: SortOrder
    description?: SortOrderInput | SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    _count?: VehicleFaultReportCountOrderByAggregateInput
    _avg?: VehicleFaultReportAvgOrderByAggregateInput
    _max?: VehicleFaultReportMaxOrderByAggregateInput
    _min?: VehicleFaultReportMinOrderByAggregateInput
    _sum?: VehicleFaultReportSumOrderByAggregateInput
  }

  export type VehicleFaultReportScalarWhereWithAggregatesInput = {
    AND?: VehicleFaultReportScalarWhereWithAggregatesInput | VehicleFaultReportScalarWhereWithAggregatesInput[]
    OR?: VehicleFaultReportScalarWhereWithAggregatesInput[]
    NOT?: VehicleFaultReportScalarWhereWithAggregatesInput | VehicleFaultReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VehicleFaultReport"> | number
    vehicleId?: IntWithAggregatesFilter<"VehicleFaultReport"> | number
    reportedBy?: StringWithAggregatesFilter<"VehicleFaultReport"> | string
    description?: StringNullableWithAggregatesFilter<"VehicleFaultReport"> | string | null
    reportedAt?: DateTimeWithAggregatesFilter<"VehicleFaultReport"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"VehicleFaultReport"> | Date | string | null
    isResolved?: BoolWithAggregatesFilter<"VehicleFaultReport"> | boolean
  }

  export type WorkOrderWhereInput = {
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    id?: IntFilter<"WorkOrder"> | number
    type?: StringFilter<"WorkOrder"> | string
    dateReceived?: DateTimeFilter<"WorkOrder"> | Date | string
    realizationDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    quantity?: IntNullableFilter<"WorkOrder"> | number | null
    orderNumber?: StringNullableFilter<"WorkOrder"> | string | null
    bagNumber?: StringNullableFilter<"WorkOrder"> | string | null
    executionDate?: DateTimeFilter<"WorkOrder"> | Date | string
    receivedBy?: StringFilter<"WorkOrder"> | string
    address?: StringFilter<"WorkOrder"> | string
    municipality?: StringNullableFilter<"WorkOrder"> | string | null
    company?: StringNullableFilter<"WorkOrder"> | string | null
    wasteType?: StringNullableFilter<"WorkOrder"> | string | null
    rodzaj?: StringNullableFilter<"WorkOrder"> | string | null
    kontener?: StringNullableFilter<"WorkOrder"> | string | null
    description?: StringNullableFilter<"WorkOrder"> | string | null
    notes?: StringNullableFilter<"WorkOrder"> | string | null
    failureReason?: StringNullableFilter<"WorkOrder"> | string | null
    vehicle?: StringNullableFilter<"WorkOrder"> | string | null
    responsible?: StringNullableFilter<"WorkOrder"> | string | null
    completed?: BoolFilter<"WorkOrder"> | boolean
    zlecenie?: StringNullableFilter<"WorkOrder"> | string | null
  }

  export type WorkOrderOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    dateReceived?: SortOrder
    realizationDate?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    orderNumber?: SortOrderInput | SortOrder
    bagNumber?: SortOrderInput | SortOrder
    executionDate?: SortOrder
    receivedBy?: SortOrder
    address?: SortOrder
    municipality?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    wasteType?: SortOrderInput | SortOrder
    rodzaj?: SortOrderInput | SortOrder
    kontener?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    vehicle?: SortOrderInput | SortOrder
    responsible?: SortOrderInput | SortOrder
    completed?: SortOrder
    zlecenie?: SortOrderInput | SortOrder
  }

  export type WorkOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    type?: StringFilter<"WorkOrder"> | string
    dateReceived?: DateTimeFilter<"WorkOrder"> | Date | string
    realizationDate?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    quantity?: IntNullableFilter<"WorkOrder"> | number | null
    orderNumber?: StringNullableFilter<"WorkOrder"> | string | null
    bagNumber?: StringNullableFilter<"WorkOrder"> | string | null
    executionDate?: DateTimeFilter<"WorkOrder"> | Date | string
    receivedBy?: StringFilter<"WorkOrder"> | string
    address?: StringFilter<"WorkOrder"> | string
    municipality?: StringNullableFilter<"WorkOrder"> | string | null
    company?: StringNullableFilter<"WorkOrder"> | string | null
    wasteType?: StringNullableFilter<"WorkOrder"> | string | null
    rodzaj?: StringNullableFilter<"WorkOrder"> | string | null
    kontener?: StringNullableFilter<"WorkOrder"> | string | null
    description?: StringNullableFilter<"WorkOrder"> | string | null
    notes?: StringNullableFilter<"WorkOrder"> | string | null
    failureReason?: StringNullableFilter<"WorkOrder"> | string | null
    vehicle?: StringNullableFilter<"WorkOrder"> | string | null
    responsible?: StringNullableFilter<"WorkOrder"> | string | null
    completed?: BoolFilter<"WorkOrder"> | boolean
    zlecenie?: StringNullableFilter<"WorkOrder"> | string | null
  }, "id">

  export type WorkOrderOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    dateReceived?: SortOrder
    realizationDate?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    orderNumber?: SortOrderInput | SortOrder
    bagNumber?: SortOrderInput | SortOrder
    executionDate?: SortOrder
    receivedBy?: SortOrder
    address?: SortOrder
    municipality?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    wasteType?: SortOrderInput | SortOrder
    rodzaj?: SortOrderInput | SortOrder
    kontener?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    vehicle?: SortOrderInput | SortOrder
    responsible?: SortOrderInput | SortOrder
    completed?: SortOrder
    zlecenie?: SortOrderInput | SortOrder
    _count?: WorkOrderCountOrderByAggregateInput
    _avg?: WorkOrderAvgOrderByAggregateInput
    _max?: WorkOrderMaxOrderByAggregateInput
    _min?: WorkOrderMinOrderByAggregateInput
    _sum?: WorkOrderSumOrderByAggregateInput
  }

  export type WorkOrderScalarWhereWithAggregatesInput = {
    AND?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    OR?: WorkOrderScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkOrder"> | number
    type?: StringWithAggregatesFilter<"WorkOrder"> | string
    dateReceived?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
    realizationDate?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    quantity?: IntNullableWithAggregatesFilter<"WorkOrder"> | number | null
    orderNumber?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    bagNumber?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    executionDate?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
    receivedBy?: StringWithAggregatesFilter<"WorkOrder"> | string
    address?: StringWithAggregatesFilter<"WorkOrder"> | string
    municipality?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    company?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    wasteType?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    rodzaj?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    kontener?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    description?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    vehicle?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    responsible?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    completed?: BoolWithAggregatesFilter<"WorkOrder"> | boolean
    zlecenie?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
  }

  export type MunicipalityWhereInput = {
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    id?: IntFilter<"Municipality"> | number
    name?: StringFilter<"Municipality"> | string
    dailyAssignments?: DailyAssignmentListRelationFilter
  }

  export type MunicipalityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    dailyAssignments?: DailyAssignmentOrderByRelationAggregateInput
  }

  export type MunicipalityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    name?: StringFilter<"Municipality"> | string
    dailyAssignments?: DailyAssignmentListRelationFilter
  }, "id">

  export type MunicipalityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MunicipalityCountOrderByAggregateInput
    _avg?: MunicipalityAvgOrderByAggregateInput
    _max?: MunicipalityMaxOrderByAggregateInput
    _min?: MunicipalityMinOrderByAggregateInput
    _sum?: MunicipalitySumOrderByAggregateInput
  }

  export type MunicipalityScalarWhereWithAggregatesInput = {
    AND?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    OR?: MunicipalityScalarWhereWithAggregatesInput[]
    NOT?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Municipality"> | number
    name?: StringWithAggregatesFilter<"Municipality"> | string
  }

  export type RodzajAbsencjiWhereInput = {
    AND?: RodzajAbsencjiWhereInput | RodzajAbsencjiWhereInput[]
    OR?: RodzajAbsencjiWhereInput[]
    NOT?: RodzajAbsencjiWhereInput | RodzajAbsencjiWhereInput[]
    id?: IntFilter<"RodzajAbsencji"> | number
    name?: StringFilter<"RodzajAbsencji"> | string
    code?: StringNullableFilter<"RodzajAbsencji"> | string | null
    color?: StringNullableFilter<"RodzajAbsencji"> | string | null
    notes?: StringNullableFilter<"RodzajAbsencji"> | string | null
    workCardEntries?: WorkCardEntryListRelationFilter
  }

  export type RodzajAbsencjiOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    workCardEntries?: WorkCardEntryOrderByRelationAggregateInput
  }

  export type RodzajAbsencjiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RodzajAbsencjiWhereInput | RodzajAbsencjiWhereInput[]
    OR?: RodzajAbsencjiWhereInput[]
    NOT?: RodzajAbsencjiWhereInput | RodzajAbsencjiWhereInput[]
    name?: StringFilter<"RodzajAbsencji"> | string
    code?: StringNullableFilter<"RodzajAbsencji"> | string | null
    color?: StringNullableFilter<"RodzajAbsencji"> | string | null
    notes?: StringNullableFilter<"RodzajAbsencji"> | string | null
    workCardEntries?: WorkCardEntryListRelationFilter
  }, "id">

  export type RodzajAbsencjiOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: RodzajAbsencjiCountOrderByAggregateInput
    _avg?: RodzajAbsencjiAvgOrderByAggregateInput
    _max?: RodzajAbsencjiMaxOrderByAggregateInput
    _min?: RodzajAbsencjiMinOrderByAggregateInput
    _sum?: RodzajAbsencjiSumOrderByAggregateInput
  }

  export type RodzajAbsencjiScalarWhereWithAggregatesInput = {
    AND?: RodzajAbsencjiScalarWhereWithAggregatesInput | RodzajAbsencjiScalarWhereWithAggregatesInput[]
    OR?: RodzajAbsencjiScalarWhereWithAggregatesInput[]
    NOT?: RodzajAbsencjiScalarWhereWithAggregatesInput | RodzajAbsencjiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RodzajAbsencji"> | number
    name?: StringWithAggregatesFilter<"RodzajAbsencji"> | string
    code?: StringNullableWithAggregatesFilter<"RodzajAbsencji"> | string | null
    color?: StringNullableWithAggregatesFilter<"RodzajAbsencji"> | string | null
    notes?: StringNullableWithAggregatesFilter<"RodzajAbsencji"> | string | null
  }

  export type WorkCardEntryWhereInput = {
    AND?: WorkCardEntryWhereInput | WorkCardEntryWhereInput[]
    OR?: WorkCardEntryWhereInput[]
    NOT?: WorkCardEntryWhereInput | WorkCardEntryWhereInput[]
    id?: IntFilter<"WorkCardEntry"> | number
    employeeId?: IntFilter<"WorkCardEntry"> | number
    date?: DateTimeFilter<"WorkCardEntry"> | Date | string
    actualFrom?: StringNullableFilter<"WorkCardEntry"> | string | null
    actualTo?: StringNullableFilter<"WorkCardEntry"> | string | null
    actualTotal?: FloatNullableFilter<"WorkCardEntry"> | number | null
    absenceTypeId?: IntNullableFilter<"WorkCardEntry"> | number | null
    onCall?: BoolFilter<"WorkCardEntry"> | boolean
    createdAt?: DateTimeFilter<"WorkCardEntry"> | Date | string
    updatedAt?: DateTimeFilter<"WorkCardEntry"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    absenceType?: XOR<RodzajAbsencjiNullableScalarRelationFilter, RodzajAbsencjiWhereInput> | null
  }

  export type WorkCardEntryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    actualFrom?: SortOrderInput | SortOrder
    actualTo?: SortOrderInput | SortOrder
    actualTotal?: SortOrderInput | SortOrder
    absenceTypeId?: SortOrderInput | SortOrder
    onCall?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    absenceType?: RodzajAbsencjiOrderByWithRelationInput
  }

  export type WorkCardEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_date?: WorkCardEntryEmployeeIdDateCompoundUniqueInput
    AND?: WorkCardEntryWhereInput | WorkCardEntryWhereInput[]
    OR?: WorkCardEntryWhereInput[]
    NOT?: WorkCardEntryWhereInput | WorkCardEntryWhereInput[]
    employeeId?: IntFilter<"WorkCardEntry"> | number
    date?: DateTimeFilter<"WorkCardEntry"> | Date | string
    actualFrom?: StringNullableFilter<"WorkCardEntry"> | string | null
    actualTo?: StringNullableFilter<"WorkCardEntry"> | string | null
    actualTotal?: FloatNullableFilter<"WorkCardEntry"> | number | null
    absenceTypeId?: IntNullableFilter<"WorkCardEntry"> | number | null
    onCall?: BoolFilter<"WorkCardEntry"> | boolean
    createdAt?: DateTimeFilter<"WorkCardEntry"> | Date | string
    updatedAt?: DateTimeFilter<"WorkCardEntry"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    absenceType?: XOR<RodzajAbsencjiNullableScalarRelationFilter, RodzajAbsencjiWhereInput> | null
  }, "id" | "employeeId_date">

  export type WorkCardEntryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    actualFrom?: SortOrderInput | SortOrder
    actualTo?: SortOrderInput | SortOrder
    actualTotal?: SortOrderInput | SortOrder
    absenceTypeId?: SortOrderInput | SortOrder
    onCall?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkCardEntryCountOrderByAggregateInput
    _avg?: WorkCardEntryAvgOrderByAggregateInput
    _max?: WorkCardEntryMaxOrderByAggregateInput
    _min?: WorkCardEntryMinOrderByAggregateInput
    _sum?: WorkCardEntrySumOrderByAggregateInput
  }

  export type WorkCardEntryScalarWhereWithAggregatesInput = {
    AND?: WorkCardEntryScalarWhereWithAggregatesInput | WorkCardEntryScalarWhereWithAggregatesInput[]
    OR?: WorkCardEntryScalarWhereWithAggregatesInput[]
    NOT?: WorkCardEntryScalarWhereWithAggregatesInput | WorkCardEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkCardEntry"> | number
    employeeId?: IntWithAggregatesFilter<"WorkCardEntry"> | number
    date?: DateTimeWithAggregatesFilter<"WorkCardEntry"> | Date | string
    actualFrom?: StringNullableWithAggregatesFilter<"WorkCardEntry"> | string | null
    actualTo?: StringNullableWithAggregatesFilter<"WorkCardEntry"> | string | null
    actualTotal?: FloatNullableWithAggregatesFilter<"WorkCardEntry"> | number | null
    absenceTypeId?: IntNullableWithAggregatesFilter<"WorkCardEntry"> | number | null
    onCall?: BoolWithAggregatesFilter<"WorkCardEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkCardEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkCardEntry"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    contractNumber?: StringNullableFilter<"Document"> | string | null
    parties?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    tags?: StringNullableFilter<"Document"> | string | null
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    uploadedBy?: IntFilter<"Document"> | number
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    isDeleted?: BoolFilter<"Document"> | boolean
    deletedBy?: IntNullableFilter<"Document"> | number | null
    deletedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    attachments?: DocumentAttachmentListRelationFilter
    annotations?: DocumentAnnotationListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    contractNumber?: SortOrderInput | SortOrder
    parties?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    uploader?: UserOrderByWithRelationInput
    deleter?: UserOrderByWithRelationInput
    attachments?: DocumentAttachmentOrderByRelationAggregateInput
    annotations?: DocumentAnnotationOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    contractNumber?: StringNullableFilter<"Document"> | string | null
    parties?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    tags?: StringNullableFilter<"Document"> | string | null
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    uploadedBy?: IntFilter<"Document"> | number
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    isDeleted?: BoolFilter<"Document"> | boolean
    deletedBy?: IntNullableFilter<"Document"> | number | null
    deletedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    attachments?: DocumentAttachmentListRelationFilter
    annotations?: DocumentAnnotationListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    contractNumber?: SortOrderInput | SortOrder
    parties?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    contractNumber?: StringNullableWithAggregatesFilter<"Document"> | string | null
    parties?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    tags?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileName?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    fileSize?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    uploadedBy?: IntWithAggregatesFilter<"Document"> | number
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Document"> | boolean
    deletedBy?: IntNullableWithAggregatesFilter<"Document"> | number | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
  }

  export type DocumentAttachmentWhereInput = {
    AND?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    OR?: DocumentAttachmentWhereInput[]
    NOT?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    id?: IntFilter<"DocumentAttachment"> | number
    documentId?: IntFilter<"DocumentAttachment"> | number
    fileName?: StringFilter<"DocumentAttachment"> | string
    filePath?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    mimeType?: StringFilter<"DocumentAttachment"> | string
    uploadedBy?: IntFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    isDeleted?: BoolFilter<"DocumentAttachment"> | boolean
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    isDeleted?: SortOrder
    document?: DocumentOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type DocumentAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    OR?: DocumentAttachmentWhereInput[]
    NOT?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    documentId?: IntFilter<"DocumentAttachment"> | number
    fileName?: StringFilter<"DocumentAttachment"> | string
    filePath?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    mimeType?: StringFilter<"DocumentAttachment"> | string
    uploadedBy?: IntFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    isDeleted?: BoolFilter<"DocumentAttachment"> | boolean
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    isDeleted?: SortOrder
    _count?: DocumentAttachmentCountOrderByAggregateInput
    _avg?: DocumentAttachmentAvgOrderByAggregateInput
    _max?: DocumentAttachmentMaxOrderByAggregateInput
    _min?: DocumentAttachmentMinOrderByAggregateInput
    _sum?: DocumentAttachmentSumOrderByAggregateInput
  }

  export type DocumentAttachmentScalarWhereWithAggregatesInput = {
    AND?: DocumentAttachmentScalarWhereWithAggregatesInput | DocumentAttachmentScalarWhereWithAggregatesInput[]
    OR?: DocumentAttachmentScalarWhereWithAggregatesInput[]
    NOT?: DocumentAttachmentScalarWhereWithAggregatesInput | DocumentAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DocumentAttachment"> | number
    documentId?: IntWithAggregatesFilter<"DocumentAttachment"> | number
    fileName?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    filePath?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"DocumentAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    uploadedBy?: IntWithAggregatesFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeWithAggregatesFilter<"DocumentAttachment"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"DocumentAttachment"> | boolean
  }

  export type DocumentAnnotationWhereInput = {
    AND?: DocumentAnnotationWhereInput | DocumentAnnotationWhereInput[]
    OR?: DocumentAnnotationWhereInput[]
    NOT?: DocumentAnnotationWhereInput | DocumentAnnotationWhereInput[]
    id?: IntFilter<"DocumentAnnotation"> | number
    documentId?: IntFilter<"DocumentAnnotation"> | number
    userId?: IntFilter<"DocumentAnnotation"> | number
    type?: StringFilter<"DocumentAnnotation"> | string
    page?: IntFilter<"DocumentAnnotation"> | number
    x?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    y?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    width?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    height?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    content?: StringNullableFilter<"DocumentAnnotation"> | string | null
    color?: StringNullableFilter<"DocumentAnnotation"> | string | null
    data?: JsonNullableFilter<"DocumentAnnotation">
    createdAt?: DateTimeFilter<"DocumentAnnotation"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentAnnotation"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentAnnotationOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    page?: SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DocumentAnnotationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentAnnotationWhereInput | DocumentAnnotationWhereInput[]
    OR?: DocumentAnnotationWhereInput[]
    NOT?: DocumentAnnotationWhereInput | DocumentAnnotationWhereInput[]
    documentId?: IntFilter<"DocumentAnnotation"> | number
    userId?: IntFilter<"DocumentAnnotation"> | number
    type?: StringFilter<"DocumentAnnotation"> | string
    page?: IntFilter<"DocumentAnnotation"> | number
    x?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    y?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    width?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    height?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    content?: StringNullableFilter<"DocumentAnnotation"> | string | null
    color?: StringNullableFilter<"DocumentAnnotation"> | string | null
    data?: JsonNullableFilter<"DocumentAnnotation">
    createdAt?: DateTimeFilter<"DocumentAnnotation"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentAnnotation"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentAnnotationOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    page?: SortOrder
    x?: SortOrderInput | SortOrder
    y?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentAnnotationCountOrderByAggregateInput
    _avg?: DocumentAnnotationAvgOrderByAggregateInput
    _max?: DocumentAnnotationMaxOrderByAggregateInput
    _min?: DocumentAnnotationMinOrderByAggregateInput
    _sum?: DocumentAnnotationSumOrderByAggregateInput
  }

  export type DocumentAnnotationScalarWhereWithAggregatesInput = {
    AND?: DocumentAnnotationScalarWhereWithAggregatesInput | DocumentAnnotationScalarWhereWithAggregatesInput[]
    OR?: DocumentAnnotationScalarWhereWithAggregatesInput[]
    NOT?: DocumentAnnotationScalarWhereWithAggregatesInput | DocumentAnnotationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DocumentAnnotation"> | number
    documentId?: IntWithAggregatesFilter<"DocumentAnnotation"> | number
    userId?: IntWithAggregatesFilter<"DocumentAnnotation"> | number
    type?: StringWithAggregatesFilter<"DocumentAnnotation"> | string
    page?: IntWithAggregatesFilter<"DocumentAnnotation"> | number
    x?: FloatNullableWithAggregatesFilter<"DocumentAnnotation"> | number | null
    y?: FloatNullableWithAggregatesFilter<"DocumentAnnotation"> | number | null
    width?: FloatNullableWithAggregatesFilter<"DocumentAnnotation"> | number | null
    height?: FloatNullableWithAggregatesFilter<"DocumentAnnotation"> | number | null
    content?: StringNullableWithAggregatesFilter<"DocumentAnnotation"> | string | null
    color?: StringNullableWithAggregatesFilter<"DocumentAnnotation"> | string | null
    data?: JsonNullableWithAggregatesFilter<"DocumentAnnotation">
    createdAt?: DateTimeWithAggregatesFilter<"DocumentAnnotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentAnnotation"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    uploadedAttachments?: DocumentAttachmentCreateNestedManyWithoutUploaderInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    uploadedAttachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    uploadedAttachments?: DocumentAttachmentUpdateManyWithoutUploaderNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    uploadedAttachments?: DocumentAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeCreateInput = {
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleCreateNestedManyWithoutEmployeeInput
    drivenAssignments?: DailyAssignmentCreateNestedManyWithoutDriverInput
    assistantAssignments?: DailyAssignmentAssistantCreateNestedManyWithoutEmployeeInput
    workCardEntries?: WorkCardEntryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleUncheckedCreateNestedManyWithoutEmployeeInput
    drivenAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutDriverInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutEmployeeInput
    workCardEntries?: WorkCardEntryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUpdateManyWithoutEmployeeNestedInput
    drivenAssignments?: DailyAssignmentUpdateManyWithoutDriverNestedInput
    assistantAssignments?: DailyAssignmentAssistantUpdateManyWithoutEmployeeNestedInput
    workCardEntries?: WorkCardEntryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUncheckedUpdateManyWithoutEmployeeNestedInput
    drivenAssignments?: DailyAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeNestedInput
    workCardEntries?: WorkCardEntryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
  }

  export type EmployeeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleCreateInput = {
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutVehicleInput
    faultReports?: VehicleFaultReportCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: number
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    faultReports?: VehicleFaultReportUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
    dailyAssignments?: DailyAssignmentUpdateManyWithoutVehicleNestedInput
    faultReports?: VehicleFaultReportUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    faultReports?: VehicleFaultReportUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: number
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
  }

  export type VehicleUpdateManyMutationInput = {
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
  }

  export type RegionCreateInput = {
    name: string
    unitName: string
    notes?: string | null
    points?: PointCreateNestedManyWithoutRegionInput
    regionFractions?: RegionFractionCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    name: string
    unitName: string
    notes?: string | null
    points?: PointUncheckedCreateNestedManyWithoutRegionInput
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUpdateManyWithoutRegionNestedInput
    regionFractions?: RegionFractionUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUncheckedUpdateManyWithoutRegionNestedInput
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    name: string
    unitName: string
    notes?: string | null
  }

  export type RegionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FractionCreateInput = {
    name: string
    code: string
    color: string
    pointFractions?: PointFractionCreateNestedManyWithoutFractionInput
    regionFractions?: RegionFractionCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionCreateNestedManyWithoutFractionInput
  }

  export type FractionUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    color: string
    pointFractions?: PointFractionUncheckedCreateNestedManyWithoutFractionInput
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutFractionInput
  }

  export type FractionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUpdateManyWithoutFractionNestedInput
    regionFractions?: RegionFractionUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUpdateManyWithoutFractionNestedInput
  }

  export type FractionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUncheckedUpdateManyWithoutFractionNestedInput
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedUpdateManyWithoutFractionNestedInput
  }

  export type FractionCreateManyInput = {
    id?: number
    name: string
    code: string
    color: string
  }

  export type FractionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type FractionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type PointCreateInput = {
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    region?: RegionCreateNestedOneWithoutPointsInput
    pointFractions?: PointFractionCreateNestedManyWithoutPointInput
  }

  export type PointUncheckedCreateInput = {
    id?: number
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: number | null
    pointFractions?: PointFractionUncheckedCreateNestedManyWithoutPointInput
  }

  export type PointUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    region?: RegionUpdateOneWithoutPointsNestedInput
    pointFractions?: PointFractionUpdateManyWithoutPointNestedInput
  }

  export type PointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
    pointFractions?: PointFractionUncheckedUpdateManyWithoutPointNestedInput
  }

  export type PointCreateManyInput = {
    id?: number
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: number | null
  }

  export type PointUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PointFractionCreateInput = {
    containerSize: string
    pickupFrequency: string
    point: PointCreateNestedOneWithoutPointFractionsInput
    fraction: FractionCreateNestedOneWithoutPointFractionsInput
  }

  export type PointFractionUncheckedCreateInput = {
    id?: number
    pointId: number
    fractionId: number
    containerSize: string
    pickupFrequency: string
  }

  export type PointFractionUpdateInput = {
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
    point?: PointUpdateOneRequiredWithoutPointFractionsNestedInput
    fraction?: FractionUpdateOneRequiredWithoutPointFractionsNestedInput
  }

  export type PointFractionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pointId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PointFractionCreateManyInput = {
    id?: number
    pointId: number
    fractionId: number
    containerSize: string
    pickupFrequency: string
  }

  export type PointFractionUpdateManyMutationInput = {
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PointFractionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pointId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeScheduleCreateInput = {
    date: Date | string
    shift: string
    customHours?: string | null
    colorCode?: string | null
    employee: EmployeeCreateNestedOneWithoutEmployeeSchedulesInput
  }

  export type EmployeeScheduleUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    shift: string
    customHours?: string | null
    colorCode?: string | null
  }

  export type EmployeeScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutEmployeeSchedulesNestedInput
  }

  export type EmployeeScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeScheduleCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    shift: string
    customHours?: string | null
    colorCode?: string | null
  }

  export type EmployeeScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegionFractionCreateInput = {
    region: RegionCreateNestedOneWithoutRegionFractionsInput
    fraction: FractionCreateNestedOneWithoutRegionFractionsInput
  }

  export type RegionFractionUncheckedCreateInput = {
    id?: number
    regionId: number
    fractionId: number
  }

  export type RegionFractionUpdateInput = {
    region?: RegionUpdateOneRequiredWithoutRegionFractionsNestedInput
    fraction?: FractionUpdateOneRequiredWithoutRegionFractionsNestedInput
  }

  export type RegionFractionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type RegionFractionCreateManyInput = {
    id?: number
    regionId: number
    fractionId: number
  }

  export type RegionFractionUpdateManyMutationInput = {

  }

  export type RegionFractionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type CalendarEntryCreateInput = {
    date: Date | string
    region: RegionCreateNestedOneWithoutCalendarEntriesInput
    fraction: FractionCreateNestedOneWithoutCalendarEntriesInput
  }

  export type CalendarEntryUncheckedCreateInput = {
    id?: number
    regionId: number
    fractionId: number
    date: Date | string
  }

  export type CalendarEntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutCalendarEntriesNestedInput
    fraction?: FractionUpdateOneRequiredWithoutCalendarEntriesNestedInput
  }

  export type CalendarEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryCreateManyInput = {
    id?: number
    regionId: number
    fractionId: number
    date: Date | string
  }

  export type CalendarEntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAssignmentCreateInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    municipality?: MunicipalityCreateNestedOneWithoutDailyAssignmentsInput
    region: RegionCreateNestedOneWithoutDailyAssignmentsInput
    vehicle: VehicleCreateNestedOneWithoutDailyAssignmentsInput
    driver?: EmployeeCreateNestedOneWithoutDrivenAssignmentsInput
    assistants?: DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    assistants?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput
    region?: RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    driver?: EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput
    assistants?: DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentCreateManyInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
  }

  export type DailyAssignmentUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyAssignmentAssistantCreateInput = {
    dailyAssignment: DailyAssignmentCreateNestedOneWithoutAssistantsInput
    employee: EmployeeCreateNestedOneWithoutAssistantAssignmentsInput
  }

  export type DailyAssignmentAssistantUncheckedCreateInput = {
    id?: number
    dailyAssignmentId: number
    employeeId: number
  }

  export type DailyAssignmentAssistantUpdateInput = {
    dailyAssignment?: DailyAssignmentUpdateOneRequiredWithoutAssistantsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutAssistantAssignmentsNestedInput
  }

  export type DailyAssignmentAssistantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentAssistantCreateManyInput = {
    id?: number
    dailyAssignmentId: number
    employeeId: number
  }

  export type DailyAssignmentAssistantUpdateManyMutationInput = {

  }

  export type DailyAssignmentAssistantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentFractionCreateInput = {
    dailyAssignment: DailyAssignmentCreateNestedOneWithoutFractionsInput
    fraction: FractionCreateNestedOneWithoutFractionsInAssignmentsInput
  }

  export type DailyAssignmentFractionUncheckedCreateInput = {
    id?: number
    dailyAssignmentId: number
    fractionId: number
  }

  export type DailyAssignmentFractionUpdateInput = {
    dailyAssignment?: DailyAssignmentUpdateOneRequiredWithoutFractionsNestedInput
    fraction?: FractionUpdateOneRequiredWithoutFractionsInAssignmentsNestedInput
  }

  export type DailyAssignmentFractionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentFractionCreateManyInput = {
    id?: number
    dailyAssignmentId: number
    fractionId: number
  }

  export type DailyAssignmentFractionUpdateManyMutationInput = {

  }

  export type DailyAssignmentFractionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleFaultReportCreateInput = {
    reportedBy: string
    description?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    isResolved?: boolean
    vehicle: VehicleCreateNestedOneWithoutFaultReportsInput
  }

  export type VehicleFaultReportUncheckedCreateInput = {
    id?: number
    vehicleId: number
    reportedBy: string
    description?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    isResolved?: boolean
  }

  export type VehicleFaultReportUpdateInput = {
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    vehicle?: VehicleUpdateOneRequiredWithoutFaultReportsNestedInput
  }

  export type VehicleFaultReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleFaultReportCreateManyInput = {
    id?: number
    vehicleId: number
    reportedBy: string
    description?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    isResolved?: boolean
  }

  export type VehicleFaultReportUpdateManyMutationInput = {
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleFaultReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkOrderCreateInput = {
    type: string
    dateReceived: Date | string
    realizationDate?: Date | string | null
    quantity?: number | null
    orderNumber?: string | null
    bagNumber?: string | null
    executionDate: Date | string
    receivedBy: string
    address: string
    municipality?: string | null
    company?: string | null
    wasteType?: string | null
    rodzaj?: string | null
    kontener?: string | null
    description?: string | null
    notes?: string | null
    failureReason?: string | null
    vehicle?: string | null
    responsible?: string | null
    completed?: boolean
    zlecenie?: string | null
  }

  export type WorkOrderUncheckedCreateInput = {
    id?: number
    type: string
    dateReceived: Date | string
    realizationDate?: Date | string | null
    quantity?: number | null
    orderNumber?: string | null
    bagNumber?: string | null
    executionDate: Date | string
    receivedBy: string
    address: string
    municipality?: string | null
    company?: string | null
    wasteType?: string | null
    rodzaj?: string | null
    kontener?: string | null
    description?: string | null
    notes?: string | null
    failureReason?: string | null
    vehicle?: string | null
    responsible?: string | null
    completed?: boolean
    zlecenie?: string | null
  }

  export type WorkOrderUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    realizationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedBy?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    wasteType?: NullableStringFieldUpdateOperationsInput | string | null
    rodzaj?: NullableStringFieldUpdateOperationsInput | string | null
    kontener?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    zlecenie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    realizationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedBy?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    wasteType?: NullableStringFieldUpdateOperationsInput | string | null
    rodzaj?: NullableStringFieldUpdateOperationsInput | string | null
    kontener?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    zlecenie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderCreateManyInput = {
    id?: number
    type: string
    dateReceived: Date | string
    realizationDate?: Date | string | null
    quantity?: number | null
    orderNumber?: string | null
    bagNumber?: string | null
    executionDate: Date | string
    receivedBy: string
    address: string
    municipality?: string | null
    company?: string | null
    wasteType?: string | null
    rodzaj?: string | null
    kontener?: string | null
    description?: string | null
    notes?: string | null
    failureReason?: string | null
    vehicle?: string | null
    responsible?: string | null
    completed?: boolean
    zlecenie?: string | null
  }

  export type WorkOrderUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    realizationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedBy?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    wasteType?: NullableStringFieldUpdateOperationsInput | string | null
    rodzaj?: NullableStringFieldUpdateOperationsInput | string | null
    kontener?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    zlecenie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    dateReceived?: DateTimeFieldUpdateOperationsInput | Date | string
    realizationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedBy?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    municipality?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    wasteType?: NullableStringFieldUpdateOperationsInput | string | null
    rodzaj?: NullableStringFieldUpdateOperationsInput | string | null
    kontener?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: NullableStringFieldUpdateOperationsInput | string | null
    responsible?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    zlecenie?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MunicipalityCreateInput = {
    name: string
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateInput = {
    id?: number
    name: string
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    dailyAssignments?: DailyAssignmentUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityCreateManyInput = {
    id?: number
    name: string
  }

  export type MunicipalityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RodzajAbsencjiCreateInput = {
    name: string
    code?: string | null
    color?: string | null
    notes?: string | null
    workCardEntries?: WorkCardEntryCreateNestedManyWithoutAbsenceTypeInput
  }

  export type RodzajAbsencjiUncheckedCreateInput = {
    id?: number
    name: string
    code?: string | null
    color?: string | null
    notes?: string | null
    workCardEntries?: WorkCardEntryUncheckedCreateNestedManyWithoutAbsenceTypeInput
  }

  export type RodzajAbsencjiUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workCardEntries?: WorkCardEntryUpdateManyWithoutAbsenceTypeNestedInput
  }

  export type RodzajAbsencjiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    workCardEntries?: WorkCardEntryUncheckedUpdateManyWithoutAbsenceTypeNestedInput
  }

  export type RodzajAbsencjiCreateManyInput = {
    id?: number
    name: string
    code?: string | null
    color?: string | null
    notes?: string | null
  }

  export type RodzajAbsencjiUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RodzajAbsencjiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkCardEntryCreateInput = {
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutWorkCardEntriesInput
    absenceType?: RodzajAbsencjiCreateNestedOneWithoutWorkCardEntriesInput
  }

  export type WorkCardEntryUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    absenceTypeId?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkCardEntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutWorkCardEntriesNestedInput
    absenceType?: RodzajAbsencjiUpdateOneWithoutWorkCardEntriesNestedInput
  }

  export type WorkCardEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    absenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkCardEntryCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    absenceTypeId?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkCardEntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkCardEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    absenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedBy?: number | null
    deletedAt?: Date | string | null
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedBy?: number | null
    deletedAt?: Date | string | null
  }

  export type DocumentUpdateManyMutationInput = {
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentAttachmentCreateInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isDeleted?: boolean
    document: DocumentCreateNestedOneWithoutAttachmentsInput
    uploader: UserCreateNestedOneWithoutUploadedAttachmentsInput
  }

  export type DocumentAttachmentUncheckedCreateInput = {
    id?: number
    documentId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    isDeleted?: boolean
  }

  export type DocumentAttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    document?: DocumentUpdateOneRequiredWithoutAttachmentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedAttachmentsNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAttachmentCreateManyInput = {
    id?: number
    documentId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    isDeleted?: boolean
  }

  export type DocumentAttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAnnotationCreateInput = {
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutAnnotationsInput
    user: UserCreateNestedOneWithoutAnnotationsInput
  }

  export type DocumentAnnotationUncheckedCreateInput = {
    id?: number
    documentId: number
    userId: number
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentAnnotationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutAnnotationsNestedInput
    user?: UserUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type DocumentAnnotationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAnnotationCreateManyInput = {
    id?: number
    documentId: number
    userId: number
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentAnnotationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAnnotationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentAttachmentListRelationFilter = {
    every?: DocumentAttachmentWhereInput
    some?: DocumentAttachmentWhereInput
    none?: DocumentAttachmentWhereInput
  }

  export type DocumentAnnotationListRelationFilter = {
    every?: DocumentAnnotationWhereInput
    some?: DocumentAnnotationWhereInput
    none?: DocumentAnnotationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentAnnotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EmployeeScheduleListRelationFilter = {
    every?: EmployeeScheduleWhereInput
    some?: EmployeeScheduleWhereInput
    none?: EmployeeScheduleWhereInput
  }

  export type DailyAssignmentListRelationFilter = {
    every?: DailyAssignmentWhereInput
    some?: DailyAssignmentWhereInput
    none?: DailyAssignmentWhereInput
  }

  export type DailyAssignmentAssistantListRelationFilter = {
    every?: DailyAssignmentAssistantWhereInput
    some?: DailyAssignmentAssistantWhereInput
    none?: DailyAssignmentAssistantWhereInput
  }

  export type WorkCardEntryListRelationFilter = {
    every?: WorkCardEntryWhereInput
    some?: WorkCardEntryWhereInput
    none?: WorkCardEntryWhereInput
  }

  export type EmployeeScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyAssignmentAssistantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkCardEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    hiredAt?: SortOrder
    terminatedAt?: SortOrder
    notes?: SortOrder
    hasDisabilityCertificate?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    hiredAt?: SortOrder
    terminatedAt?: SortOrder
    notes?: SortOrder
    hasDisabilityCertificate?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    hiredAt?: SortOrder
    terminatedAt?: SortOrder
    notes?: SortOrder
    hasDisabilityCertificate?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type VehicleFaultReportListRelationFilter = {
    every?: VehicleFaultReportWhereInput
    some?: VehicleFaultReportWhereInput
    none?: VehicleFaultReportWhereInput
  }

  export type VehicleFaultReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    registrationNumber?: SortOrder
    vehicleType?: SortOrder
    capacity?: SortOrder
    fuelType?: SortOrder
    purchaseDate?: SortOrder
    isActive?: SortOrder
    faultStatus?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    registrationNumber?: SortOrder
    vehicleType?: SortOrder
    capacity?: SortOrder
    fuelType?: SortOrder
    purchaseDate?: SortOrder
    isActive?: SortOrder
    faultStatus?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    registrationNumber?: SortOrder
    vehicleType?: SortOrder
    capacity?: SortOrder
    fuelType?: SortOrder
    purchaseDate?: SortOrder
    isActive?: SortOrder
    faultStatus?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PointListRelationFilter = {
    every?: PointWhereInput
    some?: PointWhereInput
    none?: PointWhereInput
  }

  export type RegionFractionListRelationFilter = {
    every?: RegionFractionWhereInput
    some?: RegionFractionWhereInput
    none?: RegionFractionWhereInput
  }

  export type CalendarEntryListRelationFilter = {
    every?: CalendarEntryWhereInput
    some?: CalendarEntryWhereInput
    none?: CalendarEntryWhereInput
  }

  export type PointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionFractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unitName?: SortOrder
    notes?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unitName?: SortOrder
    notes?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    unitName?: SortOrder
    notes?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PointFractionListRelationFilter = {
    every?: PointFractionWhereInput
    some?: PointFractionWhereInput
    none?: PointFractionWhereInput
  }

  export type DailyAssignmentFractionListRelationFilter = {
    every?: DailyAssignmentFractionWhereInput
    some?: DailyAssignmentFractionWhereInput
    none?: DailyAssignmentFractionWhereInput
  }

  export type PointFractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyAssignmentFractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FractionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type FractionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FractionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type FractionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
  }

  export type FractionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RegionNullableScalarRelationFilter = {
    is?: RegionWhereInput | null
    isNot?: RegionWhereInput | null
  }

  export type PointCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    town?: SortOrder
    street?: SortOrder
    number?: SortOrder
    notes?: SortOrder
    companyName?: SortOrder
    activityNotes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isIndefinite?: SortOrder
    kompostownik?: SortOrder
    regionId?: SortOrder
  }

  export type PointAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
  }

  export type PointMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    town?: SortOrder
    street?: SortOrder
    number?: SortOrder
    notes?: SortOrder
    companyName?: SortOrder
    activityNotes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isIndefinite?: SortOrder
    kompostownik?: SortOrder
    regionId?: SortOrder
  }

  export type PointMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    town?: SortOrder
    street?: SortOrder
    number?: SortOrder
    notes?: SortOrder
    companyName?: SortOrder
    activityNotes?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isIndefinite?: SortOrder
    kompostownik?: SortOrder
    regionId?: SortOrder
  }

  export type PointSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PointScalarRelationFilter = {
    is?: PointWhereInput
    isNot?: PointWhereInput
  }

  export type FractionScalarRelationFilter = {
    is?: FractionWhereInput
    isNot?: FractionWhereInput
  }

  export type PointFractionCountOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
    containerSize?: SortOrder
    pickupFrequency?: SortOrder
  }

  export type PointFractionAvgOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
  }

  export type PointFractionMaxOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
    containerSize?: SortOrder
    pickupFrequency?: SortOrder
  }

  export type PointFractionMinOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
    containerSize?: SortOrder
    pickupFrequency?: SortOrder
  }

  export type PointFractionSumOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    fractionId?: SortOrder
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type EmployeeScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    shift?: SortOrder
    customHours?: SortOrder
    colorCode?: SortOrder
  }

  export type EmployeeScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type EmployeeScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    shift?: SortOrder
    customHours?: SortOrder
    colorCode?: SortOrder
  }

  export type EmployeeScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    shift?: SortOrder
    customHours?: SortOrder
    colorCode?: SortOrder
  }

  export type EmployeeScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type RegionFractionRegionIdFractionIdCompoundUniqueInput = {
    regionId: number
    fractionId: number
  }

  export type RegionFractionCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type RegionFractionAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type RegionFractionMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type RegionFractionMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type RegionFractionSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type CalendarEntryRegionIdFractionIdDateCompoundUniqueInput = {
    regionId: number
    fractionId: number
    date: Date | string
  }

  export type CalendarEntryCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type CalendarEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEntryMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
    date?: SortOrder
  }

  export type CalendarEntrySumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    fractionId?: SortOrder
  }

  export type EnumDailyAssignmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyAssignmentType | EnumDailyAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DailyAssignmentType[]
    notIn?: $Enums.DailyAssignmentType[]
    not?: NestedEnumDailyAssignmentTypeFilter<$PrismaModel> | $Enums.DailyAssignmentType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MunicipalityNullableScalarRelationFilter = {
    is?: MunicipalityWhereInput | null
    isNot?: MunicipalityWhereInput | null
  }

  export type VehicleScalarRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type DailyAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    type?: SortOrder
    shift?: SortOrder
    municipalityId?: SortOrder
    equipment?: SortOrder
    workType?: SortOrder
  }

  export type DailyAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    municipalityId?: SortOrder
  }

  export type DailyAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    type?: SortOrder
    shift?: SortOrder
    municipalityId?: SortOrder
    workType?: SortOrder
  }

  export type DailyAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    type?: SortOrder
    shift?: SortOrder
    municipalityId?: SortOrder
    workType?: SortOrder
  }

  export type DailyAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    municipalityId?: SortOrder
  }

  export type EnumDailyAssignmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyAssignmentType | EnumDailyAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DailyAssignmentType[]
    notIn?: $Enums.DailyAssignmentType[]
    not?: NestedEnumDailyAssignmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DailyAssignmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDailyAssignmentTypeFilter<$PrismaModel>
    _max?: NestedEnumDailyAssignmentTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DailyAssignmentScalarRelationFilter = {
    is?: DailyAssignmentWhereInput
    isNot?: DailyAssignmentWhereInput
  }

  export type DailyAssignmentAssistantCountOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
  }

  export type DailyAssignmentAssistantAvgOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
  }

  export type DailyAssignmentAssistantMaxOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
  }

  export type DailyAssignmentAssistantMinOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
  }

  export type DailyAssignmentAssistantSumOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    employeeId?: SortOrder
  }

  export type DailyAssignmentFractionCountOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
  }

  export type DailyAssignmentFractionAvgOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
  }

  export type DailyAssignmentFractionMaxOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
  }

  export type DailyAssignmentFractionMinOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
  }

  export type DailyAssignmentFractionSumOrderByAggregateInput = {
    id?: SortOrder
    dailyAssignmentId?: SortOrder
    fractionId?: SortOrder
  }

  export type VehicleFaultReportCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    reportedBy?: SortOrder
    description?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    isResolved?: SortOrder
  }

  export type VehicleFaultReportAvgOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
  }

  export type VehicleFaultReportMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    reportedBy?: SortOrder
    description?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    isResolved?: SortOrder
  }

  export type VehicleFaultReportMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    reportedBy?: SortOrder
    description?: SortOrder
    reportedAt?: SortOrder
    resolvedAt?: SortOrder
    isResolved?: SortOrder
  }

  export type VehicleFaultReportSumOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
  }

  export type WorkOrderCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dateReceived?: SortOrder
    realizationDate?: SortOrder
    quantity?: SortOrder
    orderNumber?: SortOrder
    bagNumber?: SortOrder
    executionDate?: SortOrder
    receivedBy?: SortOrder
    address?: SortOrder
    municipality?: SortOrder
    company?: SortOrder
    wasteType?: SortOrder
    rodzaj?: SortOrder
    kontener?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    failureReason?: SortOrder
    vehicle?: SortOrder
    responsible?: SortOrder
    completed?: SortOrder
    zlecenie?: SortOrder
  }

  export type WorkOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type WorkOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dateReceived?: SortOrder
    realizationDate?: SortOrder
    quantity?: SortOrder
    orderNumber?: SortOrder
    bagNumber?: SortOrder
    executionDate?: SortOrder
    receivedBy?: SortOrder
    address?: SortOrder
    municipality?: SortOrder
    company?: SortOrder
    wasteType?: SortOrder
    rodzaj?: SortOrder
    kontener?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    failureReason?: SortOrder
    vehicle?: SortOrder
    responsible?: SortOrder
    completed?: SortOrder
    zlecenie?: SortOrder
  }

  export type WorkOrderMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dateReceived?: SortOrder
    realizationDate?: SortOrder
    quantity?: SortOrder
    orderNumber?: SortOrder
    bagNumber?: SortOrder
    executionDate?: SortOrder
    receivedBy?: SortOrder
    address?: SortOrder
    municipality?: SortOrder
    company?: SortOrder
    wasteType?: SortOrder
    rodzaj?: SortOrder
    kontener?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    failureReason?: SortOrder
    vehicle?: SortOrder
    responsible?: SortOrder
    completed?: SortOrder
    zlecenie?: SortOrder
  }

  export type WorkOrderSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type MunicipalityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MunicipalityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MunicipalityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MunicipalityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MunicipalitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RodzajAbsencjiCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    notes?: SortOrder
  }

  export type RodzajAbsencjiAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RodzajAbsencjiMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    notes?: SortOrder
  }

  export type RodzajAbsencjiMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    notes?: SortOrder
  }

  export type RodzajAbsencjiSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RodzajAbsencjiNullableScalarRelationFilter = {
    is?: RodzajAbsencjiWhereInput | null
    isNot?: RodzajAbsencjiWhereInput | null
  }

  export type WorkCardEntryEmployeeIdDateCompoundUniqueInput = {
    employeeId: number
    date: Date | string
  }

  export type WorkCardEntryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    actualFrom?: SortOrder
    actualTo?: SortOrder
    actualTotal?: SortOrder
    absenceTypeId?: SortOrder
    onCall?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkCardEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    actualTotal?: SortOrder
    absenceTypeId?: SortOrder
  }

  export type WorkCardEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    actualFrom?: SortOrder
    actualTo?: SortOrder
    actualTotal?: SortOrder
    absenceTypeId?: SortOrder
    onCall?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkCardEntryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    actualFrom?: SortOrder
    actualTo?: SortOrder
    actualTotal?: SortOrder
    absenceTypeId?: SortOrder
    onCall?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkCardEntrySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    actualTotal?: SortOrder
    absenceTypeId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    parties?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    parties?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    contractNumber?: SortOrder
    parties?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type DocumentAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type DocumentAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    isDeleted?: SortOrder
  }

  export type DocumentAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentAnnotationCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    page?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    content?: SortOrder
    color?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAnnotationAvgOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type DocumentAnnotationMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    page?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    content?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAnnotationMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    page?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    content?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAnnotationSumOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type DocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutDeleterInput = {
    create?: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput> | DocumentCreateWithoutDeleterInput[] | DocumentUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDeleterInput | DocumentCreateOrConnectWithoutDeleterInput[]
    createMany?: DocumentCreateManyDeleterInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentAttachmentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUploaderInput, DocumentAttachmentUncheckedCreateWithoutUploaderInput> | DocumentAttachmentCreateWithoutUploaderInput[] | DocumentAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUploaderInput | DocumentAttachmentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentAttachmentCreateManyUploaderInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type DocumentAnnotationCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentAnnotationCreateWithoutUserInput, DocumentAnnotationUncheckedCreateWithoutUserInput> | DocumentAnnotationCreateWithoutUserInput[] | DocumentAnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutUserInput | DocumentAnnotationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentAnnotationCreateManyUserInputEnvelope
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDeleterInput = {
    create?: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput> | DocumentCreateWithoutDeleterInput[] | DocumentUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDeleterInput | DocumentCreateOrConnectWithoutDeleterInput[]
    createMany?: DocumentCreateManyDeleterInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentAttachmentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUploaderInput, DocumentAttachmentUncheckedCreateWithoutUploaderInput> | DocumentAttachmentCreateWithoutUploaderInput[] | DocumentAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUploaderInput | DocumentAttachmentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentAttachmentCreateManyUploaderInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type DocumentAnnotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentAnnotationCreateWithoutUserInput, DocumentAnnotationUncheckedCreateWithoutUserInput> | DocumentAnnotationCreateWithoutUserInput[] | DocumentAnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutUserInput | DocumentAnnotationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentAnnotationCreateManyUserInputEnvelope
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploaderInput | DocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploaderInput | DocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploaderInput | DocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput> | DocumentCreateWithoutDeleterInput[] | DocumentUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDeleterInput | DocumentCreateOrConnectWithoutDeleterInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDeleterInput | DocumentUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: DocumentCreateManyDeleterInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDeleterInput | DocumentUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDeleterInput | DocumentUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentAttachmentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUploaderInput, DocumentAttachmentUncheckedCreateWithoutUploaderInput> | DocumentAttachmentCreateWithoutUploaderInput[] | DocumentAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUploaderInput | DocumentAttachmentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutUploaderInput | DocumentAttachmentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentAttachmentCreateManyUploaderInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutUploaderInput | DocumentAttachmentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutUploaderInput | DocumentAttachmentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type DocumentAnnotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentAnnotationCreateWithoutUserInput, DocumentAnnotationUncheckedCreateWithoutUserInput> | DocumentAnnotationCreateWithoutUserInput[] | DocumentAnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutUserInput | DocumentAnnotationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentAnnotationUpsertWithWhereUniqueWithoutUserInput | DocumentAnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentAnnotationCreateManyUserInputEnvelope
    set?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    disconnect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    delete?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    update?: DocumentAnnotationUpdateWithWhereUniqueWithoutUserInput | DocumentAnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentAnnotationUpdateManyWithWhereWithoutUserInput | DocumentAnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentAnnotationScalarWhereInput | DocumentAnnotationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploaderInput | DocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploaderInput | DocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploaderInput | DocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput> | DocumentCreateWithoutDeleterInput[] | DocumentUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDeleterInput | DocumentCreateOrConnectWithoutDeleterInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDeleterInput | DocumentUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: DocumentCreateManyDeleterInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDeleterInput | DocumentUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDeleterInput | DocumentUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUploaderInput, DocumentAttachmentUncheckedCreateWithoutUploaderInput> | DocumentAttachmentCreateWithoutUploaderInput[] | DocumentAttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUploaderInput | DocumentAttachmentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutUploaderInput | DocumentAttachmentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentAttachmentCreateManyUploaderInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutUploaderInput | DocumentAttachmentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutUploaderInput | DocumentAttachmentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type DocumentAnnotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentAnnotationCreateWithoutUserInput, DocumentAnnotationUncheckedCreateWithoutUserInput> | DocumentAnnotationCreateWithoutUserInput[] | DocumentAnnotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutUserInput | DocumentAnnotationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentAnnotationUpsertWithWhereUniqueWithoutUserInput | DocumentAnnotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentAnnotationCreateManyUserInputEnvelope
    set?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    disconnect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    delete?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    update?: DocumentAnnotationUpdateWithWhereUniqueWithoutUserInput | DocumentAnnotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentAnnotationUpdateManyWithWhereWithoutUserInput | DocumentAnnotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentAnnotationScalarWhereInput | DocumentAnnotationScalarWhereInput[]
  }

  export type EmployeeScheduleCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeScheduleCreateWithoutEmployeeInput, EmployeeScheduleUncheckedCreateWithoutEmployeeInput> | EmployeeScheduleCreateWithoutEmployeeInput[] | EmployeeScheduleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeScheduleCreateOrConnectWithoutEmployeeInput | EmployeeScheduleCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeScheduleCreateManyEmployeeInputEnvelope
    connect?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
  }

  export type DailyAssignmentCreateNestedManyWithoutDriverInput = {
    create?: XOR<DailyAssignmentCreateWithoutDriverInput, DailyAssignmentUncheckedCreateWithoutDriverInput> | DailyAssignmentCreateWithoutDriverInput[] | DailyAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutDriverInput | DailyAssignmentCreateOrConnectWithoutDriverInput[]
    createMany?: DailyAssignmentCreateManyDriverInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type DailyAssignmentAssistantCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput> | DailyAssignmentAssistantCreateWithoutEmployeeInput[] | DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput | DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput[]
    createMany?: DailyAssignmentAssistantCreateManyEmployeeInputEnvelope
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
  }

  export type WorkCardEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkCardEntryCreateWithoutEmployeeInput, WorkCardEntryUncheckedCreateWithoutEmployeeInput> | WorkCardEntryCreateWithoutEmployeeInput[] | WorkCardEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutEmployeeInput | WorkCardEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkCardEntryCreateManyEmployeeInputEnvelope
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
  }

  export type EmployeeScheduleUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeScheduleCreateWithoutEmployeeInput, EmployeeScheduleUncheckedCreateWithoutEmployeeInput> | EmployeeScheduleCreateWithoutEmployeeInput[] | EmployeeScheduleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeScheduleCreateOrConnectWithoutEmployeeInput | EmployeeScheduleCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeScheduleCreateManyEmployeeInputEnvelope
    connect?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
  }

  export type DailyAssignmentUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DailyAssignmentCreateWithoutDriverInput, DailyAssignmentUncheckedCreateWithoutDriverInput> | DailyAssignmentCreateWithoutDriverInput[] | DailyAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutDriverInput | DailyAssignmentCreateOrConnectWithoutDriverInput[]
    createMany?: DailyAssignmentCreateManyDriverInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type DailyAssignmentAssistantUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput> | DailyAssignmentAssistantCreateWithoutEmployeeInput[] | DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput | DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput[]
    createMany?: DailyAssignmentAssistantCreateManyEmployeeInputEnvelope
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
  }

  export type WorkCardEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkCardEntryCreateWithoutEmployeeInput, WorkCardEntryUncheckedCreateWithoutEmployeeInput> | WorkCardEntryCreateWithoutEmployeeInput[] | WorkCardEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutEmployeeInput | WorkCardEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkCardEntryCreateManyEmployeeInputEnvelope
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EmployeeScheduleUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeScheduleCreateWithoutEmployeeInput, EmployeeScheduleUncheckedCreateWithoutEmployeeInput> | EmployeeScheduleCreateWithoutEmployeeInput[] | EmployeeScheduleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeScheduleCreateOrConnectWithoutEmployeeInput | EmployeeScheduleCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeScheduleUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeScheduleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeScheduleCreateManyEmployeeInputEnvelope
    set?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    disconnect?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    delete?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    connect?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    update?: EmployeeScheduleUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeScheduleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeScheduleUpdateManyWithWhereWithoutEmployeeInput | EmployeeScheduleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeScheduleScalarWhereInput | EmployeeScheduleScalarWhereInput[]
  }

  export type DailyAssignmentUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutDriverInput, DailyAssignmentUncheckedCreateWithoutDriverInput> | DailyAssignmentCreateWithoutDriverInput[] | DailyAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutDriverInput | DailyAssignmentCreateOrConnectWithoutDriverInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutDriverInput | DailyAssignmentUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DailyAssignmentCreateManyDriverInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutDriverInput | DailyAssignmentUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutDriverInput | DailyAssignmentUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type DailyAssignmentAssistantUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput> | DailyAssignmentAssistantCreateWithoutEmployeeInput[] | DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput | DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput[]
    upsert?: DailyAssignmentAssistantUpsertWithWhereUniqueWithoutEmployeeInput | DailyAssignmentAssistantUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DailyAssignmentAssistantCreateManyEmployeeInputEnvelope
    set?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    disconnect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    delete?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    update?: DailyAssignmentAssistantUpdateWithWhereUniqueWithoutEmployeeInput | DailyAssignmentAssistantUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DailyAssignmentAssistantUpdateManyWithWhereWithoutEmployeeInput | DailyAssignmentAssistantUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DailyAssignmentAssistantScalarWhereInput | DailyAssignmentAssistantScalarWhereInput[]
  }

  export type WorkCardEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkCardEntryCreateWithoutEmployeeInput, WorkCardEntryUncheckedCreateWithoutEmployeeInput> | WorkCardEntryCreateWithoutEmployeeInput[] | WorkCardEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutEmployeeInput | WorkCardEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkCardEntryUpsertWithWhereUniqueWithoutEmployeeInput | WorkCardEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkCardEntryCreateManyEmployeeInputEnvelope
    set?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    disconnect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    delete?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    update?: WorkCardEntryUpdateWithWhereUniqueWithoutEmployeeInput | WorkCardEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkCardEntryUpdateManyWithWhereWithoutEmployeeInput | WorkCardEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkCardEntryScalarWhereInput | WorkCardEntryScalarWhereInput[]
  }

  export type EmployeeScheduleUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeScheduleCreateWithoutEmployeeInput, EmployeeScheduleUncheckedCreateWithoutEmployeeInput> | EmployeeScheduleCreateWithoutEmployeeInput[] | EmployeeScheduleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeScheduleCreateOrConnectWithoutEmployeeInput | EmployeeScheduleCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeScheduleUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeScheduleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeScheduleCreateManyEmployeeInputEnvelope
    set?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    disconnect?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    delete?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    connect?: EmployeeScheduleWhereUniqueInput | EmployeeScheduleWhereUniqueInput[]
    update?: EmployeeScheduleUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeScheduleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeScheduleUpdateManyWithWhereWithoutEmployeeInput | EmployeeScheduleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeScheduleScalarWhereInput | EmployeeScheduleScalarWhereInput[]
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutDriverInput, DailyAssignmentUncheckedCreateWithoutDriverInput> | DailyAssignmentCreateWithoutDriverInput[] | DailyAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutDriverInput | DailyAssignmentCreateOrConnectWithoutDriverInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutDriverInput | DailyAssignmentUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DailyAssignmentCreateManyDriverInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutDriverInput | DailyAssignmentUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutDriverInput | DailyAssignmentUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput> | DailyAssignmentAssistantCreateWithoutEmployeeInput[] | DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput | DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput[]
    upsert?: DailyAssignmentAssistantUpsertWithWhereUniqueWithoutEmployeeInput | DailyAssignmentAssistantUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DailyAssignmentAssistantCreateManyEmployeeInputEnvelope
    set?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    disconnect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    delete?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    update?: DailyAssignmentAssistantUpdateWithWhereUniqueWithoutEmployeeInput | DailyAssignmentAssistantUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DailyAssignmentAssistantUpdateManyWithWhereWithoutEmployeeInput | DailyAssignmentAssistantUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DailyAssignmentAssistantScalarWhereInput | DailyAssignmentAssistantScalarWhereInput[]
  }

  export type WorkCardEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkCardEntryCreateWithoutEmployeeInput, WorkCardEntryUncheckedCreateWithoutEmployeeInput> | WorkCardEntryCreateWithoutEmployeeInput[] | WorkCardEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutEmployeeInput | WorkCardEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkCardEntryUpsertWithWhereUniqueWithoutEmployeeInput | WorkCardEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkCardEntryCreateManyEmployeeInputEnvelope
    set?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    disconnect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    delete?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    update?: WorkCardEntryUpdateWithWhereUniqueWithoutEmployeeInput | WorkCardEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkCardEntryUpdateManyWithWhereWithoutEmployeeInput | WorkCardEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkCardEntryScalarWhereInput | WorkCardEntryScalarWhereInput[]
  }

  export type DailyAssignmentCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DailyAssignmentCreateWithoutVehicleInput, DailyAssignmentUncheckedCreateWithoutVehicleInput> | DailyAssignmentCreateWithoutVehicleInput[] | DailyAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutVehicleInput | DailyAssignmentCreateOrConnectWithoutVehicleInput[]
    createMany?: DailyAssignmentCreateManyVehicleInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type VehicleFaultReportCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleFaultReportCreateWithoutVehicleInput, VehicleFaultReportUncheckedCreateWithoutVehicleInput> | VehicleFaultReportCreateWithoutVehicleInput[] | VehicleFaultReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleFaultReportCreateOrConnectWithoutVehicleInput | VehicleFaultReportCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleFaultReportCreateManyVehicleInputEnvelope
    connect?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
  }

  export type DailyAssignmentUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DailyAssignmentCreateWithoutVehicleInput, DailyAssignmentUncheckedCreateWithoutVehicleInput> | DailyAssignmentCreateWithoutVehicleInput[] | DailyAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutVehicleInput | DailyAssignmentCreateOrConnectWithoutVehicleInput[]
    createMany?: DailyAssignmentCreateManyVehicleInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type VehicleFaultReportUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<VehicleFaultReportCreateWithoutVehicleInput, VehicleFaultReportUncheckedCreateWithoutVehicleInput> | VehicleFaultReportCreateWithoutVehicleInput[] | VehicleFaultReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleFaultReportCreateOrConnectWithoutVehicleInput | VehicleFaultReportCreateOrConnectWithoutVehicleInput[]
    createMany?: VehicleFaultReportCreateManyVehicleInputEnvelope
    connect?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DailyAssignmentUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutVehicleInput, DailyAssignmentUncheckedCreateWithoutVehicleInput> | DailyAssignmentCreateWithoutVehicleInput[] | DailyAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutVehicleInput | DailyAssignmentCreateOrConnectWithoutVehicleInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutVehicleInput | DailyAssignmentUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DailyAssignmentCreateManyVehicleInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutVehicleInput | DailyAssignmentUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutVehicleInput | DailyAssignmentUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type VehicleFaultReportUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleFaultReportCreateWithoutVehicleInput, VehicleFaultReportUncheckedCreateWithoutVehicleInput> | VehicleFaultReportCreateWithoutVehicleInput[] | VehicleFaultReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleFaultReportCreateOrConnectWithoutVehicleInput | VehicleFaultReportCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleFaultReportUpsertWithWhereUniqueWithoutVehicleInput | VehicleFaultReportUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleFaultReportCreateManyVehicleInputEnvelope
    set?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    disconnect?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    delete?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    connect?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    update?: VehicleFaultReportUpdateWithWhereUniqueWithoutVehicleInput | VehicleFaultReportUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleFaultReportUpdateManyWithWhereWithoutVehicleInput | VehicleFaultReportUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleFaultReportScalarWhereInput | VehicleFaultReportScalarWhereInput[]
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutVehicleInput, DailyAssignmentUncheckedCreateWithoutVehicleInput> | DailyAssignmentCreateWithoutVehicleInput[] | DailyAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutVehicleInput | DailyAssignmentCreateOrConnectWithoutVehicleInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutVehicleInput | DailyAssignmentUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DailyAssignmentCreateManyVehicleInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutVehicleInput | DailyAssignmentUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutVehicleInput | DailyAssignmentUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type VehicleFaultReportUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<VehicleFaultReportCreateWithoutVehicleInput, VehicleFaultReportUncheckedCreateWithoutVehicleInput> | VehicleFaultReportCreateWithoutVehicleInput[] | VehicleFaultReportUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: VehicleFaultReportCreateOrConnectWithoutVehicleInput | VehicleFaultReportCreateOrConnectWithoutVehicleInput[]
    upsert?: VehicleFaultReportUpsertWithWhereUniqueWithoutVehicleInput | VehicleFaultReportUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: VehicleFaultReportCreateManyVehicleInputEnvelope
    set?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    disconnect?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    delete?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    connect?: VehicleFaultReportWhereUniqueInput | VehicleFaultReportWhereUniqueInput[]
    update?: VehicleFaultReportUpdateWithWhereUniqueWithoutVehicleInput | VehicleFaultReportUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: VehicleFaultReportUpdateManyWithWhereWithoutVehicleInput | VehicleFaultReportUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: VehicleFaultReportScalarWhereInput | VehicleFaultReportScalarWhereInput[]
  }

  export type PointCreateNestedManyWithoutRegionInput = {
    create?: XOR<PointCreateWithoutRegionInput, PointUncheckedCreateWithoutRegionInput> | PointCreateWithoutRegionInput[] | PointUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PointCreateOrConnectWithoutRegionInput | PointCreateOrConnectWithoutRegionInput[]
    createMany?: PointCreateManyRegionInputEnvelope
    connect?: PointWhereUniqueInput | PointWhereUniqueInput[]
  }

  export type RegionFractionCreateNestedManyWithoutRegionInput = {
    create?: XOR<RegionFractionCreateWithoutRegionInput, RegionFractionUncheckedCreateWithoutRegionInput> | RegionFractionCreateWithoutRegionInput[] | RegionFractionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutRegionInput | RegionFractionCreateOrConnectWithoutRegionInput[]
    createMany?: RegionFractionCreateManyRegionInputEnvelope
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
  }

  export type CalendarEntryCreateNestedManyWithoutRegionInput = {
    create?: XOR<CalendarEntryCreateWithoutRegionInput, CalendarEntryUncheckedCreateWithoutRegionInput> | CalendarEntryCreateWithoutRegionInput[] | CalendarEntryUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutRegionInput | CalendarEntryCreateOrConnectWithoutRegionInput[]
    createMany?: CalendarEntryCreateManyRegionInputEnvelope
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
  }

  export type DailyAssignmentCreateNestedManyWithoutRegionInput = {
    create?: XOR<DailyAssignmentCreateWithoutRegionInput, DailyAssignmentUncheckedCreateWithoutRegionInput> | DailyAssignmentCreateWithoutRegionInput[] | DailyAssignmentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutRegionInput | DailyAssignmentCreateOrConnectWithoutRegionInput[]
    createMany?: DailyAssignmentCreateManyRegionInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type PointUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<PointCreateWithoutRegionInput, PointUncheckedCreateWithoutRegionInput> | PointCreateWithoutRegionInput[] | PointUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PointCreateOrConnectWithoutRegionInput | PointCreateOrConnectWithoutRegionInput[]
    createMany?: PointCreateManyRegionInputEnvelope
    connect?: PointWhereUniqueInput | PointWhereUniqueInput[]
  }

  export type RegionFractionUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<RegionFractionCreateWithoutRegionInput, RegionFractionUncheckedCreateWithoutRegionInput> | RegionFractionCreateWithoutRegionInput[] | RegionFractionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutRegionInput | RegionFractionCreateOrConnectWithoutRegionInput[]
    createMany?: RegionFractionCreateManyRegionInputEnvelope
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
  }

  export type CalendarEntryUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<CalendarEntryCreateWithoutRegionInput, CalendarEntryUncheckedCreateWithoutRegionInput> | CalendarEntryCreateWithoutRegionInput[] | CalendarEntryUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutRegionInput | CalendarEntryCreateOrConnectWithoutRegionInput[]
    createMany?: CalendarEntryCreateManyRegionInputEnvelope
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
  }

  export type DailyAssignmentUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<DailyAssignmentCreateWithoutRegionInput, DailyAssignmentUncheckedCreateWithoutRegionInput> | DailyAssignmentCreateWithoutRegionInput[] | DailyAssignmentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutRegionInput | DailyAssignmentCreateOrConnectWithoutRegionInput[]
    createMany?: DailyAssignmentCreateManyRegionInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type PointUpdateManyWithoutRegionNestedInput = {
    create?: XOR<PointCreateWithoutRegionInput, PointUncheckedCreateWithoutRegionInput> | PointCreateWithoutRegionInput[] | PointUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PointCreateOrConnectWithoutRegionInput | PointCreateOrConnectWithoutRegionInput[]
    upsert?: PointUpsertWithWhereUniqueWithoutRegionInput | PointUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: PointCreateManyRegionInputEnvelope
    set?: PointWhereUniqueInput | PointWhereUniqueInput[]
    disconnect?: PointWhereUniqueInput | PointWhereUniqueInput[]
    delete?: PointWhereUniqueInput | PointWhereUniqueInput[]
    connect?: PointWhereUniqueInput | PointWhereUniqueInput[]
    update?: PointUpdateWithWhereUniqueWithoutRegionInput | PointUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: PointUpdateManyWithWhereWithoutRegionInput | PointUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: PointScalarWhereInput | PointScalarWhereInput[]
  }

  export type RegionFractionUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RegionFractionCreateWithoutRegionInput, RegionFractionUncheckedCreateWithoutRegionInput> | RegionFractionCreateWithoutRegionInput[] | RegionFractionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutRegionInput | RegionFractionCreateOrConnectWithoutRegionInput[]
    upsert?: RegionFractionUpsertWithWhereUniqueWithoutRegionInput | RegionFractionUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RegionFractionCreateManyRegionInputEnvelope
    set?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    disconnect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    delete?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    update?: RegionFractionUpdateWithWhereUniqueWithoutRegionInput | RegionFractionUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RegionFractionUpdateManyWithWhereWithoutRegionInput | RegionFractionUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RegionFractionScalarWhereInput | RegionFractionScalarWhereInput[]
  }

  export type CalendarEntryUpdateManyWithoutRegionNestedInput = {
    create?: XOR<CalendarEntryCreateWithoutRegionInput, CalendarEntryUncheckedCreateWithoutRegionInput> | CalendarEntryCreateWithoutRegionInput[] | CalendarEntryUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutRegionInput | CalendarEntryCreateOrConnectWithoutRegionInput[]
    upsert?: CalendarEntryUpsertWithWhereUniqueWithoutRegionInput | CalendarEntryUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: CalendarEntryCreateManyRegionInputEnvelope
    set?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    disconnect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    delete?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    update?: CalendarEntryUpdateWithWhereUniqueWithoutRegionInput | CalendarEntryUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: CalendarEntryUpdateManyWithWhereWithoutRegionInput | CalendarEntryUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: CalendarEntryScalarWhereInput | CalendarEntryScalarWhereInput[]
  }

  export type DailyAssignmentUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutRegionInput, DailyAssignmentUncheckedCreateWithoutRegionInput> | DailyAssignmentCreateWithoutRegionInput[] | DailyAssignmentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutRegionInput | DailyAssignmentCreateOrConnectWithoutRegionInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutRegionInput | DailyAssignmentUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DailyAssignmentCreateManyRegionInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutRegionInput | DailyAssignmentUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutRegionInput | DailyAssignmentUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type PointUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<PointCreateWithoutRegionInput, PointUncheckedCreateWithoutRegionInput> | PointCreateWithoutRegionInput[] | PointUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PointCreateOrConnectWithoutRegionInput | PointCreateOrConnectWithoutRegionInput[]
    upsert?: PointUpsertWithWhereUniqueWithoutRegionInput | PointUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: PointCreateManyRegionInputEnvelope
    set?: PointWhereUniqueInput | PointWhereUniqueInput[]
    disconnect?: PointWhereUniqueInput | PointWhereUniqueInput[]
    delete?: PointWhereUniqueInput | PointWhereUniqueInput[]
    connect?: PointWhereUniqueInput | PointWhereUniqueInput[]
    update?: PointUpdateWithWhereUniqueWithoutRegionInput | PointUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: PointUpdateManyWithWhereWithoutRegionInput | PointUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: PointScalarWhereInput | PointScalarWhereInput[]
  }

  export type RegionFractionUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RegionFractionCreateWithoutRegionInput, RegionFractionUncheckedCreateWithoutRegionInput> | RegionFractionCreateWithoutRegionInput[] | RegionFractionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutRegionInput | RegionFractionCreateOrConnectWithoutRegionInput[]
    upsert?: RegionFractionUpsertWithWhereUniqueWithoutRegionInput | RegionFractionUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RegionFractionCreateManyRegionInputEnvelope
    set?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    disconnect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    delete?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    update?: RegionFractionUpdateWithWhereUniqueWithoutRegionInput | RegionFractionUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RegionFractionUpdateManyWithWhereWithoutRegionInput | RegionFractionUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RegionFractionScalarWhereInput | RegionFractionScalarWhereInput[]
  }

  export type CalendarEntryUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<CalendarEntryCreateWithoutRegionInput, CalendarEntryUncheckedCreateWithoutRegionInput> | CalendarEntryCreateWithoutRegionInput[] | CalendarEntryUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutRegionInput | CalendarEntryCreateOrConnectWithoutRegionInput[]
    upsert?: CalendarEntryUpsertWithWhereUniqueWithoutRegionInput | CalendarEntryUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: CalendarEntryCreateManyRegionInputEnvelope
    set?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    disconnect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    delete?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    update?: CalendarEntryUpdateWithWhereUniqueWithoutRegionInput | CalendarEntryUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: CalendarEntryUpdateManyWithWhereWithoutRegionInput | CalendarEntryUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: CalendarEntryScalarWhereInput | CalendarEntryScalarWhereInput[]
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutRegionInput, DailyAssignmentUncheckedCreateWithoutRegionInput> | DailyAssignmentCreateWithoutRegionInput[] | DailyAssignmentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutRegionInput | DailyAssignmentCreateOrConnectWithoutRegionInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutRegionInput | DailyAssignmentUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DailyAssignmentCreateManyRegionInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutRegionInput | DailyAssignmentUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutRegionInput | DailyAssignmentUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type PointFractionCreateNestedManyWithoutFractionInput = {
    create?: XOR<PointFractionCreateWithoutFractionInput, PointFractionUncheckedCreateWithoutFractionInput> | PointFractionCreateWithoutFractionInput[] | PointFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutFractionInput | PointFractionCreateOrConnectWithoutFractionInput[]
    createMany?: PointFractionCreateManyFractionInputEnvelope
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
  }

  export type RegionFractionCreateNestedManyWithoutFractionInput = {
    create?: XOR<RegionFractionCreateWithoutFractionInput, RegionFractionUncheckedCreateWithoutFractionInput> | RegionFractionCreateWithoutFractionInput[] | RegionFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutFractionInput | RegionFractionCreateOrConnectWithoutFractionInput[]
    createMany?: RegionFractionCreateManyFractionInputEnvelope
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
  }

  export type CalendarEntryCreateNestedManyWithoutFractionInput = {
    create?: XOR<CalendarEntryCreateWithoutFractionInput, CalendarEntryUncheckedCreateWithoutFractionInput> | CalendarEntryCreateWithoutFractionInput[] | CalendarEntryUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutFractionInput | CalendarEntryCreateOrConnectWithoutFractionInput[]
    createMany?: CalendarEntryCreateManyFractionInputEnvelope
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
  }

  export type DailyAssignmentFractionCreateNestedManyWithoutFractionInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutFractionInput, DailyAssignmentFractionUncheckedCreateWithoutFractionInput> | DailyAssignmentFractionCreateWithoutFractionInput[] | DailyAssignmentFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutFractionInput | DailyAssignmentFractionCreateOrConnectWithoutFractionInput[]
    createMany?: DailyAssignmentFractionCreateManyFractionInputEnvelope
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
  }

  export type PointFractionUncheckedCreateNestedManyWithoutFractionInput = {
    create?: XOR<PointFractionCreateWithoutFractionInput, PointFractionUncheckedCreateWithoutFractionInput> | PointFractionCreateWithoutFractionInput[] | PointFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutFractionInput | PointFractionCreateOrConnectWithoutFractionInput[]
    createMany?: PointFractionCreateManyFractionInputEnvelope
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
  }

  export type RegionFractionUncheckedCreateNestedManyWithoutFractionInput = {
    create?: XOR<RegionFractionCreateWithoutFractionInput, RegionFractionUncheckedCreateWithoutFractionInput> | RegionFractionCreateWithoutFractionInput[] | RegionFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutFractionInput | RegionFractionCreateOrConnectWithoutFractionInput[]
    createMany?: RegionFractionCreateManyFractionInputEnvelope
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
  }

  export type CalendarEntryUncheckedCreateNestedManyWithoutFractionInput = {
    create?: XOR<CalendarEntryCreateWithoutFractionInput, CalendarEntryUncheckedCreateWithoutFractionInput> | CalendarEntryCreateWithoutFractionInput[] | CalendarEntryUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutFractionInput | CalendarEntryCreateOrConnectWithoutFractionInput[]
    createMany?: CalendarEntryCreateManyFractionInputEnvelope
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
  }

  export type DailyAssignmentFractionUncheckedCreateNestedManyWithoutFractionInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutFractionInput, DailyAssignmentFractionUncheckedCreateWithoutFractionInput> | DailyAssignmentFractionCreateWithoutFractionInput[] | DailyAssignmentFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutFractionInput | DailyAssignmentFractionCreateOrConnectWithoutFractionInput[]
    createMany?: DailyAssignmentFractionCreateManyFractionInputEnvelope
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
  }

  export type PointFractionUpdateManyWithoutFractionNestedInput = {
    create?: XOR<PointFractionCreateWithoutFractionInput, PointFractionUncheckedCreateWithoutFractionInput> | PointFractionCreateWithoutFractionInput[] | PointFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutFractionInput | PointFractionCreateOrConnectWithoutFractionInput[]
    upsert?: PointFractionUpsertWithWhereUniqueWithoutFractionInput | PointFractionUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: PointFractionCreateManyFractionInputEnvelope
    set?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    disconnect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    delete?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    update?: PointFractionUpdateWithWhereUniqueWithoutFractionInput | PointFractionUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: PointFractionUpdateManyWithWhereWithoutFractionInput | PointFractionUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: PointFractionScalarWhereInput | PointFractionScalarWhereInput[]
  }

  export type RegionFractionUpdateManyWithoutFractionNestedInput = {
    create?: XOR<RegionFractionCreateWithoutFractionInput, RegionFractionUncheckedCreateWithoutFractionInput> | RegionFractionCreateWithoutFractionInput[] | RegionFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutFractionInput | RegionFractionCreateOrConnectWithoutFractionInput[]
    upsert?: RegionFractionUpsertWithWhereUniqueWithoutFractionInput | RegionFractionUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: RegionFractionCreateManyFractionInputEnvelope
    set?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    disconnect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    delete?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    update?: RegionFractionUpdateWithWhereUniqueWithoutFractionInput | RegionFractionUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: RegionFractionUpdateManyWithWhereWithoutFractionInput | RegionFractionUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: RegionFractionScalarWhereInput | RegionFractionScalarWhereInput[]
  }

  export type CalendarEntryUpdateManyWithoutFractionNestedInput = {
    create?: XOR<CalendarEntryCreateWithoutFractionInput, CalendarEntryUncheckedCreateWithoutFractionInput> | CalendarEntryCreateWithoutFractionInput[] | CalendarEntryUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutFractionInput | CalendarEntryCreateOrConnectWithoutFractionInput[]
    upsert?: CalendarEntryUpsertWithWhereUniqueWithoutFractionInput | CalendarEntryUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: CalendarEntryCreateManyFractionInputEnvelope
    set?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    disconnect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    delete?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    update?: CalendarEntryUpdateWithWhereUniqueWithoutFractionInput | CalendarEntryUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: CalendarEntryUpdateManyWithWhereWithoutFractionInput | CalendarEntryUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: CalendarEntryScalarWhereInput | CalendarEntryScalarWhereInput[]
  }

  export type DailyAssignmentFractionUpdateManyWithoutFractionNestedInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutFractionInput, DailyAssignmentFractionUncheckedCreateWithoutFractionInput> | DailyAssignmentFractionCreateWithoutFractionInput[] | DailyAssignmentFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutFractionInput | DailyAssignmentFractionCreateOrConnectWithoutFractionInput[]
    upsert?: DailyAssignmentFractionUpsertWithWhereUniqueWithoutFractionInput | DailyAssignmentFractionUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: DailyAssignmentFractionCreateManyFractionInputEnvelope
    set?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    disconnect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    delete?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    update?: DailyAssignmentFractionUpdateWithWhereUniqueWithoutFractionInput | DailyAssignmentFractionUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: DailyAssignmentFractionUpdateManyWithWhereWithoutFractionInput | DailyAssignmentFractionUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: DailyAssignmentFractionScalarWhereInput | DailyAssignmentFractionScalarWhereInput[]
  }

  export type PointFractionUncheckedUpdateManyWithoutFractionNestedInput = {
    create?: XOR<PointFractionCreateWithoutFractionInput, PointFractionUncheckedCreateWithoutFractionInput> | PointFractionCreateWithoutFractionInput[] | PointFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutFractionInput | PointFractionCreateOrConnectWithoutFractionInput[]
    upsert?: PointFractionUpsertWithWhereUniqueWithoutFractionInput | PointFractionUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: PointFractionCreateManyFractionInputEnvelope
    set?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    disconnect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    delete?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    update?: PointFractionUpdateWithWhereUniqueWithoutFractionInput | PointFractionUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: PointFractionUpdateManyWithWhereWithoutFractionInput | PointFractionUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: PointFractionScalarWhereInput | PointFractionScalarWhereInput[]
  }

  export type RegionFractionUncheckedUpdateManyWithoutFractionNestedInput = {
    create?: XOR<RegionFractionCreateWithoutFractionInput, RegionFractionUncheckedCreateWithoutFractionInput> | RegionFractionCreateWithoutFractionInput[] | RegionFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: RegionFractionCreateOrConnectWithoutFractionInput | RegionFractionCreateOrConnectWithoutFractionInput[]
    upsert?: RegionFractionUpsertWithWhereUniqueWithoutFractionInput | RegionFractionUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: RegionFractionCreateManyFractionInputEnvelope
    set?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    disconnect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    delete?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    connect?: RegionFractionWhereUniqueInput | RegionFractionWhereUniqueInput[]
    update?: RegionFractionUpdateWithWhereUniqueWithoutFractionInput | RegionFractionUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: RegionFractionUpdateManyWithWhereWithoutFractionInput | RegionFractionUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: RegionFractionScalarWhereInput | RegionFractionScalarWhereInput[]
  }

  export type CalendarEntryUncheckedUpdateManyWithoutFractionNestedInput = {
    create?: XOR<CalendarEntryCreateWithoutFractionInput, CalendarEntryUncheckedCreateWithoutFractionInput> | CalendarEntryCreateWithoutFractionInput[] | CalendarEntryUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: CalendarEntryCreateOrConnectWithoutFractionInput | CalendarEntryCreateOrConnectWithoutFractionInput[]
    upsert?: CalendarEntryUpsertWithWhereUniqueWithoutFractionInput | CalendarEntryUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: CalendarEntryCreateManyFractionInputEnvelope
    set?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    disconnect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    delete?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    connect?: CalendarEntryWhereUniqueInput | CalendarEntryWhereUniqueInput[]
    update?: CalendarEntryUpdateWithWhereUniqueWithoutFractionInput | CalendarEntryUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: CalendarEntryUpdateManyWithWhereWithoutFractionInput | CalendarEntryUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: CalendarEntryScalarWhereInput | CalendarEntryScalarWhereInput[]
  }

  export type DailyAssignmentFractionUncheckedUpdateManyWithoutFractionNestedInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutFractionInput, DailyAssignmentFractionUncheckedCreateWithoutFractionInput> | DailyAssignmentFractionCreateWithoutFractionInput[] | DailyAssignmentFractionUncheckedCreateWithoutFractionInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutFractionInput | DailyAssignmentFractionCreateOrConnectWithoutFractionInput[]
    upsert?: DailyAssignmentFractionUpsertWithWhereUniqueWithoutFractionInput | DailyAssignmentFractionUpsertWithWhereUniqueWithoutFractionInput[]
    createMany?: DailyAssignmentFractionCreateManyFractionInputEnvelope
    set?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    disconnect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    delete?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    update?: DailyAssignmentFractionUpdateWithWhereUniqueWithoutFractionInput | DailyAssignmentFractionUpdateWithWhereUniqueWithoutFractionInput[]
    updateMany?: DailyAssignmentFractionUpdateManyWithWhereWithoutFractionInput | DailyAssignmentFractionUpdateManyWithWhereWithoutFractionInput[]
    deleteMany?: DailyAssignmentFractionScalarWhereInput | DailyAssignmentFractionScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutPointsInput = {
    create?: XOR<RegionCreateWithoutPointsInput, RegionUncheckedCreateWithoutPointsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPointsInput
    connect?: RegionWhereUniqueInput
  }

  export type PointFractionCreateNestedManyWithoutPointInput = {
    create?: XOR<PointFractionCreateWithoutPointInput, PointFractionUncheckedCreateWithoutPointInput> | PointFractionCreateWithoutPointInput[] | PointFractionUncheckedCreateWithoutPointInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutPointInput | PointFractionCreateOrConnectWithoutPointInput[]
    createMany?: PointFractionCreateManyPointInputEnvelope
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
  }

  export type PointFractionUncheckedCreateNestedManyWithoutPointInput = {
    create?: XOR<PointFractionCreateWithoutPointInput, PointFractionUncheckedCreateWithoutPointInput> | PointFractionCreateWithoutPointInput[] | PointFractionUncheckedCreateWithoutPointInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutPointInput | PointFractionCreateOrConnectWithoutPointInput[]
    createMany?: PointFractionCreateManyPointInputEnvelope
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
  }

  export type RegionUpdateOneWithoutPointsNestedInput = {
    create?: XOR<RegionCreateWithoutPointsInput, RegionUncheckedCreateWithoutPointsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPointsInput
    upsert?: RegionUpsertWithoutPointsInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutPointsInput, RegionUpdateWithoutPointsInput>, RegionUncheckedUpdateWithoutPointsInput>
  }

  export type PointFractionUpdateManyWithoutPointNestedInput = {
    create?: XOR<PointFractionCreateWithoutPointInput, PointFractionUncheckedCreateWithoutPointInput> | PointFractionCreateWithoutPointInput[] | PointFractionUncheckedCreateWithoutPointInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutPointInput | PointFractionCreateOrConnectWithoutPointInput[]
    upsert?: PointFractionUpsertWithWhereUniqueWithoutPointInput | PointFractionUpsertWithWhereUniqueWithoutPointInput[]
    createMany?: PointFractionCreateManyPointInputEnvelope
    set?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    disconnect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    delete?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    update?: PointFractionUpdateWithWhereUniqueWithoutPointInput | PointFractionUpdateWithWhereUniqueWithoutPointInput[]
    updateMany?: PointFractionUpdateManyWithWhereWithoutPointInput | PointFractionUpdateManyWithWhereWithoutPointInput[]
    deleteMany?: PointFractionScalarWhereInput | PointFractionScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PointFractionUncheckedUpdateManyWithoutPointNestedInput = {
    create?: XOR<PointFractionCreateWithoutPointInput, PointFractionUncheckedCreateWithoutPointInput> | PointFractionCreateWithoutPointInput[] | PointFractionUncheckedCreateWithoutPointInput[]
    connectOrCreate?: PointFractionCreateOrConnectWithoutPointInput | PointFractionCreateOrConnectWithoutPointInput[]
    upsert?: PointFractionUpsertWithWhereUniqueWithoutPointInput | PointFractionUpsertWithWhereUniqueWithoutPointInput[]
    createMany?: PointFractionCreateManyPointInputEnvelope
    set?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    disconnect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    delete?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    connect?: PointFractionWhereUniqueInput | PointFractionWhereUniqueInput[]
    update?: PointFractionUpdateWithWhereUniqueWithoutPointInput | PointFractionUpdateWithWhereUniqueWithoutPointInput[]
    updateMany?: PointFractionUpdateManyWithWhereWithoutPointInput | PointFractionUpdateManyWithWhereWithoutPointInput[]
    deleteMany?: PointFractionScalarWhereInput | PointFractionScalarWhereInput[]
  }

  export type PointCreateNestedOneWithoutPointFractionsInput = {
    create?: XOR<PointCreateWithoutPointFractionsInput, PointUncheckedCreateWithoutPointFractionsInput>
    connectOrCreate?: PointCreateOrConnectWithoutPointFractionsInput
    connect?: PointWhereUniqueInput
  }

  export type FractionCreateNestedOneWithoutPointFractionsInput = {
    create?: XOR<FractionCreateWithoutPointFractionsInput, FractionUncheckedCreateWithoutPointFractionsInput>
    connectOrCreate?: FractionCreateOrConnectWithoutPointFractionsInput
    connect?: FractionWhereUniqueInput
  }

  export type PointUpdateOneRequiredWithoutPointFractionsNestedInput = {
    create?: XOR<PointCreateWithoutPointFractionsInput, PointUncheckedCreateWithoutPointFractionsInput>
    connectOrCreate?: PointCreateOrConnectWithoutPointFractionsInput
    upsert?: PointUpsertWithoutPointFractionsInput
    connect?: PointWhereUniqueInput
    update?: XOR<XOR<PointUpdateToOneWithWhereWithoutPointFractionsInput, PointUpdateWithoutPointFractionsInput>, PointUncheckedUpdateWithoutPointFractionsInput>
  }

  export type FractionUpdateOneRequiredWithoutPointFractionsNestedInput = {
    create?: XOR<FractionCreateWithoutPointFractionsInput, FractionUncheckedCreateWithoutPointFractionsInput>
    connectOrCreate?: FractionCreateOrConnectWithoutPointFractionsInput
    upsert?: FractionUpsertWithoutPointFractionsInput
    connect?: FractionWhereUniqueInput
    update?: XOR<XOR<FractionUpdateToOneWithWhereWithoutPointFractionsInput, FractionUpdateWithoutPointFractionsInput>, FractionUncheckedUpdateWithoutPointFractionsInput>
  }

  export type EmployeeCreateNestedOneWithoutEmployeeSchedulesInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeSchedulesInput, EmployeeUncheckedCreateWithoutEmployeeSchedulesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeSchedulesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeeSchedulesNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeSchedulesInput, EmployeeUncheckedCreateWithoutEmployeeSchedulesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeSchedulesInput
    upsert?: EmployeeUpsertWithoutEmployeeSchedulesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeeSchedulesInput, EmployeeUpdateWithoutEmployeeSchedulesInput>, EmployeeUncheckedUpdateWithoutEmployeeSchedulesInput>
  }

  export type RegionCreateNestedOneWithoutRegionFractionsInput = {
    create?: XOR<RegionCreateWithoutRegionFractionsInput, RegionUncheckedCreateWithoutRegionFractionsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutRegionFractionsInput
    connect?: RegionWhereUniqueInput
  }

  export type FractionCreateNestedOneWithoutRegionFractionsInput = {
    create?: XOR<FractionCreateWithoutRegionFractionsInput, FractionUncheckedCreateWithoutRegionFractionsInput>
    connectOrCreate?: FractionCreateOrConnectWithoutRegionFractionsInput
    connect?: FractionWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutRegionFractionsNestedInput = {
    create?: XOR<RegionCreateWithoutRegionFractionsInput, RegionUncheckedCreateWithoutRegionFractionsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutRegionFractionsInput
    upsert?: RegionUpsertWithoutRegionFractionsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutRegionFractionsInput, RegionUpdateWithoutRegionFractionsInput>, RegionUncheckedUpdateWithoutRegionFractionsInput>
  }

  export type FractionUpdateOneRequiredWithoutRegionFractionsNestedInput = {
    create?: XOR<FractionCreateWithoutRegionFractionsInput, FractionUncheckedCreateWithoutRegionFractionsInput>
    connectOrCreate?: FractionCreateOrConnectWithoutRegionFractionsInput
    upsert?: FractionUpsertWithoutRegionFractionsInput
    connect?: FractionWhereUniqueInput
    update?: XOR<XOR<FractionUpdateToOneWithWhereWithoutRegionFractionsInput, FractionUpdateWithoutRegionFractionsInput>, FractionUncheckedUpdateWithoutRegionFractionsInput>
  }

  export type RegionCreateNestedOneWithoutCalendarEntriesInput = {
    create?: XOR<RegionCreateWithoutCalendarEntriesInput, RegionUncheckedCreateWithoutCalendarEntriesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutCalendarEntriesInput
    connect?: RegionWhereUniqueInput
  }

  export type FractionCreateNestedOneWithoutCalendarEntriesInput = {
    create?: XOR<FractionCreateWithoutCalendarEntriesInput, FractionUncheckedCreateWithoutCalendarEntriesInput>
    connectOrCreate?: FractionCreateOrConnectWithoutCalendarEntriesInput
    connect?: FractionWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutCalendarEntriesNestedInput = {
    create?: XOR<RegionCreateWithoutCalendarEntriesInput, RegionUncheckedCreateWithoutCalendarEntriesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutCalendarEntriesInput
    upsert?: RegionUpsertWithoutCalendarEntriesInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutCalendarEntriesInput, RegionUpdateWithoutCalendarEntriesInput>, RegionUncheckedUpdateWithoutCalendarEntriesInput>
  }

  export type FractionUpdateOneRequiredWithoutCalendarEntriesNestedInput = {
    create?: XOR<FractionCreateWithoutCalendarEntriesInput, FractionUncheckedCreateWithoutCalendarEntriesInput>
    connectOrCreate?: FractionCreateOrConnectWithoutCalendarEntriesInput
    upsert?: FractionUpsertWithoutCalendarEntriesInput
    connect?: FractionWhereUniqueInput
    update?: XOR<XOR<FractionUpdateToOneWithWhereWithoutCalendarEntriesInput, FractionUpdateWithoutCalendarEntriesInput>, FractionUncheckedUpdateWithoutCalendarEntriesInput>
  }

  export type MunicipalityCreateNestedOneWithoutDailyAssignmentsInput = {
    create?: XOR<MunicipalityCreateWithoutDailyAssignmentsInput, MunicipalityUncheckedCreateWithoutDailyAssignmentsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDailyAssignmentsInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutDailyAssignmentsInput = {
    create?: XOR<RegionCreateWithoutDailyAssignmentsInput, RegionUncheckedCreateWithoutDailyAssignmentsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDailyAssignmentsInput
    connect?: RegionWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutDailyAssignmentsInput = {
    create?: XOR<VehicleCreateWithoutDailyAssignmentsInput, VehicleUncheckedCreateWithoutDailyAssignmentsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDailyAssignmentsInput
    connect?: VehicleWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutDrivenAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutDrivenAssignmentsInput, EmployeeUncheckedCreateWithoutDrivenAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDrivenAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentAssistantCreateWithoutDailyAssignmentInput[] | DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentAssistantCreateManyDailyAssignmentInputEnvelope
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
  }

  export type DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentFractionCreateWithoutDailyAssignmentInput[] | DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentFractionCreateManyDailyAssignmentInputEnvelope
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
  }

  export type DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentAssistantCreateWithoutDailyAssignmentInput[] | DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentAssistantCreateManyDailyAssignmentInputEnvelope
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
  }

  export type DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentFractionCreateWithoutDailyAssignmentInput[] | DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentFractionCreateManyDailyAssignmentInputEnvelope
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
  }

  export type EnumDailyAssignmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DailyAssignmentType
  }

  export type MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput = {
    create?: XOR<MunicipalityCreateWithoutDailyAssignmentsInput, MunicipalityUncheckedCreateWithoutDailyAssignmentsInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDailyAssignmentsInput
    upsert?: MunicipalityUpsertWithoutDailyAssignmentsInput
    disconnect?: MunicipalityWhereInput | boolean
    delete?: MunicipalityWhereInput | boolean
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutDailyAssignmentsInput, MunicipalityUpdateWithoutDailyAssignmentsInput>, MunicipalityUncheckedUpdateWithoutDailyAssignmentsInput>
  }

  export type RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput = {
    create?: XOR<RegionCreateWithoutDailyAssignmentsInput, RegionUncheckedCreateWithoutDailyAssignmentsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDailyAssignmentsInput
    upsert?: RegionUpsertWithoutDailyAssignmentsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutDailyAssignmentsInput, RegionUpdateWithoutDailyAssignmentsInput>, RegionUncheckedUpdateWithoutDailyAssignmentsInput>
  }

  export type VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput = {
    create?: XOR<VehicleCreateWithoutDailyAssignmentsInput, VehicleUncheckedCreateWithoutDailyAssignmentsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDailyAssignmentsInput
    upsert?: VehicleUpsertWithoutDailyAssignmentsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDailyAssignmentsInput, VehicleUpdateWithoutDailyAssignmentsInput>, VehicleUncheckedUpdateWithoutDailyAssignmentsInput>
  }

  export type EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDrivenAssignmentsInput, EmployeeUncheckedCreateWithoutDrivenAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDrivenAssignmentsInput
    upsert?: EmployeeUpsertWithoutDrivenAssignmentsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDrivenAssignmentsInput, EmployeeUpdateWithoutDrivenAssignmentsInput>, EmployeeUncheckedUpdateWithoutDrivenAssignmentsInput>
  }

  export type DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentAssistantCreateWithoutDailyAssignmentInput[] | DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput[]
    upsert?: DailyAssignmentAssistantUpsertWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentAssistantUpsertWithWhereUniqueWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentAssistantCreateManyDailyAssignmentInputEnvelope
    set?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    disconnect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    delete?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    update?: DailyAssignmentAssistantUpdateWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentAssistantUpdateWithWhereUniqueWithoutDailyAssignmentInput[]
    updateMany?: DailyAssignmentAssistantUpdateManyWithWhereWithoutDailyAssignmentInput | DailyAssignmentAssistantUpdateManyWithWhereWithoutDailyAssignmentInput[]
    deleteMany?: DailyAssignmentAssistantScalarWhereInput | DailyAssignmentAssistantScalarWhereInput[]
  }

  export type DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentFractionCreateWithoutDailyAssignmentInput[] | DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput[]
    upsert?: DailyAssignmentFractionUpsertWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentFractionUpsertWithWhereUniqueWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentFractionCreateManyDailyAssignmentInputEnvelope
    set?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    disconnect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    delete?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    update?: DailyAssignmentFractionUpdateWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentFractionUpdateWithWhereUniqueWithoutDailyAssignmentInput[]
    updateMany?: DailyAssignmentFractionUpdateManyWithWhereWithoutDailyAssignmentInput | DailyAssignmentFractionUpdateManyWithWhereWithoutDailyAssignmentInput[]
    deleteMany?: DailyAssignmentFractionScalarWhereInput | DailyAssignmentFractionScalarWhereInput[]
  }

  export type DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput = {
    create?: XOR<DailyAssignmentAssistantCreateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentAssistantCreateWithoutDailyAssignmentInput[] | DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput[]
    upsert?: DailyAssignmentAssistantUpsertWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentAssistantUpsertWithWhereUniqueWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentAssistantCreateManyDailyAssignmentInputEnvelope
    set?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    disconnect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    delete?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    connect?: DailyAssignmentAssistantWhereUniqueInput | DailyAssignmentAssistantWhereUniqueInput[]
    update?: DailyAssignmentAssistantUpdateWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentAssistantUpdateWithWhereUniqueWithoutDailyAssignmentInput[]
    updateMany?: DailyAssignmentAssistantUpdateManyWithWhereWithoutDailyAssignmentInput | DailyAssignmentAssistantUpdateManyWithWhereWithoutDailyAssignmentInput[]
    deleteMany?: DailyAssignmentAssistantScalarWhereInput | DailyAssignmentAssistantScalarWhereInput[]
  }

  export type DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput = {
    create?: XOR<DailyAssignmentFractionCreateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput> | DailyAssignmentFractionCreateWithoutDailyAssignmentInput[] | DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput[]
    connectOrCreate?: DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput | DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput[]
    upsert?: DailyAssignmentFractionUpsertWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentFractionUpsertWithWhereUniqueWithoutDailyAssignmentInput[]
    createMany?: DailyAssignmentFractionCreateManyDailyAssignmentInputEnvelope
    set?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    disconnect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    delete?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    connect?: DailyAssignmentFractionWhereUniqueInput | DailyAssignmentFractionWhereUniqueInput[]
    update?: DailyAssignmentFractionUpdateWithWhereUniqueWithoutDailyAssignmentInput | DailyAssignmentFractionUpdateWithWhereUniqueWithoutDailyAssignmentInput[]
    updateMany?: DailyAssignmentFractionUpdateManyWithWhereWithoutDailyAssignmentInput | DailyAssignmentFractionUpdateManyWithWhereWithoutDailyAssignmentInput[]
    deleteMany?: DailyAssignmentFractionScalarWhereInput | DailyAssignmentFractionScalarWhereInput[]
  }

  export type DailyAssignmentCreateNestedOneWithoutAssistantsInput = {
    create?: XOR<DailyAssignmentCreateWithoutAssistantsInput, DailyAssignmentUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutAssistantsInput
    connect?: DailyAssignmentWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutAssistantAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutAssistantAssignmentsInput, EmployeeUncheckedCreateWithoutAssistantAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssistantAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type DailyAssignmentUpdateOneRequiredWithoutAssistantsNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutAssistantsInput, DailyAssignmentUncheckedCreateWithoutAssistantsInput>
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutAssistantsInput
    upsert?: DailyAssignmentUpsertWithoutAssistantsInput
    connect?: DailyAssignmentWhereUniqueInput
    update?: XOR<XOR<DailyAssignmentUpdateToOneWithWhereWithoutAssistantsInput, DailyAssignmentUpdateWithoutAssistantsInput>, DailyAssignmentUncheckedUpdateWithoutAssistantsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutAssistantAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAssistantAssignmentsInput, EmployeeUncheckedCreateWithoutAssistantAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssistantAssignmentsInput
    upsert?: EmployeeUpsertWithoutAssistantAssignmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAssistantAssignmentsInput, EmployeeUpdateWithoutAssistantAssignmentsInput>, EmployeeUncheckedUpdateWithoutAssistantAssignmentsInput>
  }

  export type DailyAssignmentCreateNestedOneWithoutFractionsInput = {
    create?: XOR<DailyAssignmentCreateWithoutFractionsInput, DailyAssignmentUncheckedCreateWithoutFractionsInput>
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutFractionsInput
    connect?: DailyAssignmentWhereUniqueInput
  }

  export type FractionCreateNestedOneWithoutFractionsInAssignmentsInput = {
    create?: XOR<FractionCreateWithoutFractionsInAssignmentsInput, FractionUncheckedCreateWithoutFractionsInAssignmentsInput>
    connectOrCreate?: FractionCreateOrConnectWithoutFractionsInAssignmentsInput
    connect?: FractionWhereUniqueInput
  }

  export type DailyAssignmentUpdateOneRequiredWithoutFractionsNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutFractionsInput, DailyAssignmentUncheckedCreateWithoutFractionsInput>
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutFractionsInput
    upsert?: DailyAssignmentUpsertWithoutFractionsInput
    connect?: DailyAssignmentWhereUniqueInput
    update?: XOR<XOR<DailyAssignmentUpdateToOneWithWhereWithoutFractionsInput, DailyAssignmentUpdateWithoutFractionsInput>, DailyAssignmentUncheckedUpdateWithoutFractionsInput>
  }

  export type FractionUpdateOneRequiredWithoutFractionsInAssignmentsNestedInput = {
    create?: XOR<FractionCreateWithoutFractionsInAssignmentsInput, FractionUncheckedCreateWithoutFractionsInAssignmentsInput>
    connectOrCreate?: FractionCreateOrConnectWithoutFractionsInAssignmentsInput
    upsert?: FractionUpsertWithoutFractionsInAssignmentsInput
    connect?: FractionWhereUniqueInput
    update?: XOR<XOR<FractionUpdateToOneWithWhereWithoutFractionsInAssignmentsInput, FractionUpdateWithoutFractionsInAssignmentsInput>, FractionUncheckedUpdateWithoutFractionsInAssignmentsInput>
  }

  export type VehicleCreateNestedOneWithoutFaultReportsInput = {
    create?: XOR<VehicleCreateWithoutFaultReportsInput, VehicleUncheckedCreateWithoutFaultReportsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutFaultReportsInput
    connect?: VehicleWhereUniqueInput
  }

  export type VehicleUpdateOneRequiredWithoutFaultReportsNestedInput = {
    create?: XOR<VehicleCreateWithoutFaultReportsInput, VehicleUncheckedCreateWithoutFaultReportsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutFaultReportsInput
    upsert?: VehicleUpsertWithoutFaultReportsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutFaultReportsInput, VehicleUpdateWithoutFaultReportsInput>, VehicleUncheckedUpdateWithoutFaultReportsInput>
  }

  export type DailyAssignmentCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<DailyAssignmentCreateWithoutMunicipalityInput, DailyAssignmentUncheckedCreateWithoutMunicipalityInput> | DailyAssignmentCreateWithoutMunicipalityInput[] | DailyAssignmentUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutMunicipalityInput | DailyAssignmentCreateOrConnectWithoutMunicipalityInput[]
    createMany?: DailyAssignmentCreateManyMunicipalityInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type DailyAssignmentUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<DailyAssignmentCreateWithoutMunicipalityInput, DailyAssignmentUncheckedCreateWithoutMunicipalityInput> | DailyAssignmentCreateWithoutMunicipalityInput[] | DailyAssignmentUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutMunicipalityInput | DailyAssignmentCreateOrConnectWithoutMunicipalityInput[]
    createMany?: DailyAssignmentCreateManyMunicipalityInputEnvelope
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
  }

  export type DailyAssignmentUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutMunicipalityInput, DailyAssignmentUncheckedCreateWithoutMunicipalityInput> | DailyAssignmentCreateWithoutMunicipalityInput[] | DailyAssignmentUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutMunicipalityInput | DailyAssignmentCreateOrConnectWithoutMunicipalityInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutMunicipalityInput | DailyAssignmentUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: DailyAssignmentCreateManyMunicipalityInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutMunicipalityInput | DailyAssignmentUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutMunicipalityInput | DailyAssignmentUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<DailyAssignmentCreateWithoutMunicipalityInput, DailyAssignmentUncheckedCreateWithoutMunicipalityInput> | DailyAssignmentCreateWithoutMunicipalityInput[] | DailyAssignmentUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: DailyAssignmentCreateOrConnectWithoutMunicipalityInput | DailyAssignmentCreateOrConnectWithoutMunicipalityInput[]
    upsert?: DailyAssignmentUpsertWithWhereUniqueWithoutMunicipalityInput | DailyAssignmentUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: DailyAssignmentCreateManyMunicipalityInputEnvelope
    set?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    disconnect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    delete?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    connect?: DailyAssignmentWhereUniqueInput | DailyAssignmentWhereUniqueInput[]
    update?: DailyAssignmentUpdateWithWhereUniqueWithoutMunicipalityInput | DailyAssignmentUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: DailyAssignmentUpdateManyWithWhereWithoutMunicipalityInput | DailyAssignmentUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
  }

  export type WorkCardEntryCreateNestedManyWithoutAbsenceTypeInput = {
    create?: XOR<WorkCardEntryCreateWithoutAbsenceTypeInput, WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput> | WorkCardEntryCreateWithoutAbsenceTypeInput[] | WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput | WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput[]
    createMany?: WorkCardEntryCreateManyAbsenceTypeInputEnvelope
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
  }

  export type WorkCardEntryUncheckedCreateNestedManyWithoutAbsenceTypeInput = {
    create?: XOR<WorkCardEntryCreateWithoutAbsenceTypeInput, WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput> | WorkCardEntryCreateWithoutAbsenceTypeInput[] | WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput | WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput[]
    createMany?: WorkCardEntryCreateManyAbsenceTypeInputEnvelope
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
  }

  export type WorkCardEntryUpdateManyWithoutAbsenceTypeNestedInput = {
    create?: XOR<WorkCardEntryCreateWithoutAbsenceTypeInput, WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput> | WorkCardEntryCreateWithoutAbsenceTypeInput[] | WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput | WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput[]
    upsert?: WorkCardEntryUpsertWithWhereUniqueWithoutAbsenceTypeInput | WorkCardEntryUpsertWithWhereUniqueWithoutAbsenceTypeInput[]
    createMany?: WorkCardEntryCreateManyAbsenceTypeInputEnvelope
    set?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    disconnect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    delete?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    update?: WorkCardEntryUpdateWithWhereUniqueWithoutAbsenceTypeInput | WorkCardEntryUpdateWithWhereUniqueWithoutAbsenceTypeInput[]
    updateMany?: WorkCardEntryUpdateManyWithWhereWithoutAbsenceTypeInput | WorkCardEntryUpdateManyWithWhereWithoutAbsenceTypeInput[]
    deleteMany?: WorkCardEntryScalarWhereInput | WorkCardEntryScalarWhereInput[]
  }

  export type WorkCardEntryUncheckedUpdateManyWithoutAbsenceTypeNestedInput = {
    create?: XOR<WorkCardEntryCreateWithoutAbsenceTypeInput, WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput> | WorkCardEntryCreateWithoutAbsenceTypeInput[] | WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput[]
    connectOrCreate?: WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput | WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput[]
    upsert?: WorkCardEntryUpsertWithWhereUniqueWithoutAbsenceTypeInput | WorkCardEntryUpsertWithWhereUniqueWithoutAbsenceTypeInput[]
    createMany?: WorkCardEntryCreateManyAbsenceTypeInputEnvelope
    set?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    disconnect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    delete?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    connect?: WorkCardEntryWhereUniqueInput | WorkCardEntryWhereUniqueInput[]
    update?: WorkCardEntryUpdateWithWhereUniqueWithoutAbsenceTypeInput | WorkCardEntryUpdateWithWhereUniqueWithoutAbsenceTypeInput[]
    updateMany?: WorkCardEntryUpdateManyWithWhereWithoutAbsenceTypeInput | WorkCardEntryUpdateManyWithWhereWithoutAbsenceTypeInput[]
    deleteMany?: WorkCardEntryScalarWhereInput | WorkCardEntryScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutWorkCardEntriesInput = {
    create?: XOR<EmployeeCreateWithoutWorkCardEntriesInput, EmployeeUncheckedCreateWithoutWorkCardEntriesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkCardEntriesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type RodzajAbsencjiCreateNestedOneWithoutWorkCardEntriesInput = {
    create?: XOR<RodzajAbsencjiCreateWithoutWorkCardEntriesInput, RodzajAbsencjiUncheckedCreateWithoutWorkCardEntriesInput>
    connectOrCreate?: RodzajAbsencjiCreateOrConnectWithoutWorkCardEntriesInput
    connect?: RodzajAbsencjiWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutWorkCardEntriesNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkCardEntriesInput, EmployeeUncheckedCreateWithoutWorkCardEntriesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkCardEntriesInput
    upsert?: EmployeeUpsertWithoutWorkCardEntriesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkCardEntriesInput, EmployeeUpdateWithoutWorkCardEntriesInput>, EmployeeUncheckedUpdateWithoutWorkCardEntriesInput>
  }

  export type RodzajAbsencjiUpdateOneWithoutWorkCardEntriesNestedInput = {
    create?: XOR<RodzajAbsencjiCreateWithoutWorkCardEntriesInput, RodzajAbsencjiUncheckedCreateWithoutWorkCardEntriesInput>
    connectOrCreate?: RodzajAbsencjiCreateOrConnectWithoutWorkCardEntriesInput
    upsert?: RodzajAbsencjiUpsertWithoutWorkCardEntriesInput
    disconnect?: RodzajAbsencjiWhereInput | boolean
    delete?: RodzajAbsencjiWhereInput | boolean
    connect?: RodzajAbsencjiWhereUniqueInput
    update?: XOR<XOR<RodzajAbsencjiUpdateToOneWithWhereWithoutWorkCardEntriesInput, RodzajAbsencjiUpdateWithoutWorkCardEntriesInput>, RodzajAbsencjiUncheckedUpdateWithoutWorkCardEntriesInput>
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeletedDocumentsInput = {
    create?: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentAttachmentCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type DocumentAnnotationCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAnnotationCreateWithoutDocumentInput, DocumentAnnotationUncheckedCreateWithoutDocumentInput> | DocumentAnnotationCreateWithoutDocumentInput[] | DocumentAnnotationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutDocumentInput | DocumentAnnotationCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAnnotationCreateManyDocumentInputEnvelope
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
  }

  export type DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type DocumentAnnotationUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentAnnotationCreateWithoutDocumentInput, DocumentAnnotationUncheckedCreateWithoutDocumentInput> | DocumentAnnotationCreateWithoutDocumentInput[] | DocumentAnnotationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutDocumentInput | DocumentAnnotationCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentAnnotationCreateManyDocumentInputEnvelope
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateOneWithoutDeletedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedDocumentsInput
    upsert?: UserUpsertWithoutDeletedDocumentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletedDocumentsInput, UserUpdateWithoutDeletedDocumentsInput>, UserUncheckedUpdateWithoutDeletedDocumentsInput>
  }

  export type DocumentAttachmentUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput | DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type DocumentAnnotationUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAnnotationCreateWithoutDocumentInput, DocumentAnnotationUncheckedCreateWithoutDocumentInput> | DocumentAnnotationCreateWithoutDocumentInput[] | DocumentAnnotationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutDocumentInput | DocumentAnnotationCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAnnotationUpsertWithWhereUniqueWithoutDocumentInput | DocumentAnnotationUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAnnotationCreateManyDocumentInputEnvelope
    set?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    disconnect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    delete?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    update?: DocumentAnnotationUpdateWithWhereUniqueWithoutDocumentInput | DocumentAnnotationUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAnnotationUpdateManyWithWhereWithoutDocumentInput | DocumentAnnotationUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAnnotationScalarWhereInput | DocumentAnnotationScalarWhereInput[]
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput> | DocumentAttachmentCreateWithoutDocumentInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentInput | DocumentAttachmentCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAttachmentCreateManyDocumentInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput | DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput | DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type DocumentAnnotationUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentAnnotationCreateWithoutDocumentInput, DocumentAnnotationUncheckedCreateWithoutDocumentInput> | DocumentAnnotationCreateWithoutDocumentInput[] | DocumentAnnotationUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentAnnotationCreateOrConnectWithoutDocumentInput | DocumentAnnotationCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentAnnotationUpsertWithWhereUniqueWithoutDocumentInput | DocumentAnnotationUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentAnnotationCreateManyDocumentInputEnvelope
    set?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    disconnect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    delete?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    connect?: DocumentAnnotationWhereUniqueInput | DocumentAnnotationWhereUniqueInput[]
    update?: DocumentAnnotationUpdateWithWhereUniqueWithoutDocumentInput | DocumentAnnotationUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentAnnotationUpdateManyWithWhereWithoutDocumentInput | DocumentAnnotationUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentAnnotationScalarWhereInput | DocumentAnnotationScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<DocumentCreateWithoutAttachmentsInput, DocumentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAttachmentsInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedAttachmentsInput = {
    create?: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<DocumentCreateWithoutAttachmentsInput, DocumentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAttachmentsInput
    upsert?: DocumentUpsertWithoutAttachmentsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutAttachmentsInput, DocumentUpdateWithoutAttachmentsInput>, DocumentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedAttachmentsInput
    upsert?: UserUpsertWithoutUploadedAttachmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedAttachmentsInput, UserUpdateWithoutUploadedAttachmentsInput>, UserUncheckedUpdateWithoutUploadedAttachmentsInput>
  }

  export type DocumentCreateNestedOneWithoutAnnotationsInput = {
    create?: XOR<DocumentCreateWithoutAnnotationsInput, DocumentUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAnnotationsInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnotationsInput = {
    create?: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutAnnotationsNestedInput = {
    create?: XOR<DocumentCreateWithoutAnnotationsInput, DocumentUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAnnotationsInput
    upsert?: DocumentUpsertWithoutAnnotationsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutAnnotationsInput, DocumentUpdateWithoutAnnotationsInput>, DocumentUncheckedUpdateWithoutAnnotationsInput>
  }

  export type UserUpdateOneRequiredWithoutAnnotationsNestedInput = {
    create?: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnotationsInput
    upsert?: UserUpsertWithoutAnnotationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnotationsInput, UserUpdateWithoutAnnotationsInput>, UserUncheckedUpdateWithoutAnnotationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDailyAssignmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyAssignmentType | EnumDailyAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DailyAssignmentType[]
    notIn?: $Enums.DailyAssignmentType[]
    not?: NestedEnumDailyAssignmentTypeFilter<$PrismaModel> | $Enums.DailyAssignmentType
  }

  export type NestedEnumDailyAssignmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DailyAssignmentType | EnumDailyAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DailyAssignmentType[]
    notIn?: $Enums.DailyAssignmentType[]
    not?: NestedEnumDailyAssignmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DailyAssignmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDailyAssignmentTypeFilter<$PrismaModel>
    _max?: NestedEnumDailyAssignmentTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DocumentCreateWithoutUploaderInput = {
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUploaderInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedBy?: number | null
    deletedAt?: Date | string | null
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentCreateManyUploaderInputEnvelope = {
    data: DocumentCreateManyUploaderInput | DocumentCreateManyUploaderInput[]
  }

  export type DocumentCreateWithoutDeleterInput = {
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutDeleterInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutDeleterInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput>
  }

  export type DocumentCreateManyDeleterInputEnvelope = {
    data: DocumentCreateManyDeleterInput | DocumentCreateManyDeleterInput[]
  }

  export type DocumentAttachmentCreateWithoutUploaderInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isDeleted?: boolean
    document: DocumentCreateNestedOneWithoutAttachmentsInput
  }

  export type DocumentAttachmentUncheckedCreateWithoutUploaderInput = {
    id?: number
    documentId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isDeleted?: boolean
  }

  export type DocumentAttachmentCreateOrConnectWithoutUploaderInput = {
    where: DocumentAttachmentWhereUniqueInput
    create: XOR<DocumentAttachmentCreateWithoutUploaderInput, DocumentAttachmentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentAttachmentCreateManyUploaderInputEnvelope = {
    data: DocumentAttachmentCreateManyUploaderInput | DocumentAttachmentCreateManyUploaderInput[]
  }

  export type DocumentAnnotationCreateWithoutUserInput = {
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutAnnotationsInput
  }

  export type DocumentAnnotationUncheckedCreateWithoutUserInput = {
    id?: number
    documentId: number
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentAnnotationCreateOrConnectWithoutUserInput = {
    where: DocumentAnnotationWhereUniqueInput
    create: XOR<DocumentAnnotationCreateWithoutUserInput, DocumentAnnotationUncheckedCreateWithoutUserInput>
  }

  export type DocumentAnnotationCreateManyUserInputEnvelope = {
    data: DocumentAnnotationCreateManyUserInput | DocumentAnnotationCreateManyUserInput[]
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    contractNumber?: StringNullableFilter<"Document"> | string | null
    parties?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    tags?: StringNullableFilter<"Document"> | string | null
    fileName?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    fileSize?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    uploadedBy?: IntFilter<"Document"> | number
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    isDeleted?: BoolFilter<"Document"> | boolean
    deletedBy?: IntNullableFilter<"Document"> | number | null
    deletedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutDeleterInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDeleterInput, DocumentUncheckedUpdateWithoutDeleterInput>
    create: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDeleterInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDeleterInput, DocumentUncheckedUpdateWithoutDeleterInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDeleterInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDeleterInput>
  }

  export type DocumentAttachmentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentAttachmentWhereUniqueInput
    update: XOR<DocumentAttachmentUpdateWithoutUploaderInput, DocumentAttachmentUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentAttachmentCreateWithoutUploaderInput, DocumentAttachmentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentAttachmentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentAttachmentWhereUniqueInput
    data: XOR<DocumentAttachmentUpdateWithoutUploaderInput, DocumentAttachmentUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentAttachmentUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentAttachmentScalarWhereInput
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DocumentAttachmentScalarWhereInput = {
    AND?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
    OR?: DocumentAttachmentScalarWhereInput[]
    NOT?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
    id?: IntFilter<"DocumentAttachment"> | number
    documentId?: IntFilter<"DocumentAttachment"> | number
    fileName?: StringFilter<"DocumentAttachment"> | string
    filePath?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    mimeType?: StringFilter<"DocumentAttachment"> | string
    uploadedBy?: IntFilter<"DocumentAttachment"> | number
    uploadedAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    isDeleted?: BoolFilter<"DocumentAttachment"> | boolean
  }

  export type DocumentAnnotationUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentAnnotationWhereUniqueInput
    update: XOR<DocumentAnnotationUpdateWithoutUserInput, DocumentAnnotationUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentAnnotationCreateWithoutUserInput, DocumentAnnotationUncheckedCreateWithoutUserInput>
  }

  export type DocumentAnnotationUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentAnnotationWhereUniqueInput
    data: XOR<DocumentAnnotationUpdateWithoutUserInput, DocumentAnnotationUncheckedUpdateWithoutUserInput>
  }

  export type DocumentAnnotationUpdateManyWithWhereWithoutUserInput = {
    where: DocumentAnnotationScalarWhereInput
    data: XOR<DocumentAnnotationUpdateManyMutationInput, DocumentAnnotationUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentAnnotationScalarWhereInput = {
    AND?: DocumentAnnotationScalarWhereInput | DocumentAnnotationScalarWhereInput[]
    OR?: DocumentAnnotationScalarWhereInput[]
    NOT?: DocumentAnnotationScalarWhereInput | DocumentAnnotationScalarWhereInput[]
    id?: IntFilter<"DocumentAnnotation"> | number
    documentId?: IntFilter<"DocumentAnnotation"> | number
    userId?: IntFilter<"DocumentAnnotation"> | number
    type?: StringFilter<"DocumentAnnotation"> | string
    page?: IntFilter<"DocumentAnnotation"> | number
    x?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    y?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    width?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    height?: FloatNullableFilter<"DocumentAnnotation"> | number | null
    content?: StringNullableFilter<"DocumentAnnotation"> | string | null
    color?: StringNullableFilter<"DocumentAnnotation"> | string | null
    data?: JsonNullableFilter<"DocumentAnnotation">
    createdAt?: DateTimeFilter<"DocumentAnnotation"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentAnnotation"> | Date | string
  }

  export type EmployeeScheduleCreateWithoutEmployeeInput = {
    date: Date | string
    shift: string
    customHours?: string | null
    colorCode?: string | null
  }

  export type EmployeeScheduleUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    shift: string
    customHours?: string | null
    colorCode?: string | null
  }

  export type EmployeeScheduleCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeScheduleWhereUniqueInput
    create: XOR<EmployeeScheduleCreateWithoutEmployeeInput, EmployeeScheduleUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeScheduleCreateManyEmployeeInputEnvelope = {
    data: EmployeeScheduleCreateManyEmployeeInput | EmployeeScheduleCreateManyEmployeeInput[]
  }

  export type DailyAssignmentCreateWithoutDriverInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    municipality?: MunicipalityCreateNestedOneWithoutDailyAssignmentsInput
    region: RegionCreateNestedOneWithoutDailyAssignmentsInput
    vehicle: VehicleCreateNestedOneWithoutDailyAssignmentsInput
    assistants?: DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateWithoutDriverInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    assistants?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentCreateOrConnectWithoutDriverInput = {
    where: DailyAssignmentWhereUniqueInput
    create: XOR<DailyAssignmentCreateWithoutDriverInput, DailyAssignmentUncheckedCreateWithoutDriverInput>
  }

  export type DailyAssignmentCreateManyDriverInputEnvelope = {
    data: DailyAssignmentCreateManyDriverInput | DailyAssignmentCreateManyDriverInput[]
  }

  export type DailyAssignmentAssistantCreateWithoutEmployeeInput = {
    dailyAssignment: DailyAssignmentCreateNestedOneWithoutAssistantsInput
  }

  export type DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput = {
    id?: number
    dailyAssignmentId: number
  }

  export type DailyAssignmentAssistantCreateOrConnectWithoutEmployeeInput = {
    where: DailyAssignmentAssistantWhereUniqueInput
    create: XOR<DailyAssignmentAssistantCreateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput>
  }

  export type DailyAssignmentAssistantCreateManyEmployeeInputEnvelope = {
    data: DailyAssignmentAssistantCreateManyEmployeeInput | DailyAssignmentAssistantCreateManyEmployeeInput[]
  }

  export type WorkCardEntryCreateWithoutEmployeeInput = {
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    absenceType?: RodzajAbsencjiCreateNestedOneWithoutWorkCardEntriesInput
  }

  export type WorkCardEntryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    absenceTypeId?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkCardEntryCreateOrConnectWithoutEmployeeInput = {
    where: WorkCardEntryWhereUniqueInput
    create: XOR<WorkCardEntryCreateWithoutEmployeeInput, WorkCardEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkCardEntryCreateManyEmployeeInputEnvelope = {
    data: WorkCardEntryCreateManyEmployeeInput | WorkCardEntryCreateManyEmployeeInput[]
  }

  export type EmployeeScheduleUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeScheduleWhereUniqueInput
    update: XOR<EmployeeScheduleUpdateWithoutEmployeeInput, EmployeeScheduleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeScheduleCreateWithoutEmployeeInput, EmployeeScheduleUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeScheduleUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeScheduleWhereUniqueInput
    data: XOR<EmployeeScheduleUpdateWithoutEmployeeInput, EmployeeScheduleUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeScheduleUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeScheduleScalarWhereInput
    data: XOR<EmployeeScheduleUpdateManyMutationInput, EmployeeScheduleUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeScheduleScalarWhereInput = {
    AND?: EmployeeScheduleScalarWhereInput | EmployeeScheduleScalarWhereInput[]
    OR?: EmployeeScheduleScalarWhereInput[]
    NOT?: EmployeeScheduleScalarWhereInput | EmployeeScheduleScalarWhereInput[]
    id?: IntFilter<"EmployeeSchedule"> | number
    employeeId?: IntFilter<"EmployeeSchedule"> | number
    date?: DateTimeFilter<"EmployeeSchedule"> | Date | string
    shift?: StringFilter<"EmployeeSchedule"> | string
    customHours?: StringNullableFilter<"EmployeeSchedule"> | string | null
    colorCode?: StringNullableFilter<"EmployeeSchedule"> | string | null
  }

  export type DailyAssignmentUpsertWithWhereUniqueWithoutDriverInput = {
    where: DailyAssignmentWhereUniqueInput
    update: XOR<DailyAssignmentUpdateWithoutDriverInput, DailyAssignmentUncheckedUpdateWithoutDriverInput>
    create: XOR<DailyAssignmentCreateWithoutDriverInput, DailyAssignmentUncheckedCreateWithoutDriverInput>
  }

  export type DailyAssignmentUpdateWithWhereUniqueWithoutDriverInput = {
    where: DailyAssignmentWhereUniqueInput
    data: XOR<DailyAssignmentUpdateWithoutDriverInput, DailyAssignmentUncheckedUpdateWithoutDriverInput>
  }

  export type DailyAssignmentUpdateManyWithWhereWithoutDriverInput = {
    where: DailyAssignmentScalarWhereInput
    data: XOR<DailyAssignmentUpdateManyMutationInput, DailyAssignmentUncheckedUpdateManyWithoutDriverInput>
  }

  export type DailyAssignmentScalarWhereInput = {
    AND?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
    OR?: DailyAssignmentScalarWhereInput[]
    NOT?: DailyAssignmentScalarWhereInput | DailyAssignmentScalarWhereInput[]
    id?: IntFilter<"DailyAssignment"> | number
    date?: DateTimeFilter<"DailyAssignment"> | Date | string
    regionId?: IntFilter<"DailyAssignment"> | number
    vehicleId?: IntFilter<"DailyAssignment"> | number
    driverId?: IntNullableFilter<"DailyAssignment"> | number | null
    type?: EnumDailyAssignmentTypeFilter<"DailyAssignment"> | $Enums.DailyAssignmentType
    shift?: StringFilter<"DailyAssignment"> | string
    municipalityId?: IntNullableFilter<"DailyAssignment"> | number | null
    equipment?: JsonNullableFilter<"DailyAssignment">
    workType?: StringNullableFilter<"DailyAssignment"> | string | null
  }

  export type DailyAssignmentAssistantUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DailyAssignmentAssistantWhereUniqueInput
    update: XOR<DailyAssignmentAssistantUpdateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DailyAssignmentAssistantCreateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedCreateWithoutEmployeeInput>
  }

  export type DailyAssignmentAssistantUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DailyAssignmentAssistantWhereUniqueInput
    data: XOR<DailyAssignmentAssistantUpdateWithoutEmployeeInput, DailyAssignmentAssistantUncheckedUpdateWithoutEmployeeInput>
  }

  export type DailyAssignmentAssistantUpdateManyWithWhereWithoutEmployeeInput = {
    where: DailyAssignmentAssistantScalarWhereInput
    data: XOR<DailyAssignmentAssistantUpdateManyMutationInput, DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type DailyAssignmentAssistantScalarWhereInput = {
    AND?: DailyAssignmentAssistantScalarWhereInput | DailyAssignmentAssistantScalarWhereInput[]
    OR?: DailyAssignmentAssistantScalarWhereInput[]
    NOT?: DailyAssignmentAssistantScalarWhereInput | DailyAssignmentAssistantScalarWhereInput[]
    id?: IntFilter<"DailyAssignmentAssistant"> | number
    dailyAssignmentId?: IntFilter<"DailyAssignmentAssistant"> | number
    employeeId?: IntFilter<"DailyAssignmentAssistant"> | number
  }

  export type WorkCardEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: WorkCardEntryWhereUniqueInput
    update: XOR<WorkCardEntryUpdateWithoutEmployeeInput, WorkCardEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WorkCardEntryCreateWithoutEmployeeInput, WorkCardEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkCardEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: WorkCardEntryWhereUniqueInput
    data: XOR<WorkCardEntryUpdateWithoutEmployeeInput, WorkCardEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type WorkCardEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: WorkCardEntryScalarWhereInput
    data: XOR<WorkCardEntryUpdateManyMutationInput, WorkCardEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WorkCardEntryScalarWhereInput = {
    AND?: WorkCardEntryScalarWhereInput | WorkCardEntryScalarWhereInput[]
    OR?: WorkCardEntryScalarWhereInput[]
    NOT?: WorkCardEntryScalarWhereInput | WorkCardEntryScalarWhereInput[]
    id?: IntFilter<"WorkCardEntry"> | number
    employeeId?: IntFilter<"WorkCardEntry"> | number
    date?: DateTimeFilter<"WorkCardEntry"> | Date | string
    actualFrom?: StringNullableFilter<"WorkCardEntry"> | string | null
    actualTo?: StringNullableFilter<"WorkCardEntry"> | string | null
    actualTotal?: FloatNullableFilter<"WorkCardEntry"> | number | null
    absenceTypeId?: IntNullableFilter<"WorkCardEntry"> | number | null
    onCall?: BoolFilter<"WorkCardEntry"> | boolean
    createdAt?: DateTimeFilter<"WorkCardEntry"> | Date | string
    updatedAt?: DateTimeFilter<"WorkCardEntry"> | Date | string
  }

  export type DailyAssignmentCreateWithoutVehicleInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    municipality?: MunicipalityCreateNestedOneWithoutDailyAssignmentsInput
    region: RegionCreateNestedOneWithoutDailyAssignmentsInput
    driver?: EmployeeCreateNestedOneWithoutDrivenAssignmentsInput
    assistants?: DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateWithoutVehicleInput = {
    id?: number
    date: Date | string
    regionId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    assistants?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentCreateOrConnectWithoutVehicleInput = {
    where: DailyAssignmentWhereUniqueInput
    create: XOR<DailyAssignmentCreateWithoutVehicleInput, DailyAssignmentUncheckedCreateWithoutVehicleInput>
  }

  export type DailyAssignmentCreateManyVehicleInputEnvelope = {
    data: DailyAssignmentCreateManyVehicleInput | DailyAssignmentCreateManyVehicleInput[]
  }

  export type VehicleFaultReportCreateWithoutVehicleInput = {
    reportedBy: string
    description?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    isResolved?: boolean
  }

  export type VehicleFaultReportUncheckedCreateWithoutVehicleInput = {
    id?: number
    reportedBy: string
    description?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    isResolved?: boolean
  }

  export type VehicleFaultReportCreateOrConnectWithoutVehicleInput = {
    where: VehicleFaultReportWhereUniqueInput
    create: XOR<VehicleFaultReportCreateWithoutVehicleInput, VehicleFaultReportUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleFaultReportCreateManyVehicleInputEnvelope = {
    data: VehicleFaultReportCreateManyVehicleInput | VehicleFaultReportCreateManyVehicleInput[]
  }

  export type DailyAssignmentUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DailyAssignmentWhereUniqueInput
    update: XOR<DailyAssignmentUpdateWithoutVehicleInput, DailyAssignmentUncheckedUpdateWithoutVehicleInput>
    create: XOR<DailyAssignmentCreateWithoutVehicleInput, DailyAssignmentUncheckedCreateWithoutVehicleInput>
  }

  export type DailyAssignmentUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DailyAssignmentWhereUniqueInput
    data: XOR<DailyAssignmentUpdateWithoutVehicleInput, DailyAssignmentUncheckedUpdateWithoutVehicleInput>
  }

  export type DailyAssignmentUpdateManyWithWhereWithoutVehicleInput = {
    where: DailyAssignmentScalarWhereInput
    data: XOR<DailyAssignmentUpdateManyMutationInput, DailyAssignmentUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleFaultReportUpsertWithWhereUniqueWithoutVehicleInput = {
    where: VehicleFaultReportWhereUniqueInput
    update: XOR<VehicleFaultReportUpdateWithoutVehicleInput, VehicleFaultReportUncheckedUpdateWithoutVehicleInput>
    create: XOR<VehicleFaultReportCreateWithoutVehicleInput, VehicleFaultReportUncheckedCreateWithoutVehicleInput>
  }

  export type VehicleFaultReportUpdateWithWhereUniqueWithoutVehicleInput = {
    where: VehicleFaultReportWhereUniqueInput
    data: XOR<VehicleFaultReportUpdateWithoutVehicleInput, VehicleFaultReportUncheckedUpdateWithoutVehicleInput>
  }

  export type VehicleFaultReportUpdateManyWithWhereWithoutVehicleInput = {
    where: VehicleFaultReportScalarWhereInput
    data: XOR<VehicleFaultReportUpdateManyMutationInput, VehicleFaultReportUncheckedUpdateManyWithoutVehicleInput>
  }

  export type VehicleFaultReportScalarWhereInput = {
    AND?: VehicleFaultReportScalarWhereInput | VehicleFaultReportScalarWhereInput[]
    OR?: VehicleFaultReportScalarWhereInput[]
    NOT?: VehicleFaultReportScalarWhereInput | VehicleFaultReportScalarWhereInput[]
    id?: IntFilter<"VehicleFaultReport"> | number
    vehicleId?: IntFilter<"VehicleFaultReport"> | number
    reportedBy?: StringFilter<"VehicleFaultReport"> | string
    description?: StringNullableFilter<"VehicleFaultReport"> | string | null
    reportedAt?: DateTimeFilter<"VehicleFaultReport"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"VehicleFaultReport"> | Date | string | null
    isResolved?: BoolFilter<"VehicleFaultReport"> | boolean
  }

  export type PointCreateWithoutRegionInput = {
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    pointFractions?: PointFractionCreateNestedManyWithoutPointInput
  }

  export type PointUncheckedCreateWithoutRegionInput = {
    id?: number
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    pointFractions?: PointFractionUncheckedCreateNestedManyWithoutPointInput
  }

  export type PointCreateOrConnectWithoutRegionInput = {
    where: PointWhereUniqueInput
    create: XOR<PointCreateWithoutRegionInput, PointUncheckedCreateWithoutRegionInput>
  }

  export type PointCreateManyRegionInputEnvelope = {
    data: PointCreateManyRegionInput | PointCreateManyRegionInput[]
  }

  export type RegionFractionCreateWithoutRegionInput = {
    fraction: FractionCreateNestedOneWithoutRegionFractionsInput
  }

  export type RegionFractionUncheckedCreateWithoutRegionInput = {
    id?: number
    fractionId: number
  }

  export type RegionFractionCreateOrConnectWithoutRegionInput = {
    where: RegionFractionWhereUniqueInput
    create: XOR<RegionFractionCreateWithoutRegionInput, RegionFractionUncheckedCreateWithoutRegionInput>
  }

  export type RegionFractionCreateManyRegionInputEnvelope = {
    data: RegionFractionCreateManyRegionInput | RegionFractionCreateManyRegionInput[]
  }

  export type CalendarEntryCreateWithoutRegionInput = {
    date: Date | string
    fraction: FractionCreateNestedOneWithoutCalendarEntriesInput
  }

  export type CalendarEntryUncheckedCreateWithoutRegionInput = {
    id?: number
    fractionId: number
    date: Date | string
  }

  export type CalendarEntryCreateOrConnectWithoutRegionInput = {
    where: CalendarEntryWhereUniqueInput
    create: XOR<CalendarEntryCreateWithoutRegionInput, CalendarEntryUncheckedCreateWithoutRegionInput>
  }

  export type CalendarEntryCreateManyRegionInputEnvelope = {
    data: CalendarEntryCreateManyRegionInput | CalendarEntryCreateManyRegionInput[]
  }

  export type DailyAssignmentCreateWithoutRegionInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    municipality?: MunicipalityCreateNestedOneWithoutDailyAssignmentsInput
    vehicle: VehicleCreateNestedOneWithoutDailyAssignmentsInput
    driver?: EmployeeCreateNestedOneWithoutDrivenAssignmentsInput
    assistants?: DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateWithoutRegionInput = {
    id?: number
    date: Date | string
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    assistants?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentCreateOrConnectWithoutRegionInput = {
    where: DailyAssignmentWhereUniqueInput
    create: XOR<DailyAssignmentCreateWithoutRegionInput, DailyAssignmentUncheckedCreateWithoutRegionInput>
  }

  export type DailyAssignmentCreateManyRegionInputEnvelope = {
    data: DailyAssignmentCreateManyRegionInput | DailyAssignmentCreateManyRegionInput[]
  }

  export type PointUpsertWithWhereUniqueWithoutRegionInput = {
    where: PointWhereUniqueInput
    update: XOR<PointUpdateWithoutRegionInput, PointUncheckedUpdateWithoutRegionInput>
    create: XOR<PointCreateWithoutRegionInput, PointUncheckedCreateWithoutRegionInput>
  }

  export type PointUpdateWithWhereUniqueWithoutRegionInput = {
    where: PointWhereUniqueInput
    data: XOR<PointUpdateWithoutRegionInput, PointUncheckedUpdateWithoutRegionInput>
  }

  export type PointUpdateManyWithWhereWithoutRegionInput = {
    where: PointScalarWhereInput
    data: XOR<PointUpdateManyMutationInput, PointUncheckedUpdateManyWithoutRegionInput>
  }

  export type PointScalarWhereInput = {
    AND?: PointScalarWhereInput | PointScalarWhereInput[]
    OR?: PointScalarWhereInput[]
    NOT?: PointScalarWhereInput | PointScalarWhereInput[]
    id?: IntFilter<"Point"> | number
    type?: StringFilter<"Point"> | string
    town?: StringFilter<"Point"> | string
    street?: StringFilter<"Point"> | string
    number?: StringFilter<"Point"> | string
    notes?: StringNullableFilter<"Point"> | string | null
    companyName?: StringNullableFilter<"Point"> | string | null
    activityNotes?: StringNullableFilter<"Point"> | string | null
    startDate?: DateTimeNullableFilter<"Point"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Point"> | Date | string | null
    isIndefinite?: BoolFilter<"Point"> | boolean
    kompostownik?: BoolFilter<"Point"> | boolean
    regionId?: IntNullableFilter<"Point"> | number | null
  }

  export type RegionFractionUpsertWithWhereUniqueWithoutRegionInput = {
    where: RegionFractionWhereUniqueInput
    update: XOR<RegionFractionUpdateWithoutRegionInput, RegionFractionUncheckedUpdateWithoutRegionInput>
    create: XOR<RegionFractionCreateWithoutRegionInput, RegionFractionUncheckedCreateWithoutRegionInput>
  }

  export type RegionFractionUpdateWithWhereUniqueWithoutRegionInput = {
    where: RegionFractionWhereUniqueInput
    data: XOR<RegionFractionUpdateWithoutRegionInput, RegionFractionUncheckedUpdateWithoutRegionInput>
  }

  export type RegionFractionUpdateManyWithWhereWithoutRegionInput = {
    where: RegionFractionScalarWhereInput
    data: XOR<RegionFractionUpdateManyMutationInput, RegionFractionUncheckedUpdateManyWithoutRegionInput>
  }

  export type RegionFractionScalarWhereInput = {
    AND?: RegionFractionScalarWhereInput | RegionFractionScalarWhereInput[]
    OR?: RegionFractionScalarWhereInput[]
    NOT?: RegionFractionScalarWhereInput | RegionFractionScalarWhereInput[]
    id?: IntFilter<"RegionFraction"> | number
    regionId?: IntFilter<"RegionFraction"> | number
    fractionId?: IntFilter<"RegionFraction"> | number
  }

  export type CalendarEntryUpsertWithWhereUniqueWithoutRegionInput = {
    where: CalendarEntryWhereUniqueInput
    update: XOR<CalendarEntryUpdateWithoutRegionInput, CalendarEntryUncheckedUpdateWithoutRegionInput>
    create: XOR<CalendarEntryCreateWithoutRegionInput, CalendarEntryUncheckedCreateWithoutRegionInput>
  }

  export type CalendarEntryUpdateWithWhereUniqueWithoutRegionInput = {
    where: CalendarEntryWhereUniqueInput
    data: XOR<CalendarEntryUpdateWithoutRegionInput, CalendarEntryUncheckedUpdateWithoutRegionInput>
  }

  export type CalendarEntryUpdateManyWithWhereWithoutRegionInput = {
    where: CalendarEntryScalarWhereInput
    data: XOR<CalendarEntryUpdateManyMutationInput, CalendarEntryUncheckedUpdateManyWithoutRegionInput>
  }

  export type CalendarEntryScalarWhereInput = {
    AND?: CalendarEntryScalarWhereInput | CalendarEntryScalarWhereInput[]
    OR?: CalendarEntryScalarWhereInput[]
    NOT?: CalendarEntryScalarWhereInput | CalendarEntryScalarWhereInput[]
    id?: IntFilter<"CalendarEntry"> | number
    regionId?: IntFilter<"CalendarEntry"> | number
    fractionId?: IntFilter<"CalendarEntry"> | number
    date?: DateTimeFilter<"CalendarEntry"> | Date | string
  }

  export type DailyAssignmentUpsertWithWhereUniqueWithoutRegionInput = {
    where: DailyAssignmentWhereUniqueInput
    update: XOR<DailyAssignmentUpdateWithoutRegionInput, DailyAssignmentUncheckedUpdateWithoutRegionInput>
    create: XOR<DailyAssignmentCreateWithoutRegionInput, DailyAssignmentUncheckedCreateWithoutRegionInput>
  }

  export type DailyAssignmentUpdateWithWhereUniqueWithoutRegionInput = {
    where: DailyAssignmentWhereUniqueInput
    data: XOR<DailyAssignmentUpdateWithoutRegionInput, DailyAssignmentUncheckedUpdateWithoutRegionInput>
  }

  export type DailyAssignmentUpdateManyWithWhereWithoutRegionInput = {
    where: DailyAssignmentScalarWhereInput
    data: XOR<DailyAssignmentUpdateManyMutationInput, DailyAssignmentUncheckedUpdateManyWithoutRegionInput>
  }

  export type PointFractionCreateWithoutFractionInput = {
    containerSize: string
    pickupFrequency: string
    point: PointCreateNestedOneWithoutPointFractionsInput
  }

  export type PointFractionUncheckedCreateWithoutFractionInput = {
    id?: number
    pointId: number
    containerSize: string
    pickupFrequency: string
  }

  export type PointFractionCreateOrConnectWithoutFractionInput = {
    where: PointFractionWhereUniqueInput
    create: XOR<PointFractionCreateWithoutFractionInput, PointFractionUncheckedCreateWithoutFractionInput>
  }

  export type PointFractionCreateManyFractionInputEnvelope = {
    data: PointFractionCreateManyFractionInput | PointFractionCreateManyFractionInput[]
  }

  export type RegionFractionCreateWithoutFractionInput = {
    region: RegionCreateNestedOneWithoutRegionFractionsInput
  }

  export type RegionFractionUncheckedCreateWithoutFractionInput = {
    id?: number
    regionId: number
  }

  export type RegionFractionCreateOrConnectWithoutFractionInput = {
    where: RegionFractionWhereUniqueInput
    create: XOR<RegionFractionCreateWithoutFractionInput, RegionFractionUncheckedCreateWithoutFractionInput>
  }

  export type RegionFractionCreateManyFractionInputEnvelope = {
    data: RegionFractionCreateManyFractionInput | RegionFractionCreateManyFractionInput[]
  }

  export type CalendarEntryCreateWithoutFractionInput = {
    date: Date | string
    region: RegionCreateNestedOneWithoutCalendarEntriesInput
  }

  export type CalendarEntryUncheckedCreateWithoutFractionInput = {
    id?: number
    regionId: number
    date: Date | string
  }

  export type CalendarEntryCreateOrConnectWithoutFractionInput = {
    where: CalendarEntryWhereUniqueInput
    create: XOR<CalendarEntryCreateWithoutFractionInput, CalendarEntryUncheckedCreateWithoutFractionInput>
  }

  export type CalendarEntryCreateManyFractionInputEnvelope = {
    data: CalendarEntryCreateManyFractionInput | CalendarEntryCreateManyFractionInput[]
  }

  export type DailyAssignmentFractionCreateWithoutFractionInput = {
    dailyAssignment: DailyAssignmentCreateNestedOneWithoutFractionsInput
  }

  export type DailyAssignmentFractionUncheckedCreateWithoutFractionInput = {
    id?: number
    dailyAssignmentId: number
  }

  export type DailyAssignmentFractionCreateOrConnectWithoutFractionInput = {
    where: DailyAssignmentFractionWhereUniqueInput
    create: XOR<DailyAssignmentFractionCreateWithoutFractionInput, DailyAssignmentFractionUncheckedCreateWithoutFractionInput>
  }

  export type DailyAssignmentFractionCreateManyFractionInputEnvelope = {
    data: DailyAssignmentFractionCreateManyFractionInput | DailyAssignmentFractionCreateManyFractionInput[]
  }

  export type PointFractionUpsertWithWhereUniqueWithoutFractionInput = {
    where: PointFractionWhereUniqueInput
    update: XOR<PointFractionUpdateWithoutFractionInput, PointFractionUncheckedUpdateWithoutFractionInput>
    create: XOR<PointFractionCreateWithoutFractionInput, PointFractionUncheckedCreateWithoutFractionInput>
  }

  export type PointFractionUpdateWithWhereUniqueWithoutFractionInput = {
    where: PointFractionWhereUniqueInput
    data: XOR<PointFractionUpdateWithoutFractionInput, PointFractionUncheckedUpdateWithoutFractionInput>
  }

  export type PointFractionUpdateManyWithWhereWithoutFractionInput = {
    where: PointFractionScalarWhereInput
    data: XOR<PointFractionUpdateManyMutationInput, PointFractionUncheckedUpdateManyWithoutFractionInput>
  }

  export type PointFractionScalarWhereInput = {
    AND?: PointFractionScalarWhereInput | PointFractionScalarWhereInput[]
    OR?: PointFractionScalarWhereInput[]
    NOT?: PointFractionScalarWhereInput | PointFractionScalarWhereInput[]
    id?: IntFilter<"PointFraction"> | number
    pointId?: IntFilter<"PointFraction"> | number
    fractionId?: IntFilter<"PointFraction"> | number
    containerSize?: StringFilter<"PointFraction"> | string
    pickupFrequency?: StringFilter<"PointFraction"> | string
  }

  export type RegionFractionUpsertWithWhereUniqueWithoutFractionInput = {
    where: RegionFractionWhereUniqueInput
    update: XOR<RegionFractionUpdateWithoutFractionInput, RegionFractionUncheckedUpdateWithoutFractionInput>
    create: XOR<RegionFractionCreateWithoutFractionInput, RegionFractionUncheckedCreateWithoutFractionInput>
  }

  export type RegionFractionUpdateWithWhereUniqueWithoutFractionInput = {
    where: RegionFractionWhereUniqueInput
    data: XOR<RegionFractionUpdateWithoutFractionInput, RegionFractionUncheckedUpdateWithoutFractionInput>
  }

  export type RegionFractionUpdateManyWithWhereWithoutFractionInput = {
    where: RegionFractionScalarWhereInput
    data: XOR<RegionFractionUpdateManyMutationInput, RegionFractionUncheckedUpdateManyWithoutFractionInput>
  }

  export type CalendarEntryUpsertWithWhereUniqueWithoutFractionInput = {
    where: CalendarEntryWhereUniqueInput
    update: XOR<CalendarEntryUpdateWithoutFractionInput, CalendarEntryUncheckedUpdateWithoutFractionInput>
    create: XOR<CalendarEntryCreateWithoutFractionInput, CalendarEntryUncheckedCreateWithoutFractionInput>
  }

  export type CalendarEntryUpdateWithWhereUniqueWithoutFractionInput = {
    where: CalendarEntryWhereUniqueInput
    data: XOR<CalendarEntryUpdateWithoutFractionInput, CalendarEntryUncheckedUpdateWithoutFractionInput>
  }

  export type CalendarEntryUpdateManyWithWhereWithoutFractionInput = {
    where: CalendarEntryScalarWhereInput
    data: XOR<CalendarEntryUpdateManyMutationInput, CalendarEntryUncheckedUpdateManyWithoutFractionInput>
  }

  export type DailyAssignmentFractionUpsertWithWhereUniqueWithoutFractionInput = {
    where: DailyAssignmentFractionWhereUniqueInput
    update: XOR<DailyAssignmentFractionUpdateWithoutFractionInput, DailyAssignmentFractionUncheckedUpdateWithoutFractionInput>
    create: XOR<DailyAssignmentFractionCreateWithoutFractionInput, DailyAssignmentFractionUncheckedCreateWithoutFractionInput>
  }

  export type DailyAssignmentFractionUpdateWithWhereUniqueWithoutFractionInput = {
    where: DailyAssignmentFractionWhereUniqueInput
    data: XOR<DailyAssignmentFractionUpdateWithoutFractionInput, DailyAssignmentFractionUncheckedUpdateWithoutFractionInput>
  }

  export type DailyAssignmentFractionUpdateManyWithWhereWithoutFractionInput = {
    where: DailyAssignmentFractionScalarWhereInput
    data: XOR<DailyAssignmentFractionUpdateManyMutationInput, DailyAssignmentFractionUncheckedUpdateManyWithoutFractionInput>
  }

  export type DailyAssignmentFractionScalarWhereInput = {
    AND?: DailyAssignmentFractionScalarWhereInput | DailyAssignmentFractionScalarWhereInput[]
    OR?: DailyAssignmentFractionScalarWhereInput[]
    NOT?: DailyAssignmentFractionScalarWhereInput | DailyAssignmentFractionScalarWhereInput[]
    id?: IntFilter<"DailyAssignmentFraction"> | number
    dailyAssignmentId?: IntFilter<"DailyAssignmentFraction"> | number
    fractionId?: IntFilter<"DailyAssignmentFraction"> | number
  }

  export type RegionCreateWithoutPointsInput = {
    name: string
    unitName: string
    notes?: string | null
    regionFractions?: RegionFractionCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutPointsInput = {
    id?: number
    name: string
    unitName: string
    notes?: string | null
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutPointsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutPointsInput, RegionUncheckedCreateWithoutPointsInput>
  }

  export type PointFractionCreateWithoutPointInput = {
    containerSize: string
    pickupFrequency: string
    fraction: FractionCreateNestedOneWithoutPointFractionsInput
  }

  export type PointFractionUncheckedCreateWithoutPointInput = {
    id?: number
    fractionId: number
    containerSize: string
    pickupFrequency: string
  }

  export type PointFractionCreateOrConnectWithoutPointInput = {
    where: PointFractionWhereUniqueInput
    create: XOR<PointFractionCreateWithoutPointInput, PointFractionUncheckedCreateWithoutPointInput>
  }

  export type PointFractionCreateManyPointInputEnvelope = {
    data: PointFractionCreateManyPointInput | PointFractionCreateManyPointInput[]
  }

  export type RegionUpsertWithoutPointsInput = {
    update: XOR<RegionUpdateWithoutPointsInput, RegionUncheckedUpdateWithoutPointsInput>
    create: XOR<RegionCreateWithoutPointsInput, RegionUncheckedCreateWithoutPointsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutPointsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutPointsInput, RegionUncheckedUpdateWithoutPointsInput>
  }

  export type RegionUpdateWithoutPointsInput = {
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    regionFractions?: RegionFractionUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutPointsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type PointFractionUpsertWithWhereUniqueWithoutPointInput = {
    where: PointFractionWhereUniqueInput
    update: XOR<PointFractionUpdateWithoutPointInput, PointFractionUncheckedUpdateWithoutPointInput>
    create: XOR<PointFractionCreateWithoutPointInput, PointFractionUncheckedCreateWithoutPointInput>
  }

  export type PointFractionUpdateWithWhereUniqueWithoutPointInput = {
    where: PointFractionWhereUniqueInput
    data: XOR<PointFractionUpdateWithoutPointInput, PointFractionUncheckedUpdateWithoutPointInput>
  }

  export type PointFractionUpdateManyWithWhereWithoutPointInput = {
    where: PointFractionScalarWhereInput
    data: XOR<PointFractionUpdateManyMutationInput, PointFractionUncheckedUpdateManyWithoutPointInput>
  }

  export type PointCreateWithoutPointFractionsInput = {
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    region?: RegionCreateNestedOneWithoutPointsInput
  }

  export type PointUncheckedCreateWithoutPointFractionsInput = {
    id?: number
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
    regionId?: number | null
  }

  export type PointCreateOrConnectWithoutPointFractionsInput = {
    where: PointWhereUniqueInput
    create: XOR<PointCreateWithoutPointFractionsInput, PointUncheckedCreateWithoutPointFractionsInput>
  }

  export type FractionCreateWithoutPointFractionsInput = {
    name: string
    code: string
    color: string
    regionFractions?: RegionFractionCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionCreateNestedManyWithoutFractionInput
  }

  export type FractionUncheckedCreateWithoutPointFractionsInput = {
    id?: number
    name: string
    code: string
    color: string
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutFractionInput
  }

  export type FractionCreateOrConnectWithoutPointFractionsInput = {
    where: FractionWhereUniqueInput
    create: XOR<FractionCreateWithoutPointFractionsInput, FractionUncheckedCreateWithoutPointFractionsInput>
  }

  export type PointUpsertWithoutPointFractionsInput = {
    update: XOR<PointUpdateWithoutPointFractionsInput, PointUncheckedUpdateWithoutPointFractionsInput>
    create: XOR<PointCreateWithoutPointFractionsInput, PointUncheckedCreateWithoutPointFractionsInput>
    where?: PointWhereInput
  }

  export type PointUpdateToOneWithWhereWithoutPointFractionsInput = {
    where?: PointWhereInput
    data: XOR<PointUpdateWithoutPointFractionsInput, PointUncheckedUpdateWithoutPointFractionsInput>
  }

  export type PointUpdateWithoutPointFractionsInput = {
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    region?: RegionUpdateOneWithoutPointsNestedInput
  }

  export type PointUncheckedUpdateWithoutPointFractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    regionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FractionUpsertWithoutPointFractionsInput = {
    update: XOR<FractionUpdateWithoutPointFractionsInput, FractionUncheckedUpdateWithoutPointFractionsInput>
    create: XOR<FractionCreateWithoutPointFractionsInput, FractionUncheckedCreateWithoutPointFractionsInput>
    where?: FractionWhereInput
  }

  export type FractionUpdateToOneWithWhereWithoutPointFractionsInput = {
    where?: FractionWhereInput
    data: XOR<FractionUpdateWithoutPointFractionsInput, FractionUncheckedUpdateWithoutPointFractionsInput>
  }

  export type FractionUpdateWithoutPointFractionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    regionFractions?: RegionFractionUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUpdateManyWithoutFractionNestedInput
  }

  export type FractionUncheckedUpdateWithoutPointFractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedUpdateManyWithoutFractionNestedInput
  }

  export type EmployeeCreateWithoutEmployeeSchedulesInput = {
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    drivenAssignments?: DailyAssignmentCreateNestedManyWithoutDriverInput
    assistantAssignments?: DailyAssignmentAssistantCreateNestedManyWithoutEmployeeInput
    workCardEntries?: WorkCardEntryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeSchedulesInput = {
    id?: number
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    drivenAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutDriverInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutEmployeeInput
    workCardEntries?: WorkCardEntryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeSchedulesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeSchedulesInput, EmployeeUncheckedCreateWithoutEmployeeSchedulesInput>
  }

  export type EmployeeUpsertWithoutEmployeeSchedulesInput = {
    update: XOR<EmployeeUpdateWithoutEmployeeSchedulesInput, EmployeeUncheckedUpdateWithoutEmployeeSchedulesInput>
    create: XOR<EmployeeCreateWithoutEmployeeSchedulesInput, EmployeeUncheckedCreateWithoutEmployeeSchedulesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeeSchedulesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeeSchedulesInput, EmployeeUncheckedUpdateWithoutEmployeeSchedulesInput>
  }

  export type EmployeeUpdateWithoutEmployeeSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    drivenAssignments?: DailyAssignmentUpdateManyWithoutDriverNestedInput
    assistantAssignments?: DailyAssignmentAssistantUpdateManyWithoutEmployeeNestedInput
    workCardEntries?: WorkCardEntryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    drivenAssignments?: DailyAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeNestedInput
    workCardEntries?: WorkCardEntryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type RegionCreateWithoutRegionFractionsInput = {
    name: string
    unitName: string
    notes?: string | null
    points?: PointCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutRegionFractionsInput = {
    id?: number
    name: string
    unitName: string
    notes?: string | null
    points?: PointUncheckedCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutRegionFractionsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutRegionFractionsInput, RegionUncheckedCreateWithoutRegionFractionsInput>
  }

  export type FractionCreateWithoutRegionFractionsInput = {
    name: string
    code: string
    color: string
    pointFractions?: PointFractionCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionCreateNestedManyWithoutFractionInput
  }

  export type FractionUncheckedCreateWithoutRegionFractionsInput = {
    id?: number
    name: string
    code: string
    color: string
    pointFractions?: PointFractionUncheckedCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutFractionInput
  }

  export type FractionCreateOrConnectWithoutRegionFractionsInput = {
    where: FractionWhereUniqueInput
    create: XOR<FractionCreateWithoutRegionFractionsInput, FractionUncheckedCreateWithoutRegionFractionsInput>
  }

  export type RegionUpsertWithoutRegionFractionsInput = {
    update: XOR<RegionUpdateWithoutRegionFractionsInput, RegionUncheckedUpdateWithoutRegionFractionsInput>
    create: XOR<RegionCreateWithoutRegionFractionsInput, RegionUncheckedCreateWithoutRegionFractionsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutRegionFractionsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutRegionFractionsInput, RegionUncheckedUpdateWithoutRegionFractionsInput>
  }

  export type RegionUpdateWithoutRegionFractionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutRegionFractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUncheckedUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type FractionUpsertWithoutRegionFractionsInput = {
    update: XOR<FractionUpdateWithoutRegionFractionsInput, FractionUncheckedUpdateWithoutRegionFractionsInput>
    create: XOR<FractionCreateWithoutRegionFractionsInput, FractionUncheckedCreateWithoutRegionFractionsInput>
    where?: FractionWhereInput
  }

  export type FractionUpdateToOneWithWhereWithoutRegionFractionsInput = {
    where?: FractionWhereInput
    data: XOR<FractionUpdateWithoutRegionFractionsInput, FractionUncheckedUpdateWithoutRegionFractionsInput>
  }

  export type FractionUpdateWithoutRegionFractionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUpdateManyWithoutFractionNestedInput
  }

  export type FractionUncheckedUpdateWithoutRegionFractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUncheckedUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedUpdateManyWithoutFractionNestedInput
  }

  export type RegionCreateWithoutCalendarEntriesInput = {
    name: string
    unitName: string
    notes?: string | null
    points?: PointCreateNestedManyWithoutRegionInput
    regionFractions?: RegionFractionCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutCalendarEntriesInput = {
    id?: number
    name: string
    unitName: string
    notes?: string | null
    points?: PointUncheckedCreateNestedManyWithoutRegionInput
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutRegionInput
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutCalendarEntriesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutCalendarEntriesInput, RegionUncheckedCreateWithoutCalendarEntriesInput>
  }

  export type FractionCreateWithoutCalendarEntriesInput = {
    name: string
    code: string
    color: string
    pointFractions?: PointFractionCreateNestedManyWithoutFractionInput
    regionFractions?: RegionFractionCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionCreateNestedManyWithoutFractionInput
  }

  export type FractionUncheckedCreateWithoutCalendarEntriesInput = {
    id?: number
    name: string
    code: string
    color: string
    pointFractions?: PointFractionUncheckedCreateNestedManyWithoutFractionInput
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutFractionInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutFractionInput
  }

  export type FractionCreateOrConnectWithoutCalendarEntriesInput = {
    where: FractionWhereUniqueInput
    create: XOR<FractionCreateWithoutCalendarEntriesInput, FractionUncheckedCreateWithoutCalendarEntriesInput>
  }

  export type RegionUpsertWithoutCalendarEntriesInput = {
    update: XOR<RegionUpdateWithoutCalendarEntriesInput, RegionUncheckedUpdateWithoutCalendarEntriesInput>
    create: XOR<RegionCreateWithoutCalendarEntriesInput, RegionUncheckedCreateWithoutCalendarEntriesInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutCalendarEntriesInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutCalendarEntriesInput, RegionUncheckedUpdateWithoutCalendarEntriesInput>
  }

  export type RegionUpdateWithoutCalendarEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUpdateManyWithoutRegionNestedInput
    regionFractions?: RegionFractionUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutCalendarEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUncheckedUpdateManyWithoutRegionNestedInput
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutRegionNestedInput
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type FractionUpsertWithoutCalendarEntriesInput = {
    update: XOR<FractionUpdateWithoutCalendarEntriesInput, FractionUncheckedUpdateWithoutCalendarEntriesInput>
    create: XOR<FractionCreateWithoutCalendarEntriesInput, FractionUncheckedCreateWithoutCalendarEntriesInput>
    where?: FractionWhereInput
  }

  export type FractionUpdateToOneWithWhereWithoutCalendarEntriesInput = {
    where?: FractionWhereInput
    data: XOR<FractionUpdateWithoutCalendarEntriesInput, FractionUncheckedUpdateWithoutCalendarEntriesInput>
  }

  export type FractionUpdateWithoutCalendarEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUpdateManyWithoutFractionNestedInput
    regionFractions?: RegionFractionUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUpdateManyWithoutFractionNestedInput
  }

  export type FractionUncheckedUpdateWithoutCalendarEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUncheckedUpdateManyWithoutFractionNestedInput
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutFractionNestedInput
    fractionsInAssignments?: DailyAssignmentFractionUncheckedUpdateManyWithoutFractionNestedInput
  }

  export type MunicipalityCreateWithoutDailyAssignmentsInput = {
    name: string
  }

  export type MunicipalityUncheckedCreateWithoutDailyAssignmentsInput = {
    id?: number
    name: string
  }

  export type MunicipalityCreateOrConnectWithoutDailyAssignmentsInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutDailyAssignmentsInput, MunicipalityUncheckedCreateWithoutDailyAssignmentsInput>
  }

  export type RegionCreateWithoutDailyAssignmentsInput = {
    name: string
    unitName: string
    notes?: string | null
    points?: PointCreateNestedManyWithoutRegionInput
    regionFractions?: RegionFractionCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutDailyAssignmentsInput = {
    id?: number
    name: string
    unitName: string
    notes?: string | null
    points?: PointUncheckedCreateNestedManyWithoutRegionInput
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutRegionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutDailyAssignmentsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutDailyAssignmentsInput, RegionUncheckedCreateWithoutDailyAssignmentsInput>
  }

  export type VehicleCreateWithoutDailyAssignmentsInput = {
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
    faultReports?: VehicleFaultReportCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutDailyAssignmentsInput = {
    id?: number
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
    faultReports?: VehicleFaultReportUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutDailyAssignmentsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDailyAssignmentsInput, VehicleUncheckedCreateWithoutDailyAssignmentsInput>
  }

  export type EmployeeCreateWithoutDrivenAssignmentsInput = {
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleCreateNestedManyWithoutEmployeeInput
    assistantAssignments?: DailyAssignmentAssistantCreateNestedManyWithoutEmployeeInput
    workCardEntries?: WorkCardEntryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDrivenAssignmentsInput = {
    id?: number
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleUncheckedCreateNestedManyWithoutEmployeeInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutEmployeeInput
    workCardEntries?: WorkCardEntryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDrivenAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDrivenAssignmentsInput, EmployeeUncheckedCreateWithoutDrivenAssignmentsInput>
  }

  export type DailyAssignmentAssistantCreateWithoutDailyAssignmentInput = {
    employee: EmployeeCreateNestedOneWithoutAssistantAssignmentsInput
  }

  export type DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput = {
    id?: number
    employeeId: number
  }

  export type DailyAssignmentAssistantCreateOrConnectWithoutDailyAssignmentInput = {
    where: DailyAssignmentAssistantWhereUniqueInput
    create: XOR<DailyAssignmentAssistantCreateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentAssistantCreateManyDailyAssignmentInputEnvelope = {
    data: DailyAssignmentAssistantCreateManyDailyAssignmentInput | DailyAssignmentAssistantCreateManyDailyAssignmentInput[]
  }

  export type DailyAssignmentFractionCreateWithoutDailyAssignmentInput = {
    fraction: FractionCreateNestedOneWithoutFractionsInAssignmentsInput
  }

  export type DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput = {
    id?: number
    fractionId: number
  }

  export type DailyAssignmentFractionCreateOrConnectWithoutDailyAssignmentInput = {
    where: DailyAssignmentFractionWhereUniqueInput
    create: XOR<DailyAssignmentFractionCreateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentFractionCreateManyDailyAssignmentInputEnvelope = {
    data: DailyAssignmentFractionCreateManyDailyAssignmentInput | DailyAssignmentFractionCreateManyDailyAssignmentInput[]
  }

  export type MunicipalityUpsertWithoutDailyAssignmentsInput = {
    update: XOR<MunicipalityUpdateWithoutDailyAssignmentsInput, MunicipalityUncheckedUpdateWithoutDailyAssignmentsInput>
    create: XOR<MunicipalityCreateWithoutDailyAssignmentsInput, MunicipalityUncheckedCreateWithoutDailyAssignmentsInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutDailyAssignmentsInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutDailyAssignmentsInput, MunicipalityUncheckedUpdateWithoutDailyAssignmentsInput>
  }

  export type MunicipalityUpdateWithoutDailyAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MunicipalityUncheckedUpdateWithoutDailyAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUpsertWithoutDailyAssignmentsInput = {
    update: XOR<RegionUpdateWithoutDailyAssignmentsInput, RegionUncheckedUpdateWithoutDailyAssignmentsInput>
    create: XOR<RegionCreateWithoutDailyAssignmentsInput, RegionUncheckedCreateWithoutDailyAssignmentsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutDailyAssignmentsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutDailyAssignmentsInput, RegionUncheckedUpdateWithoutDailyAssignmentsInput>
  }

  export type RegionUpdateWithoutDailyAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUpdateManyWithoutRegionNestedInput
    regionFractions?: RegionFractionUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutDailyAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unitName?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    points?: PointUncheckedUpdateManyWithoutRegionNestedInput
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutRegionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type VehicleUpsertWithoutDailyAssignmentsInput = {
    update: XOR<VehicleUpdateWithoutDailyAssignmentsInput, VehicleUncheckedUpdateWithoutDailyAssignmentsInput>
    create: XOR<VehicleCreateWithoutDailyAssignmentsInput, VehicleUncheckedCreateWithoutDailyAssignmentsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutDailyAssignmentsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutDailyAssignmentsInput, VehicleUncheckedUpdateWithoutDailyAssignmentsInput>
  }

  export type VehicleUpdateWithoutDailyAssignmentsInput = {
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
    faultReports?: VehicleFaultReportUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutDailyAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
    faultReports?: VehicleFaultReportUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type EmployeeUpsertWithoutDrivenAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutDrivenAssignmentsInput, EmployeeUncheckedUpdateWithoutDrivenAssignmentsInput>
    create: XOR<EmployeeCreateWithoutDrivenAssignmentsInput, EmployeeUncheckedCreateWithoutDrivenAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDrivenAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDrivenAssignmentsInput, EmployeeUncheckedUpdateWithoutDrivenAssignmentsInput>
  }

  export type EmployeeUpdateWithoutDrivenAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUpdateManyWithoutEmployeeNestedInput
    assistantAssignments?: DailyAssignmentAssistantUpdateManyWithoutEmployeeNestedInput
    workCardEntries?: WorkCardEntryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDrivenAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUncheckedUpdateManyWithoutEmployeeNestedInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeNestedInput
    workCardEntries?: WorkCardEntryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type DailyAssignmentAssistantUpsertWithWhereUniqueWithoutDailyAssignmentInput = {
    where: DailyAssignmentAssistantWhereUniqueInput
    update: XOR<DailyAssignmentAssistantUpdateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedUpdateWithoutDailyAssignmentInput>
    create: XOR<DailyAssignmentAssistantCreateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedCreateWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentAssistantUpdateWithWhereUniqueWithoutDailyAssignmentInput = {
    where: DailyAssignmentAssistantWhereUniqueInput
    data: XOR<DailyAssignmentAssistantUpdateWithoutDailyAssignmentInput, DailyAssignmentAssistantUncheckedUpdateWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentAssistantUpdateManyWithWhereWithoutDailyAssignmentInput = {
    where: DailyAssignmentAssistantScalarWhereInput
    data: XOR<DailyAssignmentAssistantUpdateManyMutationInput, DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentFractionUpsertWithWhereUniqueWithoutDailyAssignmentInput = {
    where: DailyAssignmentFractionWhereUniqueInput
    update: XOR<DailyAssignmentFractionUpdateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedUpdateWithoutDailyAssignmentInput>
    create: XOR<DailyAssignmentFractionCreateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedCreateWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentFractionUpdateWithWhereUniqueWithoutDailyAssignmentInput = {
    where: DailyAssignmentFractionWhereUniqueInput
    data: XOR<DailyAssignmentFractionUpdateWithoutDailyAssignmentInput, DailyAssignmentFractionUncheckedUpdateWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentFractionUpdateManyWithWhereWithoutDailyAssignmentInput = {
    where: DailyAssignmentFractionScalarWhereInput
    data: XOR<DailyAssignmentFractionUpdateManyMutationInput, DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentInput>
  }

  export type DailyAssignmentCreateWithoutAssistantsInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    municipality?: MunicipalityCreateNestedOneWithoutDailyAssignmentsInput
    region: RegionCreateNestedOneWithoutDailyAssignmentsInput
    vehicle: VehicleCreateNestedOneWithoutDailyAssignmentsInput
    driver?: EmployeeCreateNestedOneWithoutDrivenAssignmentsInput
    fractions?: DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateWithoutAssistantsInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    fractions?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentCreateOrConnectWithoutAssistantsInput = {
    where: DailyAssignmentWhereUniqueInput
    create: XOR<DailyAssignmentCreateWithoutAssistantsInput, DailyAssignmentUncheckedCreateWithoutAssistantsInput>
  }

  export type EmployeeCreateWithoutAssistantAssignmentsInput = {
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleCreateNestedManyWithoutEmployeeInput
    drivenAssignments?: DailyAssignmentCreateNestedManyWithoutDriverInput
    workCardEntries?: WorkCardEntryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAssistantAssignmentsInput = {
    id?: number
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleUncheckedCreateNestedManyWithoutEmployeeInput
    drivenAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutDriverInput
    workCardEntries?: WorkCardEntryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAssistantAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAssistantAssignmentsInput, EmployeeUncheckedCreateWithoutAssistantAssignmentsInput>
  }

  export type DailyAssignmentUpsertWithoutAssistantsInput = {
    update: XOR<DailyAssignmentUpdateWithoutAssistantsInput, DailyAssignmentUncheckedUpdateWithoutAssistantsInput>
    create: XOR<DailyAssignmentCreateWithoutAssistantsInput, DailyAssignmentUncheckedCreateWithoutAssistantsInput>
    where?: DailyAssignmentWhereInput
  }

  export type DailyAssignmentUpdateToOneWithWhereWithoutAssistantsInput = {
    where?: DailyAssignmentWhereInput
    data: XOR<DailyAssignmentUpdateWithoutAssistantsInput, DailyAssignmentUncheckedUpdateWithoutAssistantsInput>
  }

  export type DailyAssignmentUpdateWithoutAssistantsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput
    region?: RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    driver?: EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput
    fractions?: DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateWithoutAssistantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    fractions?: DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type EmployeeUpsertWithoutAssistantAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutAssistantAssignmentsInput, EmployeeUncheckedUpdateWithoutAssistantAssignmentsInput>
    create: XOR<EmployeeCreateWithoutAssistantAssignmentsInput, EmployeeUncheckedCreateWithoutAssistantAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAssistantAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAssistantAssignmentsInput, EmployeeUncheckedUpdateWithoutAssistantAssignmentsInput>
  }

  export type EmployeeUpdateWithoutAssistantAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUpdateManyWithoutEmployeeNestedInput
    drivenAssignments?: DailyAssignmentUpdateManyWithoutDriverNestedInput
    workCardEntries?: WorkCardEntryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAssistantAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUncheckedUpdateManyWithoutEmployeeNestedInput
    drivenAssignments?: DailyAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    workCardEntries?: WorkCardEntryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type DailyAssignmentCreateWithoutFractionsInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    municipality?: MunicipalityCreateNestedOneWithoutDailyAssignmentsInput
    region: RegionCreateNestedOneWithoutDailyAssignmentsInput
    vehicle: VehicleCreateNestedOneWithoutDailyAssignmentsInput
    driver?: EmployeeCreateNestedOneWithoutDrivenAssignmentsInput
    assistants?: DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateWithoutFractionsInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    assistants?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentCreateOrConnectWithoutFractionsInput = {
    where: DailyAssignmentWhereUniqueInput
    create: XOR<DailyAssignmentCreateWithoutFractionsInput, DailyAssignmentUncheckedCreateWithoutFractionsInput>
  }

  export type FractionCreateWithoutFractionsInAssignmentsInput = {
    name: string
    code: string
    color: string
    pointFractions?: PointFractionCreateNestedManyWithoutFractionInput
    regionFractions?: RegionFractionCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryCreateNestedManyWithoutFractionInput
  }

  export type FractionUncheckedCreateWithoutFractionsInAssignmentsInput = {
    id?: number
    name: string
    code: string
    color: string
    pointFractions?: PointFractionUncheckedCreateNestedManyWithoutFractionInput
    regionFractions?: RegionFractionUncheckedCreateNestedManyWithoutFractionInput
    calendarEntries?: CalendarEntryUncheckedCreateNestedManyWithoutFractionInput
  }

  export type FractionCreateOrConnectWithoutFractionsInAssignmentsInput = {
    where: FractionWhereUniqueInput
    create: XOR<FractionCreateWithoutFractionsInAssignmentsInput, FractionUncheckedCreateWithoutFractionsInAssignmentsInput>
  }

  export type DailyAssignmentUpsertWithoutFractionsInput = {
    update: XOR<DailyAssignmentUpdateWithoutFractionsInput, DailyAssignmentUncheckedUpdateWithoutFractionsInput>
    create: XOR<DailyAssignmentCreateWithoutFractionsInput, DailyAssignmentUncheckedCreateWithoutFractionsInput>
    where?: DailyAssignmentWhereInput
  }

  export type DailyAssignmentUpdateToOneWithWhereWithoutFractionsInput = {
    where?: DailyAssignmentWhereInput
    data: XOR<DailyAssignmentUpdateWithoutFractionsInput, DailyAssignmentUncheckedUpdateWithoutFractionsInput>
  }

  export type DailyAssignmentUpdateWithoutFractionsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput
    region?: RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    driver?: EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput
    assistants?: DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateWithoutFractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type FractionUpsertWithoutFractionsInAssignmentsInput = {
    update: XOR<FractionUpdateWithoutFractionsInAssignmentsInput, FractionUncheckedUpdateWithoutFractionsInAssignmentsInput>
    create: XOR<FractionCreateWithoutFractionsInAssignmentsInput, FractionUncheckedCreateWithoutFractionsInAssignmentsInput>
    where?: FractionWhereInput
  }

  export type FractionUpdateToOneWithWhereWithoutFractionsInAssignmentsInput = {
    where?: FractionWhereInput
    data: XOR<FractionUpdateWithoutFractionsInAssignmentsInput, FractionUncheckedUpdateWithoutFractionsInAssignmentsInput>
  }

  export type FractionUpdateWithoutFractionsInAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUpdateManyWithoutFractionNestedInput
    regionFractions?: RegionFractionUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUpdateManyWithoutFractionNestedInput
  }

  export type FractionUncheckedUpdateWithoutFractionsInAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    pointFractions?: PointFractionUncheckedUpdateManyWithoutFractionNestedInput
    regionFractions?: RegionFractionUncheckedUpdateManyWithoutFractionNestedInput
    calendarEntries?: CalendarEntryUncheckedUpdateManyWithoutFractionNestedInput
  }

  export type VehicleCreateWithoutFaultReportsInput = {
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
    dailyAssignments?: DailyAssignmentCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutFaultReportsInput = {
    id?: number
    brand: string
    registrationNumber: string
    vehicleType: string
    capacity: number
    fuelType: string
    purchaseDate?: Date | string | null
    isActive?: boolean
    faultStatus?: string
    dailyAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutFaultReportsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutFaultReportsInput, VehicleUncheckedCreateWithoutFaultReportsInput>
  }

  export type VehicleUpsertWithoutFaultReportsInput = {
    update: XOR<VehicleUpdateWithoutFaultReportsInput, VehicleUncheckedUpdateWithoutFaultReportsInput>
    create: XOR<VehicleCreateWithoutFaultReportsInput, VehicleUncheckedCreateWithoutFaultReportsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutFaultReportsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutFaultReportsInput, VehicleUncheckedUpdateWithoutFaultReportsInput>
  }

  export type VehicleUpdateWithoutFaultReportsInput = {
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
    dailyAssignments?: DailyAssignmentUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutFaultReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    capacity?: FloatFieldUpdateOperationsInput | number
    fuelType?: StringFieldUpdateOperationsInput | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    faultStatus?: StringFieldUpdateOperationsInput | string
    dailyAssignments?: DailyAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type DailyAssignmentCreateWithoutMunicipalityInput = {
    date: Date | string
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    region: RegionCreateNestedOneWithoutDailyAssignmentsInput
    vehicle: VehicleCreateNestedOneWithoutDailyAssignmentsInput
    driver?: EmployeeCreateNestedOneWithoutDrivenAssignmentsInput
    assistants?: DailyAssignmentAssistantCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentUncheckedCreateWithoutMunicipalityInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
    assistants?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutDailyAssignmentInput
    fractions?: DailyAssignmentFractionUncheckedCreateNestedManyWithoutDailyAssignmentInput
  }

  export type DailyAssignmentCreateOrConnectWithoutMunicipalityInput = {
    where: DailyAssignmentWhereUniqueInput
    create: XOR<DailyAssignmentCreateWithoutMunicipalityInput, DailyAssignmentUncheckedCreateWithoutMunicipalityInput>
  }

  export type DailyAssignmentCreateManyMunicipalityInputEnvelope = {
    data: DailyAssignmentCreateManyMunicipalityInput | DailyAssignmentCreateManyMunicipalityInput[]
  }

  export type DailyAssignmentUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: DailyAssignmentWhereUniqueInput
    update: XOR<DailyAssignmentUpdateWithoutMunicipalityInput, DailyAssignmentUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<DailyAssignmentCreateWithoutMunicipalityInput, DailyAssignmentUncheckedCreateWithoutMunicipalityInput>
  }

  export type DailyAssignmentUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: DailyAssignmentWhereUniqueInput
    data: XOR<DailyAssignmentUpdateWithoutMunicipalityInput, DailyAssignmentUncheckedUpdateWithoutMunicipalityInput>
  }

  export type DailyAssignmentUpdateManyWithWhereWithoutMunicipalityInput = {
    where: DailyAssignmentScalarWhereInput
    data: XOR<DailyAssignmentUpdateManyMutationInput, DailyAssignmentUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type WorkCardEntryCreateWithoutAbsenceTypeInput = {
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutWorkCardEntriesInput
  }

  export type WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkCardEntryCreateOrConnectWithoutAbsenceTypeInput = {
    where: WorkCardEntryWhereUniqueInput
    create: XOR<WorkCardEntryCreateWithoutAbsenceTypeInput, WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput>
  }

  export type WorkCardEntryCreateManyAbsenceTypeInputEnvelope = {
    data: WorkCardEntryCreateManyAbsenceTypeInput | WorkCardEntryCreateManyAbsenceTypeInput[]
  }

  export type WorkCardEntryUpsertWithWhereUniqueWithoutAbsenceTypeInput = {
    where: WorkCardEntryWhereUniqueInput
    update: XOR<WorkCardEntryUpdateWithoutAbsenceTypeInput, WorkCardEntryUncheckedUpdateWithoutAbsenceTypeInput>
    create: XOR<WorkCardEntryCreateWithoutAbsenceTypeInput, WorkCardEntryUncheckedCreateWithoutAbsenceTypeInput>
  }

  export type WorkCardEntryUpdateWithWhereUniqueWithoutAbsenceTypeInput = {
    where: WorkCardEntryWhereUniqueInput
    data: XOR<WorkCardEntryUpdateWithoutAbsenceTypeInput, WorkCardEntryUncheckedUpdateWithoutAbsenceTypeInput>
  }

  export type WorkCardEntryUpdateManyWithWhereWithoutAbsenceTypeInput = {
    where: WorkCardEntryScalarWhereInput
    data: XOR<WorkCardEntryUpdateManyMutationInput, WorkCardEntryUncheckedUpdateManyWithoutAbsenceTypeInput>
  }

  export type EmployeeCreateWithoutWorkCardEntriesInput = {
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleCreateNestedManyWithoutEmployeeInput
    drivenAssignments?: DailyAssignmentCreateNestedManyWithoutDriverInput
    assistantAssignments?: DailyAssignmentAssistantCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWorkCardEntriesInput = {
    id?: number
    name: string
    surname: string
    position: string
    phone: string
    email?: string | null
    hiredAt?: Date | string | null
    terminatedAt?: Date | string | null
    notes?: string | null
    hasDisabilityCertificate?: boolean
    employeeSchedules?: EmployeeScheduleUncheckedCreateNestedManyWithoutEmployeeInput
    drivenAssignments?: DailyAssignmentUncheckedCreateNestedManyWithoutDriverInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWorkCardEntriesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkCardEntriesInput, EmployeeUncheckedCreateWithoutWorkCardEntriesInput>
  }

  export type RodzajAbsencjiCreateWithoutWorkCardEntriesInput = {
    name: string
    code?: string | null
    color?: string | null
    notes?: string | null
  }

  export type RodzajAbsencjiUncheckedCreateWithoutWorkCardEntriesInput = {
    id?: number
    name: string
    code?: string | null
    color?: string | null
    notes?: string | null
  }

  export type RodzajAbsencjiCreateOrConnectWithoutWorkCardEntriesInput = {
    where: RodzajAbsencjiWhereUniqueInput
    create: XOR<RodzajAbsencjiCreateWithoutWorkCardEntriesInput, RodzajAbsencjiUncheckedCreateWithoutWorkCardEntriesInput>
  }

  export type EmployeeUpsertWithoutWorkCardEntriesInput = {
    update: XOR<EmployeeUpdateWithoutWorkCardEntriesInput, EmployeeUncheckedUpdateWithoutWorkCardEntriesInput>
    create: XOR<EmployeeCreateWithoutWorkCardEntriesInput, EmployeeUncheckedCreateWithoutWorkCardEntriesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkCardEntriesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkCardEntriesInput, EmployeeUncheckedUpdateWithoutWorkCardEntriesInput>
  }

  export type EmployeeUpdateWithoutWorkCardEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUpdateManyWithoutEmployeeNestedInput
    drivenAssignments?: DailyAssignmentUpdateManyWithoutDriverNestedInput
    assistantAssignments?: DailyAssignmentAssistantUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkCardEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    surname?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    hasDisabilityCertificate?: BoolFieldUpdateOperationsInput | boolean
    employeeSchedules?: EmployeeScheduleUncheckedUpdateManyWithoutEmployeeNestedInput
    drivenAssignments?: DailyAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    assistantAssignments?: DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type RodzajAbsencjiUpsertWithoutWorkCardEntriesInput = {
    update: XOR<RodzajAbsencjiUpdateWithoutWorkCardEntriesInput, RodzajAbsencjiUncheckedUpdateWithoutWorkCardEntriesInput>
    create: XOR<RodzajAbsencjiCreateWithoutWorkCardEntriesInput, RodzajAbsencjiUncheckedCreateWithoutWorkCardEntriesInput>
    where?: RodzajAbsencjiWhereInput
  }

  export type RodzajAbsencjiUpdateToOneWithWhereWithoutWorkCardEntriesInput = {
    where?: RodzajAbsencjiWhereInput
    data: XOR<RodzajAbsencjiUpdateWithoutWorkCardEntriesInput, RodzajAbsencjiUncheckedUpdateWithoutWorkCardEntriesInput>
  }

  export type RodzajAbsencjiUpdateWithoutWorkCardEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RodzajAbsencjiUncheckedUpdateWithoutWorkCardEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    uploadedAttachments?: DocumentAttachmentCreateNestedManyWithoutUploaderInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    uploadedAttachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type UserCreateWithoutDeletedDocumentsInput = {
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    uploadedAttachments?: DocumentAttachmentCreateNestedManyWithoutUploaderInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeletedDocumentsInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    uploadedAttachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutUploaderInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeletedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
  }

  export type DocumentAttachmentCreateWithoutDocumentInput = {
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isDeleted?: boolean
    uploader: UserCreateNestedOneWithoutUploadedAttachmentsInput
  }

  export type DocumentAttachmentUncheckedCreateWithoutDocumentInput = {
    id?: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    isDeleted?: boolean
  }

  export type DocumentAttachmentCreateOrConnectWithoutDocumentInput = {
    where: DocumentAttachmentWhereUniqueInput
    create: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAttachmentCreateManyDocumentInputEnvelope = {
    data: DocumentAttachmentCreateManyDocumentInput | DocumentAttachmentCreateManyDocumentInput[]
  }

  export type DocumentAnnotationCreateWithoutDocumentInput = {
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAnnotationsInput
  }

  export type DocumentAnnotationUncheckedCreateWithoutDocumentInput = {
    id?: number
    userId: number
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentAnnotationCreateOrConnectWithoutDocumentInput = {
    where: DocumentAnnotationWhereUniqueInput
    create: XOR<DocumentAnnotationCreateWithoutDocumentInput, DocumentAnnotationUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAnnotationCreateManyDocumentInputEnvelope = {
    data: DocumentAnnotationCreateManyDocumentInput | DocumentAnnotationCreateManyDocumentInput[]
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    uploadedAttachments?: DocumentAttachmentUpdateManyWithoutUploaderNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    uploadedAttachments?: DocumentAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDeletedDocumentsInput = {
    update: XOR<UserUpdateWithoutDeletedDocumentsInput, UserUncheckedUpdateWithoutDeletedDocumentsInput>
    create: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletedDocumentsInput, UserUncheckedUpdateWithoutDeletedDocumentsInput>
  }

  export type UserUpdateWithoutDeletedDocumentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    uploadedAttachments?: DocumentAttachmentUpdateManyWithoutUploaderNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletedDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    uploadedAttachments?: DocumentAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAttachmentWhereUniqueInput
    update: XOR<DocumentAttachmentUpdateWithoutDocumentInput, DocumentAttachmentUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentAttachmentCreateWithoutDocumentInput, DocumentAttachmentUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAttachmentWhereUniqueInput
    data: XOR<DocumentAttachmentUpdateWithoutDocumentInput, DocumentAttachmentUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentAttachmentUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentAttachmentScalarWhereInput
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentAnnotationUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAnnotationWhereUniqueInput
    update: XOR<DocumentAnnotationUpdateWithoutDocumentInput, DocumentAnnotationUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentAnnotationCreateWithoutDocumentInput, DocumentAnnotationUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentAnnotationUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentAnnotationWhereUniqueInput
    data: XOR<DocumentAnnotationUpdateWithoutDocumentInput, DocumentAnnotationUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentAnnotationUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentAnnotationScalarWhereInput
    data: XOR<DocumentAnnotationUpdateManyMutationInput, DocumentAnnotationUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutAttachmentsInput = {
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedBy?: number | null
    deletedAt?: Date | string | null
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutAttachmentsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAttachmentsInput, DocumentUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutUploadedAttachmentsInput = {
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    annotations?: DocumentAnnotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedAttachmentsInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    annotations?: DocumentAnnotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
  }

  export type DocumentUpsertWithoutAttachmentsInput = {
    update: XOR<DocumentUpdateWithoutAttachmentsInput, DocumentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<DocumentCreateWithoutAttachmentsInput, DocumentUncheckedCreateWithoutAttachmentsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutAttachmentsInput, DocumentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type DocumentUpdateWithoutAttachmentsInput = {
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserUpsertWithoutUploadedAttachmentsInput = {
    update: XOR<UserUpdateWithoutUploadedAttachmentsInput, UserUncheckedUpdateWithoutUploadedAttachmentsInput>
    create: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedAttachmentsInput, UserUncheckedUpdateWithoutUploadedAttachmentsInput>
  }

  export type UserUpdateWithoutUploadedAttachmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentCreateWithoutAnnotationsInput = {
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutAnnotationsInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedBy?: number | null
    deletedAt?: Date | string | null
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutAnnotationsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAnnotationsInput, DocumentUncheckedCreateWithoutAnnotationsInput>
  }

  export type UserCreateWithoutAnnotationsInput = {
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    uploadedAttachments?: DocumentAttachmentCreateNestedManyWithoutUploaderInput
  }

  export type UserUncheckedCreateWithoutAnnotationsInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    isActive?: boolean
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    uploadedAttachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutAnnotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
  }

  export type DocumentUpsertWithoutAnnotationsInput = {
    update: XOR<DocumentUpdateWithoutAnnotationsInput, DocumentUncheckedUpdateWithoutAnnotationsInput>
    create: XOR<DocumentCreateWithoutAnnotationsInput, DocumentUncheckedCreateWithoutAnnotationsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutAnnotationsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutAnnotationsInput, DocumentUncheckedUpdateWithoutAnnotationsInput>
  }

  export type DocumentUpdateWithoutAnnotationsInput = {
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAnnotationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserUpsertWithoutAnnotationsInput = {
    update: XOR<UserUpdateWithoutAnnotationsInput, UserUncheckedUpdateWithoutAnnotationsInput>
    create: XOR<UserCreateWithoutAnnotationsInput, UserUncheckedCreateWithoutAnnotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnotationsInput, UserUncheckedUpdateWithoutAnnotationsInput>
  }

  export type UserUpdateWithoutAnnotationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    uploadedAttachments?: DocumentAttachmentUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnotationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    uploadedAttachments?: DocumentAttachmentUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type DocumentCreateManyUploaderInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedBy?: number | null
    deletedAt?: Date | string | null
  }

  export type DocumentCreateManyDeleterInput = {
    id?: number
    contractNumber?: string | null
    parties: string
    description?: string | null
    tags?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type DocumentAttachmentCreateManyUploaderInput = {
    id?: number
    documentId: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedAt?: Date | string
    isDeleted?: boolean
  }

  export type DocumentAnnotationCreateManyUserInput = {
    id?: number
    documentId: number
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutUploaderInput = {
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedBy?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUpdateWithoutDeleterInput = {
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentNestedInput
    annotations?: DocumentAnnotationUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentNestedInput
    annotations?: DocumentAnnotationUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    parties?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentAttachmentUpdateWithoutUploaderInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    document?: DocumentUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAnnotationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type DocumentAnnotationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAnnotationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeScheduleCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    shift: string
    customHours?: string | null
    colorCode?: string | null
  }

  export type DailyAssignmentCreateManyDriverInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
  }

  export type DailyAssignmentAssistantCreateManyEmployeeInput = {
    id?: number
    dailyAssignmentId: number
  }

  export type WorkCardEntryCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    absenceTypeId?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeScheduleUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeScheduleUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeScheduleUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: StringFieldUpdateOperationsInput | string
    customHours?: NullableStringFieldUpdateOperationsInput | string | null
    colorCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyAssignmentUpdateWithoutDriverInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput
    region?: RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    assistants?: DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyAssignmentAssistantUpdateWithoutEmployeeInput = {
    dailyAssignment?: DailyAssignmentUpdateOneRequiredWithoutAssistantsNestedInput
  }

  export type DailyAssignmentAssistantUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentAssistantUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
  }

  export type WorkCardEntryUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    absenceType?: RodzajAbsencjiUpdateOneWithoutWorkCardEntriesNestedInput
  }

  export type WorkCardEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    absenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkCardEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    absenceTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAssignmentCreateManyVehicleInput = {
    id?: number
    date: Date | string
    regionId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
  }

  export type VehicleFaultReportCreateManyVehicleInput = {
    id?: number
    reportedBy: string
    description?: string | null
    reportedAt?: Date | string
    resolvedAt?: Date | string | null
    isResolved?: boolean
  }

  export type DailyAssignmentUpdateWithoutVehicleInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput
    region?: RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    driver?: EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput
    assistants?: DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleFaultReportUpdateWithoutVehicleInput = {
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleFaultReportUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleFaultReportUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedBy?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PointCreateManyRegionInput = {
    id?: number
    type: string
    town: string
    street: string
    number: string
    notes?: string | null
    companyName?: string | null
    activityNotes?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isIndefinite?: boolean
    kompostownik?: boolean
  }

  export type RegionFractionCreateManyRegionInput = {
    id?: number
    fractionId: number
  }

  export type CalendarEntryCreateManyRegionInput = {
    id?: number
    fractionId: number
    date: Date | string
  }

  export type DailyAssignmentCreateManyRegionInput = {
    id?: number
    date: Date | string
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    municipalityId?: number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
  }

  export type PointUpdateWithoutRegionInput = {
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    pointFractions?: PointFractionUpdateManyWithoutPointNestedInput
  }

  export type PointUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
    pointFractions?: PointFractionUncheckedUpdateManyWithoutPointNestedInput
  }

  export type PointUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    town?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isIndefinite?: BoolFieldUpdateOperationsInput | boolean
    kompostownik?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegionFractionUpdateWithoutRegionInput = {
    fraction?: FractionUpdateOneRequiredWithoutRegionFractionsNestedInput
  }

  export type RegionFractionUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type RegionFractionUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type CalendarEntryUpdateWithoutRegionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fraction?: FractionUpdateOneRequiredWithoutCalendarEntriesNestedInput
  }

  export type CalendarEntryUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAssignmentUpdateWithoutRegionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    municipality?: MunicipalityUpdateOneWithoutDailyAssignmentsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    driver?: EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput
    assistants?: DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    municipalityId?: NullableIntFieldUpdateOperationsInput | number | null
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PointFractionCreateManyFractionInput = {
    id?: number
    pointId: number
    containerSize: string
    pickupFrequency: string
  }

  export type RegionFractionCreateManyFractionInput = {
    id?: number
    regionId: number
  }

  export type CalendarEntryCreateManyFractionInput = {
    id?: number
    regionId: number
    date: Date | string
  }

  export type DailyAssignmentFractionCreateManyFractionInput = {
    id?: number
    dailyAssignmentId: number
  }

  export type PointFractionUpdateWithoutFractionInput = {
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
    point?: PointUpdateOneRequiredWithoutPointFractionsNestedInput
  }

  export type PointFractionUncheckedUpdateWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pointId?: IntFieldUpdateOperationsInput | number
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PointFractionUncheckedUpdateManyWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pointId?: IntFieldUpdateOperationsInput | number
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type RegionFractionUpdateWithoutFractionInput = {
    region?: RegionUpdateOneRequiredWithoutRegionFractionsNestedInput
  }

  export type RegionFractionUncheckedUpdateWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type RegionFractionUncheckedUpdateManyWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type CalendarEntryUpdateWithoutFractionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    region?: RegionUpdateOneRequiredWithoutCalendarEntriesNestedInput
  }

  export type CalendarEntryUncheckedUpdateWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEntryUncheckedUpdateManyWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyAssignmentFractionUpdateWithoutFractionInput = {
    dailyAssignment?: DailyAssignmentUpdateOneRequiredWithoutFractionsNestedInput
  }

  export type DailyAssignmentFractionUncheckedUpdateWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentFractionUncheckedUpdateManyWithoutFractionInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyAssignmentId?: IntFieldUpdateOperationsInput | number
  }

  export type PointFractionCreateManyPointInput = {
    id?: number
    fractionId: number
    containerSize: string
    pickupFrequency: string
  }

  export type PointFractionUpdateWithoutPointInput = {
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
    fraction?: FractionUpdateOneRequiredWithoutPointFractionsNestedInput
  }

  export type PointFractionUncheckedUpdateWithoutPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type PointFractionUncheckedUpdateManyWithoutPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
    containerSize?: StringFieldUpdateOperationsInput | string
    pickupFrequency?: StringFieldUpdateOperationsInput | string
  }

  export type DailyAssignmentAssistantCreateManyDailyAssignmentInput = {
    id?: number
    employeeId: number
  }

  export type DailyAssignmentFractionCreateManyDailyAssignmentInput = {
    id?: number
    fractionId: number
  }

  export type DailyAssignmentAssistantUpdateWithoutDailyAssignmentInput = {
    employee?: EmployeeUpdateOneRequiredWithoutAssistantAssignmentsNestedInput
  }

  export type DailyAssignmentAssistantUncheckedUpdateWithoutDailyAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentFractionUpdateWithoutDailyAssignmentInput = {
    fraction?: FractionUpdateOneRequiredWithoutFractionsInAssignmentsNestedInput
  }

  export type DailyAssignmentFractionUncheckedUpdateWithoutDailyAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fractionId?: IntFieldUpdateOperationsInput | number
  }

  export type DailyAssignmentCreateManyMunicipalityInput = {
    id?: number
    date: Date | string
    regionId: number
    vehicleId: number
    driverId?: number | null
    type: $Enums.DailyAssignmentType
    shift: string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: string | null
  }

  export type DailyAssignmentUpdateWithoutMunicipalityInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    region?: RegionUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutDailyAssignmentsNestedInput
    driver?: EmployeeUpdateOneWithoutDrivenAssignmentsNestedInput
    assistants?: DailyAssignmentAssistantUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateWithoutMunicipalityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
    assistants?: DailyAssignmentAssistantUncheckedUpdateManyWithoutDailyAssignmentNestedInput
    fractions?: DailyAssignmentFractionUncheckedUpdateManyWithoutDailyAssignmentNestedInput
  }

  export type DailyAssignmentUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    regionId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumDailyAssignmentTypeFieldUpdateOperationsInput | $Enums.DailyAssignmentType
    shift?: StringFieldUpdateOperationsInput | string
    equipment?: NullableJsonNullValueInput | InputJsonValue
    workType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkCardEntryCreateManyAbsenceTypeInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualFrom?: string | null
    actualTo?: string | null
    actualTotal?: number | null
    onCall?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkCardEntryUpdateWithoutAbsenceTypeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutWorkCardEntriesNestedInput
  }

  export type WorkCardEntryUncheckedUpdateWithoutAbsenceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkCardEntryUncheckedUpdateManyWithoutAbsenceTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualFrom?: NullableStringFieldUpdateOperationsInput | string | null
    actualTo?: NullableStringFieldUpdateOperationsInput | string | null
    actualTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    onCall?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAttachmentCreateManyDocumentInput = {
    id?: number
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    uploadedBy: number
    uploadedAt?: Date | string
    isDeleted?: boolean
  }

  export type DocumentAnnotationCreateManyDocumentInput = {
    id?: number
    userId: number
    type: string
    page: number
    x?: number | null
    y?: number | null
    width?: number | null
    height?: number | null
    content?: string | null
    color?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentAttachmentUpdateWithoutDocumentInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    uploader?: UserUpdateOneRequiredWithoutUploadedAttachmentsNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentAnnotationUpdateWithoutDocumentInput = {
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type DocumentAnnotationUncheckedUpdateWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAnnotationUncheckedUpdateManyWithoutDocumentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    page?: IntFieldUpdateOperationsInput | number
    x?: NullableFloatFieldUpdateOperationsInput | number | null
    y?: NullableFloatFieldUpdateOperationsInput | number | null
    width?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}